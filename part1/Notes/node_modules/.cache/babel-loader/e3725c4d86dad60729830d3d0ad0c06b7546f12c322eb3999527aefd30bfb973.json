{"ast":null,"code":"'use strict';\n\nconst BaseClient = require('./BaseClient');\nconst ActionsManager = require('./actions/ActionsManager');\nconst ClientVoiceManager = require('./voice/ClientVoiceManager');\nconst WebSocketManager = require('./websocket/WebSocketManager');\nconst {\n  Error,\n  TypeError,\n  RangeError\n} = require('../errors');\nconst ChannelManager = require('../managers/ChannelManager');\nconst GuildEmojiManager = require('../managers/GuildEmojiManager');\nconst GuildManager = require('../managers/GuildManager');\nconst UserManager = require('../managers/UserManager');\nconst ShardClientUtil = require('../sharding/ShardClientUtil');\nconst ClientApplication = require('../structures/ClientApplication');\nconst GuildPreview = require('../structures/GuildPreview');\nconst GuildTemplate = require('../structures/GuildTemplate');\nconst Invite = require('../structures/Invite');\nconst VoiceRegion = require('../structures/VoiceRegion');\nconst Webhook = require('../structures/Webhook');\nconst Collection = require('../util/Collection');\nconst {\n  Events,\n  browser,\n  DefaultOptions\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Intents = require('../util/Intents');\nconst Permissions = require('../util/Permissions');\nconst Structures = require('../util/Structures');\n\n/**\n * The main hub for interacting with the Discord API, and the starting point for any bot.\n * @extends {BaseClient}\n */\nclass Client extends BaseClient {\n  /**\n   * @param {ClientOptions} [options] Options for the client\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(Object.assign({\n      _tokenType: 'Bot'\n    }, options));\n\n    // Obtain shard details from environment or if present, worker threads\n    let data = process.env;\n    try {\n      // Test if worker threads module is present and used\n      data = require('worker_threads').workerData || data;\n    } catch {\n      // Do nothing\n    }\n    if (this.options.shards === DefaultOptions.shards) {\n      if ('SHARDS' in data) {\n        this.options.shards = JSON.parse(data.SHARDS);\n      }\n    }\n    if (this.options.shardCount === DefaultOptions.shardCount) {\n      if ('SHARD_COUNT' in data) {\n        this.options.shardCount = Number(data.SHARD_COUNT);\n      } else if (Array.isArray(this.options.shards)) {\n        this.options.shardCount = this.options.shards.length;\n      }\n    }\n    const typeofShards = typeof this.options.shards;\n    if (typeofShards === 'undefined' && typeof this.options.shardCount === 'number') {\n      this.options.shards = Array.from({\n        length: this.options.shardCount\n      }, (_, i) => i);\n    }\n    if (typeofShards === 'number') this.options.shards = [this.options.shards];\n    if (Array.isArray(this.options.shards)) {\n      this.options.shards = [...new Set(this.options.shards.filter(item => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)))];\n    }\n    this._validateOptions();\n\n    /**\n     * The WebSocket manager of the client\n     * @type {WebSocketManager}\n     */\n    this.ws = new WebSocketManager(this);\n\n    /**\n     * The action manager of the client\n     * @type {ActionsManager}\n     * @private\n     */\n    this.actions = new ActionsManager(this);\n\n    /**\n     * The voice manager of the client (`null` in browsers)\n     * @type {?ClientVoiceManager}\n     */\n    this.voice = !browser ? new ClientVoiceManager(this) : null;\n\n    /**\n     * Shard helpers for the client (only if the process was spawned from a {@link ShardingManager})\n     * @type {?ShardClientUtil}\n     */\n    this.shard = !browser && process.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE) : null;\n\n    /**\n     * All of the {@link User} objects that have been cached at any point, mapped by their IDs\n     * @type {UserManager}\n     */\n    this.users = new UserManager(this);\n\n    /**\n     * All of the guilds the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* guild the bot is a member of\n     * @type {GuildManager}\n     */\n    this.guilds = new GuildManager(this);\n\n    /**\n     * All of the {@link Channel}s that the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* channel in *every* guild the bot\n     * is a member of. Note that DM channels will not be initially cached, and thus not be present\n     * in the Manager without their explicit fetching or use.\n     * @type {ChannelManager}\n     */\n    this.channels = new ChannelManager(this);\n    const ClientPresence = Structures.get('ClientPresence');\n    /**\n     * The presence of the Client\n     * @private\n     * @type {ClientPresence}\n     */\n    this.presence = new ClientPresence(this);\n    Object.defineProperty(this, 'token', {\n      writable: true\n    });\n    if (!browser && !this.token && 'DISCORD_TOKEN' in process.env) {\n      /**\n       * Authorization token for the logged in bot.\n       * If present, this defaults to `process.env.DISCORD_TOKEN` when instantiating the client\n       * <warn>This should be kept private at all times.</warn>\n       * @type {?string}\n       */\n      this.token = process.env.DISCORD_TOKEN;\n    } else {\n      this.token = null;\n    }\n\n    /**\n     * User that the client is logged in as\n     * @type {?ClientUser}\n     */\n    this.user = null;\n\n    /**\n     * Time at which the client was last regarded as being in the `READY` state\n     * (each time the client disconnects and successfully reconnects, this will be overwritten)\n     * @type {?Date}\n     */\n    this.readyAt = null;\n    if (this.options.messageSweepInterval > 0) {\n      this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1000);\n    }\n  }\n\n  /**\n   * All custom emojis that the client has access to, mapped by their IDs\n   * @type {GuildEmojiManager}\n   * @readonly\n   */\n  get emojis() {\n    const emojis = new GuildEmojiManager({\n      client: this\n    });\n    for (const guild of this.guilds.cache.values()) {\n      if (guild.available) for (const emoji of guild.emojis.cache.values()) emojis.cache.set(emoji.id, emoji);\n    }\n    return emojis;\n  }\n\n  /**\n   * Timestamp of the time the client was last `READY` at\n   * @type {?number}\n   * @readonly\n   */\n  get readyTimestamp() {\n    return this.readyAt ? this.readyAt.getTime() : null;\n  }\n\n  /**\n   * How long it has been since the client last entered the `READY` state in milliseconds\n   * @type {?number}\n   * @readonly\n   */\n  get uptime() {\n    return this.readyAt ? Date.now() - this.readyAt : null;\n  }\n\n  /**\n   * Logs the client in, establishing a websocket connection to Discord.\n   * @param {string} [token=this.token] Token of the account to log in with\n   * @returns {Promise<string>} Token of the account used\n   * @example\n   * client.login('my token');\n   */\n  async login() {\n    let token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.token;\n    if (!token || typeof token !== 'string') throw new Error('TOKEN_INVALID');\n    this.token = token = token.replace(/^(Bot|Bearer)\\s*/i, '');\n    this.emit(Events.DEBUG, `Provided token: ${token.split('.').map((val, i) => i > 1 ? val.replace(/./g, '*') : val).join('.')}`);\n    if (this.options.presence) {\n      this.options.ws.presence = await this.presence._parse(this.options.presence);\n    }\n    this.emit(Events.DEBUG, 'Preparing to connect to the gateway...');\n    try {\n      await this.ws.connect();\n      return this.token;\n    } catch (error) {\n      this.destroy();\n      throw error;\n    }\n  }\n\n  /**\n   * Logs out, terminates the connection to Discord, and destroys the client.\n   * @returns {void}\n   */\n  destroy() {\n    super.destroy();\n    this.ws.destroy();\n    this.token = null;\n  }\n\n  /**\n   * Obtains an invite from Discord.\n   * @param {InviteResolvable} invite Invite code or URL\n   * @returns {Promise<Invite>}\n   * @example\n   * client.fetchInvite('https://discord.gg/bRCvFy9')\n   *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))\n   *   .catch(console.error);\n   */\n  fetchInvite(invite) {\n    const code = DataResolver.resolveInviteCode(invite);\n    return this.api.invites(code).get({\n      query: {\n        with_counts: true\n      }\n    }).then(data => new Invite(this, data));\n  }\n\n  /**\n   * Obtains a template from Discord.\n   * @param {GuildTemplateResolvable} template Template code or URL\n   * @returns {Promise<GuildTemplate>}\n   * @example\n   * client.fetchGuildTemplate('https://discord.new/FKvmczH2HyUf')\n   *   .then(template => console.log(`Obtained template with code: ${template.code}`))\n   *   .catch(console.error);\n   */\n  fetchGuildTemplate(template) {\n    const code = DataResolver.resolveGuildTemplateCode(template);\n    return this.api.guilds.templates(code).get().then(data => new GuildTemplate(this, data));\n  }\n\n  /**\n   * Obtains a webhook from Discord.\n   * @param {Snowflake} id ID of the webhook\n   * @param {string} [token] Token for the webhook\n   * @returns {Promise<Webhook>}\n   * @example\n   * client.fetchWebhook('id', 'token')\n   *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))\n   *   .catch(console.error);\n   */\n  fetchWebhook(id, token) {\n    return this.api.webhooks(id, token).get().then(data => new Webhook(this, data));\n  }\n\n  /**\n   * Obtains the available voice regions from Discord.\n   * @returns {Promise<Collection<string, VoiceRegion>>}\n   * @example\n   * client.fetchVoiceRegions()\n   *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))\n   *   .catch(console.error);\n   */\n  fetchVoiceRegions() {\n    return this.api.voice.regions.get().then(res => {\n      const regions = new Collection();\n      for (const region of res) regions.set(region.id, new VoiceRegion(region));\n      return regions;\n    });\n  }\n\n  /**\n   * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.\n   * If the message has been edited, the time of the edit is used rather than the time of the original message.\n   * @param {number} [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)\n   * will be removed from the caches. The default is based on {@link ClientOptions#messageCacheLifetime}\n   * @returns {number} Amount of messages that were removed from the caches,\n   * or -1 if the message cache lifetime is unlimited\n   * @example\n   * // Remove all messages older than 1800 seconds from the messages cache\n   * const amount = client.sweepMessages(1800);\n   * console.log(`Successfully removed ${amount} messages from the cache.`);\n   */\n  sweepMessages() {\n    let lifetime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.messageCacheLifetime;\n    if (typeof lifetime !== 'number' || isNaN(lifetime)) {\n      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');\n    }\n    if (lifetime <= 0) {\n      this.emit(Events.DEBUG, \"Didn't sweep messages - lifetime is unlimited\");\n      return -1;\n    }\n    const lifetimeMs = lifetime * 1000;\n    const now = Date.now();\n    let channels = 0;\n    let messages = 0;\n    for (const channel of this.channels.cache.values()) {\n      if (!channel.messages) continue;\n      channels++;\n      messages += channel.messages.cache.sweep(message => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs);\n    }\n    this.emit(Events.DEBUG, `Swept ${messages} messages older than ${lifetime} seconds in ${channels} text-based channels`);\n    return messages;\n  }\n\n  /**\n   * Obtains the OAuth Application of this bot from Discord.\n   * @returns {Promise<ClientApplication>}\n   */\n  fetchApplication() {\n    return this.api.oauth2.applications('@me').get().then(app => new ClientApplication(this, app));\n  }\n\n  /**\n   * Obtains a guild preview from Discord, available for all guilds the bot is in and all Discoverable guilds.\n   * @param {GuildResolvable} guild The guild to fetch the preview for\n   * @returns {Promise<GuildPreview>}\n   */\n  fetchGuildPreview(guild) {\n    const id = this.guilds.resolveID(guild);\n    if (!id) throw new TypeError('INVALID_TYPE', 'guild', 'GuildResolvable');\n    return this.api.guilds(id).preview.get().then(data => new GuildPreview(this, data));\n  }\n\n  /**\n   * Generates a link that can be used to invite the bot to a guild.\n   * @param {InviteGenerationOptions|PermissionResolvable} [options] Permissions to request\n   * @returns {Promise<string>}\n   * @example\n   * client.generateInvite({\n   *   permissions: ['SEND_MESSAGES', 'MANAGE_GUILD', 'MENTION_EVERYONE'],\n   * })\n   *   .then(link => console.log(`Generated bot invite link: ${link}`))\n   *   .catch(console.error);\n   */\n  async generateInvite() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (Array.isArray(options) || ['string', 'number'].includes(typeof options) || options instanceof Permissions) {\n      process.emitWarning('Client#generateInvite: Generate invite with an options object instead of a PermissionResolvable', 'DeprecationWarning');\n      options = {\n        permissions: options\n      };\n    }\n    const application = await this.fetchApplication();\n    const query = new URLSearchParams({\n      client_id: application.id,\n      permissions: Permissions.resolve(options.permissions),\n      scope: 'bot'\n    });\n    if (typeof options.disableGuildSelect === 'boolean') {\n      query.set('disable_guild_select', options.disableGuildSelect.toString());\n    }\n    if (typeof options.guild !== 'undefined') {\n      const guildID = this.guilds.resolveID(options.guild);\n      if (!guildID) throw new TypeError('INVALID_TYPE', 'options.guild', 'GuildResolvable');\n      query.set('guild_id', guildID);\n    }\n    return `${this.options.http.api}${this.api.oauth2.authorize}?${query}`;\n  }\n  toJSON() {\n    return super.toJSON({\n      readyAt: false\n    });\n  }\n\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script\n   * with the client as `this`.\n   * @param {string} script Script to eval\n   * @returns {*}\n   * @private\n   */\n  _eval(script) {\n    return eval(script);\n  }\n\n  /**\n   * Validates the client options.\n   * @param {ClientOptions} [options=this.options] Options to validate\n   * @private\n   */\n  _validateOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options;\n    if (typeof options.ws.intents !== 'undefined') {\n      options.ws.intents = Intents.resolve(options.ws.intents);\n    }\n    if (typeof options.shardCount !== 'number' || isNaN(options.shardCount) || options.shardCount < 1) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shardCount', 'a number greater than or equal to 1');\n    }\n    if (options.shards && !(options.shards === 'auto' || Array.isArray(options.shards))) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shards', \"'auto', a number or array of numbers\");\n    }\n    if (options.shards && !options.shards.length) throw new RangeError('CLIENT_INVALID_PROVIDED_SHARDS');\n    if (typeof options.messageCacheMaxSize !== 'number' || isNaN(options.messageCacheMaxSize)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageCacheMaxSize', 'a number');\n    }\n    if (typeof options.messageCacheLifetime !== 'number' || isNaN(options.messageCacheLifetime)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'The messageCacheLifetime', 'a number');\n    }\n    if (typeof options.messageSweepInterval !== 'number' || isNaN(options.messageSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageSweepInterval', 'a number');\n    }\n    if (typeof options.messageEditHistoryMaxSize !== 'number' || isNaN(options.messageEditHistoryMaxSize) || options.messageEditHistoryMaxSize < -1) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageEditHistoryMaxSize', 'a number greater than or equal to -1');\n    }\n    if (typeof options.fetchAllMembers !== 'boolean') {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'fetchAllMembers', 'a boolean');\n    }\n    if (typeof options.disableMentions !== 'string') {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'disableMentions', 'a string');\n    }\n    if (!Array.isArray(options.partials)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'partials', 'an Array');\n    }\n    if (typeof options.restWsBridgeTimeout !== 'number' || isNaN(options.restWsBridgeTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restWsBridgeTimeout', 'a number');\n    }\n    if (typeof options.restRequestTimeout !== 'number' || isNaN(options.restRequestTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restRequestTimeout', 'a number');\n    }\n    if (typeof options.restSweepInterval !== 'number' || isNaN(options.restSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restSweepInterval', 'a number');\n    }\n    if (typeof options.retryLimit !== 'number' || isNaN(options.retryLimit)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'retryLimit', 'a number');\n    }\n  }\n}\nmodule.exports = Client;\n\n/**\n * Options for {@link Client#generateInvite}.\n * @typedef {Object} InviteGenerationOptions\n * @property {PermissionResolvable} [permissions] Permissions to request\n * @property {GuildResolvable} [guild] Guild to preselect\n * @property {boolean} [disableGuildSelect] Whether to disable the guild selection\n */\n\n/**\n * Emitted for general warnings.\n * @event Client#warn\n * @param {string} info The warning\n */\n\n/**\n * Emitted for general debugging information.\n * @event Client#debug\n * @param {string} info The debug information\n */","map":{"version":3,"names":["BaseClient","require","ActionsManager","ClientVoiceManager","WebSocketManager","Error","TypeError","RangeError","ChannelManager","GuildEmojiManager","GuildManager","UserManager","ShardClientUtil","ClientApplication","GuildPreview","GuildTemplate","Invite","VoiceRegion","Webhook","Collection","Events","browser","DefaultOptions","DataResolver","Intents","Permissions","Structures","Client","constructor","options","Object","assign","_tokenType","data","process","env","workerData","shards","JSON","parse","SHARDS","shardCount","Number","SHARD_COUNT","Array","isArray","length","typeofShards","from","_","i","Set","filter","item","isNaN","Infinity","_validateOptions","ws","actions","voice","shard","SHARDING_MANAGER","singleton","SHARDING_MANAGER_MODE","users","guilds","channels","ClientPresence","get","presence","defineProperty","writable","token","DISCORD_TOKEN","user","readyAt","messageSweepInterval","setInterval","sweepMessages","bind","emojis","client","guild","cache","values","available","emoji","set","id","readyTimestamp","getTime","uptime","Date","now","login","replace","emit","DEBUG","split","map","val","join","_parse","connect","error","destroy","fetchInvite","invite","code","resolveInviteCode","api","invites","query","with_counts","then","fetchGuildTemplate","template","resolveGuildTemplateCode","templates","fetchWebhook","webhooks","fetchVoiceRegions","regions","res","region","lifetime","messageCacheLifetime","lifetimeMs","messages","channel","sweep","message","editedTimestamp","createdTimestamp","fetchApplication","oauth2","applications","app","fetchGuildPreview","resolveID","preview","generateInvite","includes","emitWarning","permissions","application","URLSearchParams","client_id","resolve","scope","disableGuildSelect","toString","guildID","http","authorize","toJSON","_eval","script","eval","intents","messageCacheMaxSize","messageEditHistoryMaxSize","fetchAllMembers","disableMentions","partials","restWsBridgeTimeout","restRequestTimeout","restSweepInterval","retryLimit","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/client/Client.js"],"sourcesContent":["'use strict';\n\nconst BaseClient = require('./BaseClient');\nconst ActionsManager = require('./actions/ActionsManager');\nconst ClientVoiceManager = require('./voice/ClientVoiceManager');\nconst WebSocketManager = require('./websocket/WebSocketManager');\nconst { Error, TypeError, RangeError } = require('../errors');\nconst ChannelManager = require('../managers/ChannelManager');\nconst GuildEmojiManager = require('../managers/GuildEmojiManager');\nconst GuildManager = require('../managers/GuildManager');\nconst UserManager = require('../managers/UserManager');\nconst ShardClientUtil = require('../sharding/ShardClientUtil');\nconst ClientApplication = require('../structures/ClientApplication');\nconst GuildPreview = require('../structures/GuildPreview');\nconst GuildTemplate = require('../structures/GuildTemplate');\nconst Invite = require('../structures/Invite');\nconst VoiceRegion = require('../structures/VoiceRegion');\nconst Webhook = require('../structures/Webhook');\nconst Collection = require('../util/Collection');\nconst { Events, browser, DefaultOptions } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Intents = require('../util/Intents');\nconst Permissions = require('../util/Permissions');\nconst Structures = require('../util/Structures');\n\n/**\n * The main hub for interacting with the Discord API, and the starting point for any bot.\n * @extends {BaseClient}\n */\nclass Client extends BaseClient {\n  /**\n   * @param {ClientOptions} [options] Options for the client\n   */\n  constructor(options = {}) {\n    super(Object.assign({ _tokenType: 'Bot' }, options));\n\n    // Obtain shard details from environment or if present, worker threads\n    let data = process.env;\n    try {\n      // Test if worker threads module is present and used\n      data = require('worker_threads').workerData || data;\n    } catch {\n      // Do nothing\n    }\n\n    if (this.options.shards === DefaultOptions.shards) {\n      if ('SHARDS' in data) {\n        this.options.shards = JSON.parse(data.SHARDS);\n      }\n    }\n\n    if (this.options.shardCount === DefaultOptions.shardCount) {\n      if ('SHARD_COUNT' in data) {\n        this.options.shardCount = Number(data.SHARD_COUNT);\n      } else if (Array.isArray(this.options.shards)) {\n        this.options.shardCount = this.options.shards.length;\n      }\n    }\n\n    const typeofShards = typeof this.options.shards;\n\n    if (typeofShards === 'undefined' && typeof this.options.shardCount === 'number') {\n      this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);\n    }\n\n    if (typeofShards === 'number') this.options.shards = [this.options.shards];\n\n    if (Array.isArray(this.options.shards)) {\n      this.options.shards = [\n        ...new Set(\n          this.options.shards.filter(item => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)),\n        ),\n      ];\n    }\n\n    this._validateOptions();\n\n    /**\n     * The WebSocket manager of the client\n     * @type {WebSocketManager}\n     */\n    this.ws = new WebSocketManager(this);\n\n    /**\n     * The action manager of the client\n     * @type {ActionsManager}\n     * @private\n     */\n    this.actions = new ActionsManager(this);\n\n    /**\n     * The voice manager of the client (`null` in browsers)\n     * @type {?ClientVoiceManager}\n     */\n    this.voice = !browser ? new ClientVoiceManager(this) : null;\n\n    /**\n     * Shard helpers for the client (only if the process was spawned from a {@link ShardingManager})\n     * @type {?ShardClientUtil}\n     */\n    this.shard =\n      !browser && process.env.SHARDING_MANAGER\n        ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE)\n        : null;\n\n    /**\n     * All of the {@link User} objects that have been cached at any point, mapped by their IDs\n     * @type {UserManager}\n     */\n    this.users = new UserManager(this);\n\n    /**\n     * All of the guilds the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* guild the bot is a member of\n     * @type {GuildManager}\n     */\n    this.guilds = new GuildManager(this);\n\n    /**\n     * All of the {@link Channel}s that the client is currently handling, mapped by their IDs -\n     * as long as sharding isn't being used, this will be *every* channel in *every* guild the bot\n     * is a member of. Note that DM channels will not be initially cached, and thus not be present\n     * in the Manager without their explicit fetching or use.\n     * @type {ChannelManager}\n     */\n    this.channels = new ChannelManager(this);\n\n    const ClientPresence = Structures.get('ClientPresence');\n    /**\n     * The presence of the Client\n     * @private\n     * @type {ClientPresence}\n     */\n    this.presence = new ClientPresence(this);\n\n    Object.defineProperty(this, 'token', { writable: true });\n    if (!browser && !this.token && 'DISCORD_TOKEN' in process.env) {\n      /**\n       * Authorization token for the logged in bot.\n       * If present, this defaults to `process.env.DISCORD_TOKEN` when instantiating the client\n       * <warn>This should be kept private at all times.</warn>\n       * @type {?string}\n       */\n      this.token = process.env.DISCORD_TOKEN;\n    } else {\n      this.token = null;\n    }\n\n    /**\n     * User that the client is logged in as\n     * @type {?ClientUser}\n     */\n    this.user = null;\n\n    /**\n     * Time at which the client was last regarded as being in the `READY` state\n     * (each time the client disconnects and successfully reconnects, this will be overwritten)\n     * @type {?Date}\n     */\n    this.readyAt = null;\n\n    if (this.options.messageSweepInterval > 0) {\n      this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1000);\n    }\n  }\n\n  /**\n   * All custom emojis that the client has access to, mapped by their IDs\n   * @type {GuildEmojiManager}\n   * @readonly\n   */\n  get emojis() {\n    const emojis = new GuildEmojiManager({ client: this });\n    for (const guild of this.guilds.cache.values()) {\n      if (guild.available) for (const emoji of guild.emojis.cache.values()) emojis.cache.set(emoji.id, emoji);\n    }\n    return emojis;\n  }\n\n  /**\n   * Timestamp of the time the client was last `READY` at\n   * @type {?number}\n   * @readonly\n   */\n  get readyTimestamp() {\n    return this.readyAt ? this.readyAt.getTime() : null;\n  }\n\n  /**\n   * How long it has been since the client last entered the `READY` state in milliseconds\n   * @type {?number}\n   * @readonly\n   */\n  get uptime() {\n    return this.readyAt ? Date.now() - this.readyAt : null;\n  }\n\n  /**\n   * Logs the client in, establishing a websocket connection to Discord.\n   * @param {string} [token=this.token] Token of the account to log in with\n   * @returns {Promise<string>} Token of the account used\n   * @example\n   * client.login('my token');\n   */\n  async login(token = this.token) {\n    if (!token || typeof token !== 'string') throw new Error('TOKEN_INVALID');\n    this.token = token = token.replace(/^(Bot|Bearer)\\s*/i, '');\n    this.emit(\n      Events.DEBUG,\n      `Provided token: ${token\n        .split('.')\n        .map((val, i) => (i > 1 ? val.replace(/./g, '*') : val))\n        .join('.')}`,\n    );\n\n    if (this.options.presence) {\n      this.options.ws.presence = await this.presence._parse(this.options.presence);\n    }\n\n    this.emit(Events.DEBUG, 'Preparing to connect to the gateway...');\n\n    try {\n      await this.ws.connect();\n      return this.token;\n    } catch (error) {\n      this.destroy();\n      throw error;\n    }\n  }\n\n  /**\n   * Logs out, terminates the connection to Discord, and destroys the client.\n   * @returns {void}\n   */\n  destroy() {\n    super.destroy();\n    this.ws.destroy();\n    this.token = null;\n  }\n\n  /**\n   * Obtains an invite from Discord.\n   * @param {InviteResolvable} invite Invite code or URL\n   * @returns {Promise<Invite>}\n   * @example\n   * client.fetchInvite('https://discord.gg/bRCvFy9')\n   *   .then(invite => console.log(`Obtained invite with code: ${invite.code}`))\n   *   .catch(console.error);\n   */\n  fetchInvite(invite) {\n    const code = DataResolver.resolveInviteCode(invite);\n    return this.api\n      .invites(code)\n      .get({ query: { with_counts: true } })\n      .then(data => new Invite(this, data));\n  }\n\n  /**\n   * Obtains a template from Discord.\n   * @param {GuildTemplateResolvable} template Template code or URL\n   * @returns {Promise<GuildTemplate>}\n   * @example\n   * client.fetchGuildTemplate('https://discord.new/FKvmczH2HyUf')\n   *   .then(template => console.log(`Obtained template with code: ${template.code}`))\n   *   .catch(console.error);\n   */\n  fetchGuildTemplate(template) {\n    const code = DataResolver.resolveGuildTemplateCode(template);\n    return this.api.guilds\n      .templates(code)\n      .get()\n      .then(data => new GuildTemplate(this, data));\n  }\n\n  /**\n   * Obtains a webhook from Discord.\n   * @param {Snowflake} id ID of the webhook\n   * @param {string} [token] Token for the webhook\n   * @returns {Promise<Webhook>}\n   * @example\n   * client.fetchWebhook('id', 'token')\n   *   .then(webhook => console.log(`Obtained webhook with name: ${webhook.name}`))\n   *   .catch(console.error);\n   */\n  fetchWebhook(id, token) {\n    return this.api\n      .webhooks(id, token)\n      .get()\n      .then(data => new Webhook(this, data));\n  }\n\n  /**\n   * Obtains the available voice regions from Discord.\n   * @returns {Promise<Collection<string, VoiceRegion>>}\n   * @example\n   * client.fetchVoiceRegions()\n   *   .then(regions => console.log(`Available regions are: ${regions.map(region => region.name).join(', ')}`))\n   *   .catch(console.error);\n   */\n  fetchVoiceRegions() {\n    return this.api.voice.regions.get().then(res => {\n      const regions = new Collection();\n      for (const region of res) regions.set(region.id, new VoiceRegion(region));\n      return regions;\n    });\n  }\n\n  /**\n   * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.\n   * If the message has been edited, the time of the edit is used rather than the time of the original message.\n   * @param {number} [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)\n   * will be removed from the caches. The default is based on {@link ClientOptions#messageCacheLifetime}\n   * @returns {number} Amount of messages that were removed from the caches,\n   * or -1 if the message cache lifetime is unlimited\n   * @example\n   * // Remove all messages older than 1800 seconds from the messages cache\n   * const amount = client.sweepMessages(1800);\n   * console.log(`Successfully removed ${amount} messages from the cache.`);\n   */\n  sweepMessages(lifetime = this.options.messageCacheLifetime) {\n    if (typeof lifetime !== 'number' || isNaN(lifetime)) {\n      throw new TypeError('INVALID_TYPE', 'lifetime', 'number');\n    }\n    if (lifetime <= 0) {\n      this.emit(Events.DEBUG, \"Didn't sweep messages - lifetime is unlimited\");\n      return -1;\n    }\n\n    const lifetimeMs = lifetime * 1000;\n    const now = Date.now();\n    let channels = 0;\n    let messages = 0;\n\n    for (const channel of this.channels.cache.values()) {\n      if (!channel.messages) continue;\n      channels++;\n\n      messages += channel.messages.cache.sweep(\n        message => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs,\n      );\n    }\n\n    this.emit(\n      Events.DEBUG,\n      `Swept ${messages} messages older than ${lifetime} seconds in ${channels} text-based channels`,\n    );\n    return messages;\n  }\n\n  /**\n   * Obtains the OAuth Application of this bot from Discord.\n   * @returns {Promise<ClientApplication>}\n   */\n  fetchApplication() {\n    return this.api.oauth2\n      .applications('@me')\n      .get()\n      .then(app => new ClientApplication(this, app));\n  }\n\n  /**\n   * Obtains a guild preview from Discord, available for all guilds the bot is in and all Discoverable guilds.\n   * @param {GuildResolvable} guild The guild to fetch the preview for\n   * @returns {Promise<GuildPreview>}\n   */\n  fetchGuildPreview(guild) {\n    const id = this.guilds.resolveID(guild);\n    if (!id) throw new TypeError('INVALID_TYPE', 'guild', 'GuildResolvable');\n    return this.api\n      .guilds(id)\n      .preview.get()\n      .then(data => new GuildPreview(this, data));\n  }\n\n  /**\n   * Generates a link that can be used to invite the bot to a guild.\n   * @param {InviteGenerationOptions|PermissionResolvable} [options] Permissions to request\n   * @returns {Promise<string>}\n   * @example\n   * client.generateInvite({\n   *   permissions: ['SEND_MESSAGES', 'MANAGE_GUILD', 'MENTION_EVERYONE'],\n   * })\n   *   .then(link => console.log(`Generated bot invite link: ${link}`))\n   *   .catch(console.error);\n   */\n  async generateInvite(options = {}) {\n    if (Array.isArray(options) || ['string', 'number'].includes(typeof options) || options instanceof Permissions) {\n      process.emitWarning(\n        'Client#generateInvite: Generate invite with an options object instead of a PermissionResolvable',\n        'DeprecationWarning',\n      );\n      options = { permissions: options };\n    }\n    const application = await this.fetchApplication();\n    const query = new URLSearchParams({\n      client_id: application.id,\n      permissions: Permissions.resolve(options.permissions),\n      scope: 'bot',\n    });\n    if (typeof options.disableGuildSelect === 'boolean') {\n      query.set('disable_guild_select', options.disableGuildSelect.toString());\n    }\n    if (typeof options.guild !== 'undefined') {\n      const guildID = this.guilds.resolveID(options.guild);\n      if (!guildID) throw new TypeError('INVALID_TYPE', 'options.guild', 'GuildResolvable');\n      query.set('guild_id', guildID);\n    }\n    return `${this.options.http.api}${this.api.oauth2.authorize}?${query}`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      readyAt: false,\n    });\n  }\n\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval} on a script\n   * with the client as `this`.\n   * @param {string} script Script to eval\n   * @returns {*}\n   * @private\n   */\n  _eval(script) {\n    return eval(script);\n  }\n\n  /**\n   * Validates the client options.\n   * @param {ClientOptions} [options=this.options] Options to validate\n   * @private\n   */\n  _validateOptions(options = this.options) {\n    if (typeof options.ws.intents !== 'undefined') {\n      options.ws.intents = Intents.resolve(options.ws.intents);\n    }\n    if (typeof options.shardCount !== 'number' || isNaN(options.shardCount) || options.shardCount < 1) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shardCount', 'a number greater than or equal to 1');\n    }\n    if (options.shards && !(options.shards === 'auto' || Array.isArray(options.shards))) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'shards', \"'auto', a number or array of numbers\");\n    }\n    if (options.shards && !options.shards.length) throw new RangeError('CLIENT_INVALID_PROVIDED_SHARDS');\n    if (typeof options.messageCacheMaxSize !== 'number' || isNaN(options.messageCacheMaxSize)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageCacheMaxSize', 'a number');\n    }\n    if (typeof options.messageCacheLifetime !== 'number' || isNaN(options.messageCacheLifetime)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'The messageCacheLifetime', 'a number');\n    }\n    if (typeof options.messageSweepInterval !== 'number' || isNaN(options.messageSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageSweepInterval', 'a number');\n    }\n    if (\n      typeof options.messageEditHistoryMaxSize !== 'number' ||\n      isNaN(options.messageEditHistoryMaxSize) ||\n      options.messageEditHistoryMaxSize < -1\n    ) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'messageEditHistoryMaxSize', 'a number greater than or equal to -1');\n    }\n    if (typeof options.fetchAllMembers !== 'boolean') {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'fetchAllMembers', 'a boolean');\n    }\n    if (typeof options.disableMentions !== 'string') {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'disableMentions', 'a string');\n    }\n    if (!Array.isArray(options.partials)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'partials', 'an Array');\n    }\n    if (typeof options.restWsBridgeTimeout !== 'number' || isNaN(options.restWsBridgeTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restWsBridgeTimeout', 'a number');\n    }\n    if (typeof options.restRequestTimeout !== 'number' || isNaN(options.restRequestTimeout)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restRequestTimeout', 'a number');\n    }\n    if (typeof options.restSweepInterval !== 'number' || isNaN(options.restSweepInterval)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'restSweepInterval', 'a number');\n    }\n    if (typeof options.retryLimit !== 'number' || isNaN(options.retryLimit)) {\n      throw new TypeError('CLIENT_INVALID_OPTION', 'retryLimit', 'a number');\n    }\n  }\n}\n\nmodule.exports = Client;\n\n/**\n * Options for {@link Client#generateInvite}.\n * @typedef {Object} InviteGenerationOptions\n * @property {PermissionResolvable} [permissions] Permissions to request\n * @property {GuildResolvable} [guild] Guild to preselect\n * @property {boolean} [disableGuildSelect] Whether to disable the guild selection\n */\n\n/**\n * Emitted for general warnings.\n * @event Client#warn\n * @param {string} info The warning\n */\n\n/**\n * Emitted for general debugging information.\n * @event Client#debug\n * @param {string} info The debug information\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}