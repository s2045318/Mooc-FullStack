{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\nconst {\n  Error,\n  TypeError\n} = require('../errors');\nconst Permissions = require('../util/Permissions');\nconst Snowflake = require('../util/Snowflake');\nconst Util = require('../util/Util');\n\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\nclass Role extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the role\n   * @param {Guild} guild The guild the role is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n    if (data) this._patch(data);\n  }\n  _patch(data) {\n    /**\n     * The ID of the role (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The name of the role\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The base 10 color of the role\n     * @type {number}\n     */\n    this.color = data.color;\n\n    /**\n     * If true, users that are part of this role will appear in a separate category in the users list\n     * @type {boolean}\n     */\n    this.hoist = data.hoist;\n\n    /**\n     * The raw position of the role from the API\n     * @type {number}\n     */\n    this.rawPosition = data.position;\n\n    /**\n     * The permissions of the role\n     * @type {Readonly<Permissions>}\n     */\n    this.permissions = new Permissions(data.permissions).freeze();\n\n    /**\n     * Whether or not the role is managed by an external service\n     * @type {boolean}\n     */\n    this.managed = data.managed;\n\n    /**\n     * Whether or not the role can be mentioned by anyone\n     * @type {boolean}\n     */\n    this.mentionable = data.mentionable;\n\n    /**\n     * Whether the role has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n  }\n\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.member(this.client.user);\n    if (!clientMember.permissions.has(Permissions.FLAGS.MANAGE_ROLES)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedRoles();\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n  comparePositionTo(role) {\n    role = this.guild.roles.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');\n    return this.constructor.comparePositions(this, role);\n  }\n\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    if (typeof data.permissions !== 'undefined') data.permissions = Permissions.resolve(data.permissions);else data.permissions = this.permissions.bitfield;\n    if (typeof data.position !== 'undefined') {\n      await Util.setPosition(this, data.position, false, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason).then(updatedRoles => {\n        this.client.actions.GuildRolesPositionUpdate.handle({\n          guild_id: this.guild.id,\n          roles: updatedRoles\n        });\n      });\n    }\n    return this.client.api.guilds[this.guild.id].roles[this.id].patch({\n      data: {\n        name: data.name || this.name,\n        color: data.color !== null ? Util.resolveColor(data.color || this.color) : null,\n        hoist: typeof data.hoist !== 'undefined' ? data.hoist : this.hoist,\n        permissions: data.permissions,\n        mentionable: typeof data.mentionable !== 'undefined' ? data.mentionable : this.mentionable\n      },\n      reason\n    }).then(role => {\n      const clone = this._clone();\n      clone._patch(role);\n      return clone;\n    });\n  }\n\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.rolePermissions(this);\n  }\n\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n  setColor(color, reason) {\n    return this.edit({\n      color\n    }, reason);\n  }\n\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} hoist Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n  setHoist(hoist, reason) {\n    return this.edit({\n      hoist\n    }, reason);\n  }\n\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions(['KICK_MEMBERS', 'BAN_MEMBERS'])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n  setPermissions(permissions, reason) {\n    return this.edit({\n      permissions\n    }, reason);\n  }\n\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} mentionable Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setMentionable(mentionable, reason) {\n    return this.edit({\n      mentionable\n    }, reason);\n  }\n\n  /**\n   * Sets the position of the role.\n   * @param {number} position The position of the role\n   * @param {Object} [options] Options for setting position\n   * @param {boolean} [options.relative=false] Change the position relative to its current value\n   * @param {string} [options.reason] Reason for changing the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Util.setPosition(this, position, relative, this.guild._sortedRoles(), this.client.api.guilds(this.guild.id).roles, reason).then(updatedRoles => {\n      this.client.actions.GuildRolesPositionUpdate.handle({\n        guild_id: this.guild.id,\n        roles: updatedRoles\n      });\n      return this;\n    });\n  }\n\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n  delete(reason) {\n    return this.client.api.guilds[this.guild.id].roles[this.id].delete({\n      reason\n    }).then(() => {\n      this.client.actions.GuildRoleDelete.handle({\n        guild_id: this.guild.id,\n        role_id: this.id\n      });\n      return this;\n    });\n  }\n\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n  equals(role) {\n    return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed;\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n  toJSON() {\n    return super.toJSON({\n      createdTimestamp: true\n    });\n  }\n\n  /**\n   * Compares the positions of two roles.\n   * @param {Role} role1 First role to compare\n   * @param {Role} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n  static comparePositions(role1, role2) {\n    if (role1.position === role2.position) return role2.id - role1.id;\n    return role1.position - role2.position;\n  }\n}\nmodule.exports = Role;","map":{"version":3,"names":["Base","require","Error","TypeError","Permissions","Snowflake","Util","Role","constructor","client","data","guild","_patch","id","name","color","hoist","rawPosition","position","permissions","freeze","managed","mentionable","deleted","createdTimestamp","deconstruct","timestamp","createdAt","Date","hexColor","toString","padStart","members","cache","filter","m","roles","has","editable","clientMember","member","user","FLAGS","MANAGE_ROLES","highest","comparePositionTo","sorted","_sortedRoles","array","indexOf","get","role","resolve","comparePositions","edit","reason","bitfield","setPosition","api","guilds","then","updatedRoles","actions","GuildRolesPositionUpdate","handle","guild_id","patch","resolveColor","clone","_clone","permissionsIn","channel","channels","rolePermissions","setName","setColor","setHoist","setPermissions","setMentionable","relative","delete","GuildRoleDelete","role_id","equals","toJSON","role1","role2","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/Role.js"],"sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst { Error, TypeError } = require('../errors');\nconst Permissions = require('../util/Permissions');\nconst Snowflake = require('../util/Snowflake');\nconst Util = require('../util/Util');\n\n/**\n * Represents a role on Discord.\n * @extends {Base}\n */\nclass Role extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the role\n   * @param {Guild} guild The guild the role is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that the role belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The ID of the role (unique to the guild it is part of)\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The name of the role\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The base 10 color of the role\n     * @type {number}\n     */\n    this.color = data.color;\n\n    /**\n     * If true, users that are part of this role will appear in a separate category in the users list\n     * @type {boolean}\n     */\n    this.hoist = data.hoist;\n\n    /**\n     * The raw position of the role from the API\n     * @type {number}\n     */\n    this.rawPosition = data.position;\n\n    /**\n     * The permissions of the role\n     * @type {Readonly<Permissions>}\n     */\n    this.permissions = new Permissions(data.permissions).freeze();\n\n    /**\n     * Whether or not the role is managed by an external service\n     * @type {boolean}\n     */\n    this.managed = data.managed;\n\n    /**\n     * Whether or not the role can be mentioned by anyone\n     * @type {boolean}\n     */\n    this.mentionable = data.mentionable;\n\n    /**\n     * Whether the role has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n  }\n\n  /**\n   * The timestamp the role was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the role was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The hexadecimal version of the role color, with a leading hashtag\n   * @type {string}\n   * @readonly\n   */\n  get hexColor() {\n    return `#${this.color.toString(16).padStart(6, '0')}`;\n  }\n\n  /**\n   * The cached guild members that have this role\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    return this.guild.members.cache.filter(m => m.roles.cache.has(this.id));\n  }\n\n  /**\n   * Whether the role is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    if (this.managed) return false;\n    const clientMember = this.guild.member(this.client.user);\n    if (!clientMember.permissions.has(Permissions.FLAGS.MANAGE_ROLES)) return false;\n    return clientMember.roles.highest.comparePositionTo(this) > 0;\n  }\n\n  /**\n   * The position of the role in the role manager\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedRoles();\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Compares this role's position to another role's.\n   * @param {RoleResolvable} role Role to compare to this one\n   * @returns {number} Negative number if this role's position is lower (other role's is higher),\n   * positive number if this one is higher (other's is lower), 0 if equal\n   */\n  comparePositionTo(role) {\n    role = this.guild.roles.resolve(role);\n    if (!role) throw new TypeError('INVALID_TYPE', 'role', 'Role nor a Snowflake');\n    return this.constructor.comparePositions(this, role);\n  }\n\n  /**\n   * The data for a role.\n   * @typedef {Object} RoleData\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Edits the role.\n   * @param {RoleData} data The new data for the role\n   * @param {string} [reason] Reason for editing this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Edit a role\n   * role.edit({ name: 'new role' })\n   *   .then(updated => console.log(`Edited role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    if (typeof data.permissions !== 'undefined') data.permissions = Permissions.resolve(data.permissions);\n    else data.permissions = this.permissions.bitfield;\n    if (typeof data.position !== 'undefined') {\n      await Util.setPosition(\n        this,\n        data.position,\n        false,\n        this.guild._sortedRoles(),\n        this.client.api.guilds(this.guild.id).roles,\n        reason,\n      ).then(updatedRoles => {\n        this.client.actions.GuildRolesPositionUpdate.handle({\n          guild_id: this.guild.id,\n          roles: updatedRoles,\n        });\n      });\n    }\n    return this.client.api.guilds[this.guild.id].roles[this.id]\n      .patch({\n        data: {\n          name: data.name || this.name,\n          color: data.color !== null ? Util.resolveColor(data.color || this.color) : null,\n          hoist: typeof data.hoist !== 'undefined' ? data.hoist : this.hoist,\n          permissions: data.permissions,\n          mentionable: typeof data.mentionable !== 'undefined' ? data.mentionable : this.mentionable,\n        },\n        reason,\n      })\n      .then(role => {\n        const clone = this._clone();\n        clone._patch(role);\n        return clone;\n      });\n  }\n\n  /**\n   * Returns `channel.permissionsFor(role)`. Returns permissions for a role in a guild channel,\n   * taking into account permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.rolePermissions(this);\n  }\n\n  /**\n   * Sets a new name for the role.\n   * @param {string} name The new name of the role\n   * @param {string} [reason] Reason for changing the role's name\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the name of the role\n   * role.setName('new role')\n   *   .then(updated => console.log(`Updated role name to ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Sets a new color for the role.\n   * @param {ColorResolvable} color The color of the role\n   * @param {string} [reason] Reason for changing the role's color\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the color of a role\n   * role.setColor('#FF0000')\n   *   .then(updated => console.log(`Set color of role to ${updated.color}`))\n   *   .catch(console.error);\n   */\n  setColor(color, reason) {\n    return this.edit({ color }, reason);\n  }\n\n  /**\n   * Sets whether or not the role should be hoisted.\n   * @param {boolean} hoist Whether or not to hoist the role\n   * @param {string} [reason] Reason for setting whether or not the role should be hoisted\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the hoist of the role\n   * role.setHoist(true)\n   *   .then(updated => console.log(`Role hoisted: ${updated.hoist}`))\n   *   .catch(console.error);\n   */\n  setHoist(hoist, reason) {\n    return this.edit({ hoist }, reason);\n  }\n\n  /**\n   * Sets the permissions of the role.\n   * @param {PermissionResolvable} permissions The permissions of the role\n   * @param {string} [reason] Reason for changing the role's permissions\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the permissions of the role\n   * role.setPermissions(['KICK_MEMBERS', 'BAN_MEMBERS'])\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   * @example\n   * // Remove all permissions from a role\n   * role.setPermissions(0)\n   *   .then(updated => console.log(`Updated permissions to ${updated.permissions.bitfield}`))\n   *   .catch(console.error);\n   */\n  setPermissions(permissions, reason) {\n    return this.edit({ permissions }, reason);\n  }\n\n  /**\n   * Sets whether this role is mentionable.\n   * @param {boolean} mentionable Whether this role should be mentionable\n   * @param {string} [reason] Reason for setting whether or not this role should be mentionable\n   * @returns {Promise<Role>}\n   * @example\n   * // Make the role mentionable\n   * role.setMentionable(true)\n   *   .then(updated => console.log(`Role updated ${updated.name}`))\n   *   .catch(console.error);\n   */\n  setMentionable(mentionable, reason) {\n    return this.edit({ mentionable }, reason);\n  }\n\n  /**\n   * Sets the position of the role.\n   * @param {number} position The position of the role\n   * @param {Object} [options] Options for setting position\n   * @param {boolean} [options.relative=false] Change the position relative to its current value\n   * @param {string} [options.reason] Reason for changing the position\n   * @returns {Promise<Role>}\n   * @example\n   * // Set the position of the role\n   * role.setPosition(1)\n   *   .then(updated => console.log(`Role position: ${updated.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position, { relative, reason } = {}) {\n    return Util.setPosition(\n      this,\n      position,\n      relative,\n      this.guild._sortedRoles(),\n      this.client.api.guilds(this.guild.id).roles,\n      reason,\n    ).then(updatedRoles => {\n      this.client.actions.GuildRolesPositionUpdate.handle({\n        guild_id: this.guild.id,\n        roles: updatedRoles,\n      });\n      return this;\n    });\n  }\n\n  /**\n   * Deletes the role.\n   * @param {string} [reason] Reason for deleting this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Delete a role\n   * role.delete('The role needed to go')\n   *   .then(deleted => console.log(`Deleted role ${deleted.name}`))\n   *   .catch(console.error);\n   */\n  delete(reason) {\n    return this.client.api.guilds[this.guild.id].roles[this.id].delete({ reason }).then(() => {\n      this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: this.id });\n      return this;\n    });\n  }\n\n  /**\n   * Whether this role equals another role. It compares all properties, so for most operations\n   * it is advisable to just compare `role.id === role2.id` as it is much faster and is often\n   * what most users need.\n   * @param {Role} role Role to compare with\n   * @returns {boolean}\n   */\n  equals(role) {\n    return (\n      role &&\n      this.id === role.id &&\n      this.name === role.name &&\n      this.color === role.color &&\n      this.hoist === role.hoist &&\n      this.position === role.position &&\n      this.permissions.bitfield === role.permissions.bitfield &&\n      this.managed === role.managed\n    );\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the role's mention instead of the Role object.\n   * @returns {string}\n   * @example\n   * // Logs: Role: <@&123456789012345678>\n   * console.log(`Role: ${role}`);\n   */\n  toString() {\n    if (this.id === this.guild.id) return '@everyone';\n    return `<@&${this.id}>`;\n  }\n\n  toJSON() {\n    return super.toJSON({ createdTimestamp: true });\n  }\n\n  /**\n   * Compares the positions of two roles.\n   * @param {Role} role1 First role to compare\n   * @param {Role} role2 Second role to compare\n   * @returns {number} Negative number if the first role's position is lower (second role's is higher),\n   * positive number if the first's is higher (second's is lower), 0 if equal\n   */\n  static comparePositions(role1, role2) {\n    if (role1.position === role2.position) return role2.id - role1.id;\n    return role1.position - role2.position;\n  }\n}\n\nmodule.exports = Role;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}