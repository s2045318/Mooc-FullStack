{"ast":null,"code":"'use strict';\n\nconst Collection = require('../util/Collection');\nconst {\n  ChannelTypes\n} = require('../util/Constants');\nconst Util = require('../util/Util');\n\n/**\n * Keeps track of mentions in a {@link Message}.\n */\nclass MessageMentions {\n  constructor(message, users, roles, everyone, crosspostedChannels) {\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: message.client\n    });\n\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n    Object.defineProperty(this, 'guild', {\n      value: message.guild\n    });\n\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n    Object.defineProperty(this, '_content', {\n      value: message.content\n    });\n\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n    this.everyone = Boolean(everyone);\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n        for (const mention of users) {\n          if (mention.member && message.guild) {\n            message.guild.members.add(Object.assign(mention.member, {\n              user: mention\n            }));\n          }\n          const user = message.client.users.add(mention);\n          this.users.set(user.id, user);\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n    if (roles) {\n      if (roles instanceof Collection) {\n        /**\n         * Any roles that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, Role>}\n         */\n        this.roles = new Collection(roles);\n      } else {\n        this.roles = new Collection();\n        for (const mention of roles) {\n          const role = message.channel.guild.roles.cache.get(mention);\n          if (role) this.roles.set(role.id, role);\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n\n    /**\n     * Cached members for {@link MessageMentions#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n    this._members = null;\n\n    /**\n     * Cached channels for {@link MessageMentions#channels}\n     * @type {?Collection<Snowflake, GuildChannel>}\n     * @private\n     */\n    this._channels = null;\n\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {string} channelID ID of the mentioned channel\n     * @property {string} guildID ID of the guild that has the channel\n     * @property {string} type Type of the channel\n     * @property {string} name The name of the channel\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        const channelTypes = Object.keys(ChannelTypes);\n        for (const d of crosspostedChannels) {\n          const type = channelTypes[d.type];\n          this.crosspostedChannels.set(d.id, {\n            channelID: d.id,\n            guildID: d.guild_id,\n            type: type ? type.toLowerCase() : 'unknown',\n            name: d.name\n          });\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n  }\n\n  /**\n   * Any members that were mentioned (only in {@link TextChannel}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    if (this._members) return this._members;\n    if (!this.guild) return null;\n    this._members = new Collection();\n    this.users.forEach(user => {\n      const member = this.guild.member(user);\n      if (member) this._members.set(member.user.id, member);\n    });\n    return this._members;\n  }\n\n  /**\n   * Any channels that were mentioned\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, GuildChannel>}\n   * @readonly\n   */\n  get channels() {\n    if (this._channels) return this._channels;\n    this._channels = new Collection();\n    let matches;\n    while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {\n      const chan = this.client.channels.cache.get(matches[1]);\n      if (chan) this._channels.set(chan.id, chan);\n    }\n    return this._channels;\n  }\n\n  /**\n   * Checks if a user, guild member, role, or channel is mentioned.\n   * Takes into account user mentions, role mentions, and @everyone/@here mentions.\n   * @param {UserResolvable|RoleResolvable|GuildChannelResolvable} data User/Role/Channel to check\n   * @param {Object} [options] Options\n   * @param {boolean} [options.ignoreDirect=false] - Whether to ignore direct mentions to the item\n   * @param {boolean} [options.ignoreRoles=false] - Whether to ignore role mentions to a guild member\n   * @param {boolean} [options.ignoreEveryone=false] - Whether to ignore everyone/here mentions\n   * @returns {boolean}\n   */\n  has(data) {\n    let {\n      ignoreDirect = false,\n      ignoreRoles = false,\n      ignoreEveryone = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ignoreEveryone && this.everyone) return true;\n    const GuildMember = require('./GuildMember');\n    if (!ignoreRoles && data instanceof GuildMember) {\n      for (const role of this.roles.values()) if (data.roles.cache.has(role.id)) return true;\n    }\n    if (!ignoreDirect) {\n      const id = this.client.users.resolveID(data) || this.guild && this.guild.roles.resolveID(data) || this.client.channels.resolveID(data);\n      return this.users.has(id) || this.channels.has(id) || this.roles.has(id);\n    }\n    return false;\n  }\n  toJSON() {\n    return Util.flatten(this, {\n      members: true,\n      channels: true\n    });\n  }\n}\n\n/**\n * Regular expression that globally matches `@everyone` and `@here`\n * @type {RegExp}\n */\nMessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;\n\n/**\n * Regular expression that globally matches user mentions like `<@81440962496172032>`\n * @type {RegExp}\n */\nMessageMentions.USERS_PATTERN = /<@!?(\\d{17,19})>/g;\n\n/**\n * Regular expression that globally matches role mentions like `<@&297577916114403338>`\n * @type {RegExp}\n */\nMessageMentions.ROLES_PATTERN = /<@&(\\d{17,19})>/g;\n\n/**\n * Regular expression that globally matches channel mentions like `<#222079895583457280>`\n * @type {RegExp}\n */\nMessageMentions.CHANNELS_PATTERN = /<#(\\d{17,19})>/g;\nmodule.exports = MessageMentions;","map":{"version":3,"names":["Collection","require","ChannelTypes","Util","MessageMentions","constructor","message","users","roles","everyone","crosspostedChannels","Object","defineProperty","value","client","guild","content","Boolean","mention","member","members","add","assign","user","set","id","role","channel","cache","get","_members","_channels","channelTypes","keys","d","type","channelID","guildID","guild_id","toLowerCase","name","forEach","channels","matches","CHANNELS_PATTERN","exec","_content","chan","has","data","ignoreDirect","ignoreRoles","ignoreEveryone","GuildMember","values","resolveID","toJSON","flatten","EVERYONE_PATTERN","USERS_PATTERN","ROLES_PATTERN","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/MessageMentions.js"],"sourcesContent":["'use strict';\n\nconst Collection = require('../util/Collection');\nconst { ChannelTypes } = require('../util/Constants');\nconst Util = require('../util/Util');\n\n/**\n * Keeps track of mentions in a {@link Message}.\n */\nclass MessageMentions {\n  constructor(message, users, roles, everyone, crosspostedChannels) {\n    /**\n     * The client the message is from\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: message.client });\n\n    /**\n     * The guild the message is in\n     * @type {?Guild}\n     * @readonly\n     */\n    Object.defineProperty(this, 'guild', { value: message.guild });\n\n    /**\n     * The initial message content\n     * @type {string}\n     * @readonly\n     * @private\n     */\n    Object.defineProperty(this, '_content', { value: message.content });\n\n    /**\n     * Whether `@everyone` or `@here` were mentioned\n     * @type {boolean}\n     */\n    this.everyone = Boolean(everyone);\n\n    if (users) {\n      if (users instanceof Collection) {\n        /**\n         * Any users that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, User>}\n         */\n        this.users = new Collection(users);\n      } else {\n        this.users = new Collection();\n        for (const mention of users) {\n          if (mention.member && message.guild) {\n            message.guild.members.add(Object.assign(mention.member, { user: mention }));\n          }\n          const user = message.client.users.add(mention);\n          this.users.set(user.id, user);\n        }\n      }\n    } else {\n      this.users = new Collection();\n    }\n\n    if (roles) {\n      if (roles instanceof Collection) {\n        /**\n         * Any roles that were mentioned\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, Role>}\n         */\n        this.roles = new Collection(roles);\n      } else {\n        this.roles = new Collection();\n        for (const mention of roles) {\n          const role = message.channel.guild.roles.cache.get(mention);\n          if (role) this.roles.set(role.id, role);\n        }\n      }\n    } else {\n      this.roles = new Collection();\n    }\n\n    /**\n     * Cached members for {@link MessageMentions#members}\n     * @type {?Collection<Snowflake, GuildMember>}\n     * @private\n     */\n    this._members = null;\n\n    /**\n     * Cached channels for {@link MessageMentions#channels}\n     * @type {?Collection<Snowflake, GuildChannel>}\n     * @private\n     */\n    this._channels = null;\n\n    /**\n     * Crossposted channel data.\n     * @typedef {Object} CrosspostedChannel\n     * @property {string} channelID ID of the mentioned channel\n     * @property {string} guildID ID of the guild that has the channel\n     * @property {string} type Type of the channel\n     * @property {string} name The name of the channel\n     */\n\n    if (crosspostedChannels) {\n      if (crosspostedChannels instanceof Collection) {\n        /**\n         * A collection of crossposted channels\n         * <info>Order as received from the API, not as they appear in the message content</info>\n         * @type {Collection<Snowflake, CrosspostedChannel>}\n         */\n        this.crosspostedChannels = new Collection(crosspostedChannels);\n      } else {\n        this.crosspostedChannels = new Collection();\n        const channelTypes = Object.keys(ChannelTypes);\n        for (const d of crosspostedChannels) {\n          const type = channelTypes[d.type];\n          this.crosspostedChannels.set(d.id, {\n            channelID: d.id,\n            guildID: d.guild_id,\n            type: type ? type.toLowerCase() : 'unknown',\n            name: d.name,\n          });\n        }\n      }\n    } else {\n      this.crosspostedChannels = new Collection();\n    }\n  }\n\n  /**\n   * Any members that were mentioned (only in {@link TextChannel}s)\n   * <info>Order as received from the API, not as they appear in the message content</info>\n   * @type {?Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    if (this._members) return this._members;\n    if (!this.guild) return null;\n    this._members = new Collection();\n    this.users.forEach(user => {\n      const member = this.guild.member(user);\n      if (member) this._members.set(member.user.id, member);\n    });\n    return this._members;\n  }\n\n  /**\n   * Any channels that were mentioned\n   * <info>Order as they appear first in the message content</info>\n   * @type {Collection<Snowflake, GuildChannel>}\n   * @readonly\n   */\n  get channels() {\n    if (this._channels) return this._channels;\n    this._channels = new Collection();\n    let matches;\n    while ((matches = this.constructor.CHANNELS_PATTERN.exec(this._content)) !== null) {\n      const chan = this.client.channels.cache.get(matches[1]);\n      if (chan) this._channels.set(chan.id, chan);\n    }\n    return this._channels;\n  }\n\n  /**\n   * Checks if a user, guild member, role, or channel is mentioned.\n   * Takes into account user mentions, role mentions, and @everyone/@here mentions.\n   * @param {UserResolvable|RoleResolvable|GuildChannelResolvable} data User/Role/Channel to check\n   * @param {Object} [options] Options\n   * @param {boolean} [options.ignoreDirect=false] - Whether to ignore direct mentions to the item\n   * @param {boolean} [options.ignoreRoles=false] - Whether to ignore role mentions to a guild member\n   * @param {boolean} [options.ignoreEveryone=false] - Whether to ignore everyone/here mentions\n   * @returns {boolean}\n   */\n  has(data, { ignoreDirect = false, ignoreRoles = false, ignoreEveryone = false } = {}) {\n    if (!ignoreEveryone && this.everyone) return true;\n    const GuildMember = require('./GuildMember');\n    if (!ignoreRoles && data instanceof GuildMember) {\n      for (const role of this.roles.values()) if (data.roles.cache.has(role.id)) return true;\n    }\n\n    if (!ignoreDirect) {\n      const id =\n        this.client.users.resolveID(data) ||\n        (this.guild && this.guild.roles.resolveID(data)) ||\n        this.client.channels.resolveID(data);\n\n      return this.users.has(id) || this.channels.has(id) || this.roles.has(id);\n    }\n\n    return false;\n  }\n\n  toJSON() {\n    return Util.flatten(this, {\n      members: true,\n      channels: true,\n    });\n  }\n}\n\n/**\n * Regular expression that globally matches `@everyone` and `@here`\n * @type {RegExp}\n */\nMessageMentions.EVERYONE_PATTERN = /@(everyone|here)/g;\n\n/**\n * Regular expression that globally matches user mentions like `<@81440962496172032>`\n * @type {RegExp}\n */\nMessageMentions.USERS_PATTERN = /<@!?(\\d{17,19})>/g;\n\n/**\n * Regular expression that globally matches role mentions like `<@&297577916114403338>`\n * @type {RegExp}\n */\nMessageMentions.ROLES_PATTERN = /<@&(\\d{17,19})>/g;\n\n/**\n * Regular expression that globally matches channel mentions like `<#222079895583457280>`\n * @type {RegExp}\n */\nMessageMentions.CHANNELS_PATTERN = /<#(\\d{17,19})>/g;\n\nmodule.exports = MessageMentions;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}