{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst Role = require('../structures/Role');\nconst Permissions = require('../util/Permissions');\nconst {\n  resolveColor\n} = require('../util/Util');\n\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {BaseManager}\n */\nclass RoleManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, Role);\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n  add(data, cache) {\n    return super.add(data, cache, {\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Obtains one or more roles from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] ID or IDs of the role(s)\n   * @param {boolean} [cache=true] Whether to cache the new roles objects if it weren't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Role|RoleManager>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.cache.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n  async fetch(id) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n    const roles = await this.client.api.guilds(this.guild.id).roles.get();\n    for (const role of roles) this.add(role, cache);\n    return id ? this.cache.get(id) || null : this;\n  }\n\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a RoleResolvable to a Role object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a RoleResolvable to a role ID string.\n   * @method resolveID\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {Object} [options] Options\n   * @param {RoleData} [options.data] The data to create the role with\n   * @param {string} [options.reason] Reason for creating this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   data: {\n   *     name: 'Super Cool People',\n   *     color: 'BLUE',\n   *   },\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  create() {\n    let {\n      data = {},\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (data.color) data.color = resolveColor(data.color);\n    if (data.permissions) data.permissions = Permissions.resolve(data.permissions);\n    return this.guild.client.api.guilds(this.guild.id).roles.post({\n      data,\n      reason\n    }).then(r => {\n      const {\n        role\n      } = this.client.actions.GuildRoleCreate.handle({\n        guild_id: this.guild.id,\n        role: r\n      });\n      if (data.position) return role.setPosition(data.position, reason);\n      return role;\n    });\n  }\n\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());\n  }\n}\nmodule.exports = RoleManager;","map":{"version":3,"names":["BaseManager","require","Role","Permissions","resolveColor","RoleManager","constructor","guild","iterable","client","add","data","cache","extras","fetch","id","force","existing","get","roles","api","guilds","role","create","reason","color","permissions","resolve","post","then","r","actions","GuildRoleCreate","handle","guild_id","position","setPosition","everyone","highest","reduce","prev","comparePositionTo","first","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/managers/RoleManager.js"],"sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst Role = require('../structures/Role');\nconst Permissions = require('../util/Permissions');\nconst { resolveColor } = require('../util/Util');\n\n/**\n * Manages API methods for roles and stores their cache.\n * @extends {BaseManager}\n */\nclass RoleManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, Role);\n    /**\n     * The guild belonging to this manager\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The role cache of this manager\n   * @type {Collection<Snowflake, Role>}\n   * @name RoleManager#cache\n   */\n\n  add(data, cache) {\n    return super.add(data, cache, { extras: [this.guild] });\n  }\n\n  /**\n   * Obtains one or more roles from Discord, or the role cache if they're already available.\n   * @param {Snowflake} [id] ID or IDs of the role(s)\n   * @param {boolean} [cache=true] Whether to cache the new roles objects if it weren't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Role|RoleManager>}\n   * @example\n   * // Fetch all roles from the guild\n   * message.guild.roles.fetch()\n   *   .then(roles => console.log(`There are ${roles.cache.size} roles.`))\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single role\n   * message.guild.roles.fetch('222078108977594368')\n   *   .then(role => console.log(`The role color is: ${role.color}`))\n   *   .catch(console.error);\n   */\n  async fetch(id, cache = true, force = false) {\n    if (id && !force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    // We cannot fetch a single role, as of this commit's date, Discord API throws with 405\n    const roles = await this.client.api.guilds(this.guild.id).roles.get();\n    for (const role of roles) this.add(role, cache);\n    return id ? this.cache.get(id) || null : this;\n  }\n\n  /**\n   * Data that can be resolved to a Role object. This can be:\n   * * A Role\n   * * A Snowflake\n   * @typedef {Role|Snowflake} RoleResolvable\n   */\n\n  /**\n   * Resolves a RoleResolvable to a Role object.\n   * @method resolve\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Role}\n   */\n\n  /**\n   * Resolves a RoleResolvable to a role ID string.\n   * @method resolveID\n   * @memberof RoleManager\n   * @instance\n   * @param {RoleResolvable} role The role resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Creates a new role in the guild with given information.\n   * <warn>The position will silently reset to 1 if an invalid one is provided, or none.</warn>\n   * @param {Object} [options] Options\n   * @param {RoleData} [options.data] The data to create the role with\n   * @param {string} [options.reason] Reason for creating this role\n   * @returns {Promise<Role>}\n   * @example\n   * // Create a new role\n   * guild.roles.create()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Create a new role with data and a reason\n   * guild.roles.create({\n   *   data: {\n   *     name: 'Super Cool People',\n   *     color: 'BLUE',\n   *   },\n   *   reason: 'we needed a role for Super Cool People',\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  create({ data = {}, reason } = {}) {\n    if (data.color) data.color = resolveColor(data.color);\n    if (data.permissions) data.permissions = Permissions.resolve(data.permissions);\n\n    return this.guild.client.api\n      .guilds(this.guild.id)\n      .roles.post({ data, reason })\n      .then(r => {\n        const { role } = this.client.actions.GuildRoleCreate.handle({\n          guild_id: this.guild.id,\n          role: r,\n        });\n        if (data.position) return role.setPosition(data.position, reason);\n        return role;\n      });\n  }\n\n  /**\n   * The `@everyone` role of the guild\n   * @type {Role}\n   * @readonly\n   */\n  get everyone() {\n    return this.cache.get(this.guild.id);\n  }\n\n  /**\n   * The role with the highest position in the cache\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this.cache.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this.cache.first());\n  }\n}\n\nmodule.exports = RoleManager;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC5C,MAAMC,IAAI,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AAC1C,MAAME,WAAW,GAAGF,OAAO,CAAC,qBAAqB,CAAC;AAClD,MAAM;EAAEG;AAAa,CAAC,GAAGH,OAAO,CAAC,cAAc,CAAC;;AAEhD;AACA;AACA;AACA;AACA,MAAMI,WAAW,SAASL,WAAW,CAAC;EACpCM,WAAW,CAACC,KAAK,EAAEC,QAAQ,EAAE;IAC3B,KAAK,CAACD,KAAK,CAACE,MAAM,EAAED,QAAQ,EAAEN,IAAI,CAAC;IACnC;AACJ;AACA;AACA;IACI,IAAI,CAACK,KAAK,GAAGA,KAAK;EACpB;;EAEA;AACF;AACA;AACA;AACA;;EAEEG,GAAG,CAACC,IAAI,EAAEC,KAAK,EAAE;IACf,OAAO,KAAK,CAACF,GAAG,CAACC,IAAI,EAAEC,KAAK,EAAE;MAAEC,MAAM,EAAE,CAAC,IAAI,CAACN,KAAK;IAAE,CAAC,CAAC;EACzD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMO,KAAK,CAACC,EAAE,EAA+B;IAAA,IAA7BH,KAAK,uEAAG,IAAI;IAAA,IAAEI,KAAK,uEAAG,KAAK;IACzC,IAAID,EAAE,IAAI,CAACC,KAAK,EAAE;MAChB,MAAMC,QAAQ,GAAG,IAAI,CAACL,KAAK,CAACM,GAAG,CAACH,EAAE,CAAC;MACnC,IAAIE,QAAQ,EAAE,OAAOA,QAAQ;IAC/B;;IAEA;IACA,MAAME,KAAK,GAAG,MAAM,IAAI,CAACV,MAAM,CAACW,GAAG,CAACC,MAAM,CAAC,IAAI,CAACd,KAAK,CAACQ,EAAE,CAAC,CAACI,KAAK,CAACD,GAAG,EAAE;IACrE,KAAK,MAAMI,IAAI,IAAIH,KAAK,EAAE,IAAI,CAACT,GAAG,CAACY,IAAI,EAAEV,KAAK,CAAC;IAC/C,OAAOG,EAAE,GAAG,IAAI,CAACH,KAAK,CAACM,GAAG,CAACH,EAAE,CAAC,IAAI,IAAI,GAAG,IAAI;EAC/C;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEQ,MAAM,GAA6B;IAAA,IAA5B;MAAEZ,IAAI,GAAG,CAAC,CAAC;MAAEa;IAAO,CAAC,uEAAG,CAAC,CAAC;IAC/B,IAAIb,IAAI,CAACc,KAAK,EAAEd,IAAI,CAACc,KAAK,GAAGrB,YAAY,CAACO,IAAI,CAACc,KAAK,CAAC;IACrD,IAAId,IAAI,CAACe,WAAW,EAAEf,IAAI,CAACe,WAAW,GAAGvB,WAAW,CAACwB,OAAO,CAAChB,IAAI,CAACe,WAAW,CAAC;IAE9E,OAAO,IAAI,CAACnB,KAAK,CAACE,MAAM,CAACW,GAAG,CACzBC,MAAM,CAAC,IAAI,CAACd,KAAK,CAACQ,EAAE,CAAC,CACrBI,KAAK,CAACS,IAAI,CAAC;MAAEjB,IAAI;MAAEa;IAAO,CAAC,CAAC,CAC5BK,IAAI,CAACC,CAAC,IAAI;MACT,MAAM;QAAER;MAAK,CAAC,GAAG,IAAI,CAACb,MAAM,CAACsB,OAAO,CAACC,eAAe,CAACC,MAAM,CAAC;QAC1DC,QAAQ,EAAE,IAAI,CAAC3B,KAAK,CAACQ,EAAE;QACvBO,IAAI,EAAEQ;MACR,CAAC,CAAC;MACF,IAAInB,IAAI,CAACwB,QAAQ,EAAE,OAAOb,IAAI,CAACc,WAAW,CAACzB,IAAI,CAACwB,QAAQ,EAAEX,MAAM,CAAC;MACjE,OAAOF,IAAI;IACb,CAAC,CAAC;EACN;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIe,QAAQ,GAAG;IACb,OAAO,IAAI,CAACzB,KAAK,CAACM,GAAG,CAAC,IAAI,CAACX,KAAK,CAACQ,EAAE,CAAC;EACtC;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIuB,OAAO,GAAG;IACZ,OAAO,IAAI,CAAC1B,KAAK,CAAC2B,MAAM,CAAC,CAACC,IAAI,EAAElB,IAAI,KAAMA,IAAI,CAACmB,iBAAiB,CAACD,IAAI,CAAC,GAAG,CAAC,GAAGlB,IAAI,GAAGkB,IAAK,EAAE,IAAI,CAAC5B,KAAK,CAAC8B,KAAK,EAAE,CAAC;EAChH;AACF;AAEAC,MAAM,CAACC,OAAO,GAAGvC,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}