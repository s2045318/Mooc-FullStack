{"ast":null,"code":"'use strict';\n\nconst MessageAttachment = require('./MessageAttachment');\nconst MessageEmbed = require('./MessageEmbed');\nconst {\n  RangeError\n} = require('../errors');\nconst {\n  browser\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst MessageFlags = require('../util/MessageFlags');\nconst Util = require('../util/Util');\n\n/**\n * Represents a message to be sent to the API.\n */\nclass APIMessage {\n  /**\n   * @param {MessageTarget} target - The target for this message to be sent to\n   * @param {MessageOptions|WebhookMessageOptions} options - Options passed in from send\n   */\n  constructor(target, options) {\n    /**\n     * The target for this message to be sent to\n     * @type {MessageTarget}\n     */\n    this.target = target;\n\n    /**\n     * Options passed in from send\n     * @type {MessageOptions|WebhookMessageOptions}\n     */\n    this.options = options;\n\n    /**\n     * Data sendable to the API\n     * @type {?Object}\n     */\n    this.data = null;\n\n    /**\n     * Files sendable to the API\n     * @type {?Object[]}\n     */\n    this.files = null;\n  }\n\n  /**\n   * Whether or not the target is a webhook\n   * @type {boolean}\n   * @readonly\n   */\n  get isWebhook() {\n    const Webhook = require('./Webhook');\n    const WebhookClient = require('../client/WebhookClient');\n    return this.target instanceof Webhook || this.target instanceof WebhookClient;\n  }\n\n  /**\n   * Whether or not the target is a user\n   * @type {boolean}\n   * @readonly\n   */\n  get isUser() {\n    const User = require('./User');\n    const GuildMember = require('./GuildMember');\n    return this.target instanceof User || this.target instanceof GuildMember;\n  }\n\n  /**\n   * Whether or not the target is a message\n   * @type {boolean}\n   * @readonly\n   */\n  get isMessage() {\n    const Message = require('./Message');\n    return this.target instanceof Message;\n  }\n\n  /**\n   * Makes the content of this message.\n   * @returns {?(string|string[])}\n   */\n  makeContent() {\n    const GuildMember = require('./GuildMember');\n    let content;\n    if (this.options.content === null) {\n      content = '';\n    } else if (typeof this.options.content !== 'undefined') {\n      content = Util.resolveString(this.options.content);\n    }\n    if (typeof content !== 'string') return content;\n    const disableMentions = typeof this.options.disableMentions === 'undefined' ? this.target.client.options.disableMentions : this.options.disableMentions;\n    if (disableMentions === 'all') {\n      content = Util.removeMentions(content);\n    } else if (disableMentions === 'everyone') {\n      content = content.replace(/@([^<>@ ]*)/gmsu, (match, target) => {\n        if (target.match(/^[&!]?\\d+$/)) {\n          return `@${target}`;\n        } else {\n          return `@\\u200b${target}`;\n        }\n      });\n    }\n    const isSplit = typeof this.options.split !== 'undefined' && this.options.split !== false;\n    const isCode = typeof this.options.code !== 'undefined' && this.options.code !== false;\n    const splitOptions = isSplit ? {\n      ...this.options.split\n    } : undefined;\n    let mentionPart = '';\n    if (this.options.reply && !this.isUser && this.target.type !== 'dm') {\n      const id = this.target.client.users.resolveID(this.options.reply);\n      mentionPart = `<@${this.options.reply instanceof GuildMember && this.options.reply.nickname ? '!' : ''}${id}>, `;\n      if (isSplit) {\n        splitOptions.prepend = `${mentionPart}${splitOptions.prepend || ''}`;\n      }\n    }\n    if (content || mentionPart) {\n      if (isCode) {\n        const codeName = typeof this.options.code === 'string' ? this.options.code : '';\n        content = `${mentionPart}\\`\\`\\`${codeName}\\n${Util.cleanCodeBlockContent(content)}\\n\\`\\`\\``;\n        if (isSplit) {\n          splitOptions.prepend = `${splitOptions.prepend || ''}\\`\\`\\`${codeName}\\n`;\n          splitOptions.append = `\\n\\`\\`\\`${splitOptions.append || ''}`;\n        }\n      } else if (mentionPart) {\n        content = `${mentionPart}${content}`;\n      }\n      if (isSplit) {\n        content = Util.splitMessage(content, splitOptions);\n      }\n    }\n    return content;\n  }\n\n  /**\n   * Resolves data.\n   * @returns {APIMessage}\n   */\n  resolveData() {\n    if (this.data) return this;\n    const content = this.makeContent();\n    const tts = Boolean(this.options.tts);\n    let nonce;\n    if (typeof this.options.nonce !== 'undefined') {\n      nonce = parseInt(this.options.nonce);\n      if (isNaN(nonce) || nonce < 0) throw new RangeError('MESSAGE_NONCE_TYPE');\n    }\n    const embedLikes = [];\n    if (this.isWebhook) {\n      if (this.options.embeds) {\n        embedLikes.push(...this.options.embeds);\n      }\n    } else if (this.options.embed) {\n      embedLikes.push(this.options.embed);\n    }\n    const embeds = embedLikes.map(e => new MessageEmbed(e).toJSON());\n    let username;\n    let avatarURL;\n    if (this.isWebhook) {\n      username = this.options.username || this.target.name;\n      if (this.options.avatarURL) avatarURL = this.options.avatarURL;\n    }\n    let flags;\n    if (this.isMessage) {\n      // eslint-disable-next-line eqeqeq\n      flags = this.options.flags != null ? new MessageFlags(this.options.flags).bitfield : this.target.flags.bitfield;\n    }\n    let allowedMentions = typeof this.options.allowedMentions === 'undefined' ? this.target.client.options.allowedMentions : this.options.allowedMentions;\n    if (this.options.reply) {\n      const id = this.target.client.users.resolveID(this.options.reply);\n      if (allowedMentions) {\n        // Clone the object as not to alter the ClientOptions object\n        allowedMentions = Util.cloneObject(allowedMentions);\n        const parsed = allowedMentions.parse && allowedMentions.parse.includes('users');\n        // Check if the mention won't be parsed, and isn't supplied in `users`\n        if (!parsed && !(allowedMentions.users && allowedMentions.users.includes(id))) {\n          if (!allowedMentions.users) allowedMentions.users = [];\n          allowedMentions.users.push(id);\n        }\n      } else {\n        allowedMentions = {\n          users: [id]\n        };\n      }\n    }\n    this.data = {\n      content,\n      tts,\n      nonce,\n      embed: this.options.embed === null ? null : embeds[0],\n      embeds,\n      username,\n      avatar_url: avatarURL,\n      allowed_mentions: typeof content === 'undefined' ? undefined : allowedMentions,\n      flags\n    };\n    return this;\n  }\n\n  /**\n   * Resolves files.\n   * @returns {Promise<APIMessage>}\n   */\n  async resolveFiles() {\n    if (this.files) return this;\n    const embedLikes = [];\n    if (this.isWebhook) {\n      if (this.options.embeds) {\n        embedLikes.push(...this.options.embeds);\n      }\n    } else if (this.options.embed) {\n      embedLikes.push(this.options.embed);\n    }\n    const fileLikes = [];\n    if (this.options.files) {\n      fileLikes.push(...this.options.files);\n    }\n    for (const embed of embedLikes) {\n      if (embed.files) {\n        fileLikes.push(...embed.files);\n      }\n    }\n    this.files = await Promise.all(fileLikes.map(f => this.constructor.resolveFile(f)));\n    return this;\n  }\n\n  /**\n   * Converts this APIMessage into an array of APIMessages for each split content\n   * @returns {APIMessage[]}\n   */\n  split() {\n    if (!this.data) this.resolveData();\n    if (!Array.isArray(this.data.content)) return [this];\n    const apiMessages = [];\n    for (let i = 0; i < this.data.content.length; i++) {\n      let data;\n      let opt;\n      if (i === this.data.content.length - 1) {\n        data = {\n          ...this.data,\n          content: this.data.content[i]\n        };\n        opt = {\n          ...this.options,\n          content: this.data.content[i]\n        };\n      } else {\n        data = {\n          content: this.data.content[i],\n          tts: this.data.tts,\n          allowed_mentions: this.options.allowedMentions\n        };\n        opt = {\n          content: this.data.content[i],\n          tts: this.data.tts,\n          allowedMentions: this.options.allowedMentions\n        };\n      }\n      const apiMessage = new APIMessage(this.target, opt);\n      apiMessage.data = data;\n      apiMessages.push(apiMessage);\n    }\n    return apiMessages;\n  }\n\n  /**\n   * Resolves a single file into an object sendable to the API.\n   * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} fileLike Something that could be resolved to a file\n   * @returns {Object}\n   */\n  static async resolveFile(fileLike) {\n    let attachment;\n    let name;\n    const findName = thing => {\n      if (typeof thing === 'string') {\n        return Util.basename(thing);\n      }\n      if (thing.path) {\n        return Util.basename(thing.path);\n      }\n      return 'file.jpg';\n    };\n    const ownAttachment = typeof fileLike === 'string' || fileLike instanceof (browser ? ArrayBuffer : Buffer) || typeof fileLike.pipe === 'function';\n    if (ownAttachment) {\n      attachment = fileLike;\n      name = findName(attachment);\n    } else {\n      attachment = fileLike.attachment;\n      name = fileLike.name || findName(attachment);\n    }\n    const resource = await DataResolver.resolveFile(attachment);\n    return {\n      attachment,\n      name,\n      file: resource\n    };\n  }\n\n  /**\n   * Partitions embeds and attachments.\n   * @param {Array<MessageEmbed|MessageAttachment>} items Items to partition\n   * @returns {Array<MessageEmbed[], MessageAttachment[]>}\n   */\n  static partitionMessageAdditions(items) {\n    const embeds = [];\n    const files = [];\n    for (const item of items) {\n      if (item instanceof MessageEmbed) {\n        embeds.push(item);\n      } else if (item instanceof MessageAttachment) {\n        files.push(item);\n      }\n    }\n    return [embeds, files];\n  }\n\n  /**\n   * Transforms the user-level arguments into a final options object. Passing a transformed options object alone into\n   * this method will keep it the same, allowing for the reuse of the final options object.\n   * @param {StringResolvable} [content] Content to send\n   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n   * @param {MessageOptions|WebhookMessageOptions} [extra={}] Extra options to add onto transformed options\n   * @param {boolean} [isWebhook=false] Whether or not to use WebhookMessageOptions as the result\n   * @returns {MessageOptions|WebhookMessageOptions}\n   */\n  static transformOptions(content, options) {\n    let extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let isWebhook = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (!options && typeof content === 'object' && !Array.isArray(content)) {\n      options = content;\n      content = undefined;\n    }\n    if (!options) {\n      options = {};\n    } else if (options instanceof MessageEmbed) {\n      return isWebhook ? {\n        content,\n        embeds: [options],\n        ...extra\n      } : {\n        content,\n        embed: options,\n        ...extra\n      };\n    } else if (options instanceof MessageAttachment) {\n      return {\n        content,\n        files: [options],\n        ...extra\n      };\n    }\n    if (Array.isArray(options)) {\n      const [embeds, files] = this.partitionMessageAdditions(options);\n      return isWebhook ? {\n        content,\n        embeds,\n        files,\n        ...extra\n      } : {\n        content,\n        embed: embeds[0],\n        files,\n        ...extra\n      };\n    } else if (Array.isArray(content)) {\n      const [embeds, files] = this.partitionMessageAdditions(content);\n      if (embeds.length || files.length) {\n        return isWebhook ? {\n          embeds,\n          files,\n          ...extra\n        } : {\n          embed: embeds[0],\n          files,\n          ...extra\n        };\n      }\n    }\n    return {\n      content,\n      ...options,\n      ...extra\n    };\n  }\n\n  /**\n   * Creates an `APIMessage` from user-level arguments.\n   * @param {MessageTarget} target Target to send to\n   * @param {StringResolvable} [content] Content to send\n   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n   * @param {MessageOptions|WebhookMessageOptions} [extra={}] - Extra options to add onto transformed options\n   * @returns {MessageOptions|WebhookMessageOptions}\n   */\n  static create(target, content, options) {\n    let extra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const Webhook = require('./Webhook');\n    const WebhookClient = require('../client/WebhookClient');\n    const isWebhook = target instanceof Webhook || target instanceof WebhookClient;\n    const transformed = this.transformOptions(content, options, extra, isWebhook);\n    return new this(target, transformed);\n  }\n}\nmodule.exports = APIMessage;\n\n/**\n * A target for a message.\n * @typedef {TextChannel|DMChannel|User|GuildMember|Webhook|WebhookClient} MessageTarget\n */\n\n/**\n * Additional items that can be sent with a message.\n * @typedef {MessageEmbed|MessageAttachment|Array<MessageEmbed|MessageAttachment>} MessageAdditions\n */","map":{"version":3,"names":["MessageAttachment","require","MessageEmbed","RangeError","browser","DataResolver","MessageFlags","Util","APIMessage","constructor","target","options","data","files","isWebhook","Webhook","WebhookClient","isUser","User","GuildMember","isMessage","Message","makeContent","content","resolveString","disableMentions","client","removeMentions","replace","match","isSplit","split","isCode","code","splitOptions","undefined","mentionPart","reply","type","id","users","resolveID","nickname","prepend","codeName","cleanCodeBlockContent","append","splitMessage","resolveData","tts","Boolean","nonce","parseInt","isNaN","embedLikes","embeds","push","embed","map","e","toJSON","username","avatarURL","name","flags","bitfield","allowedMentions","cloneObject","parsed","parse","includes","avatar_url","allowed_mentions","resolveFiles","fileLikes","Promise","all","f","resolveFile","Array","isArray","apiMessages","i","length","opt","apiMessage","fileLike","attachment","findName","thing","basename","path","ownAttachment","ArrayBuffer","Buffer","pipe","resource","file","partitionMessageAdditions","items","item","transformOptions","extra","create","transformed","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/APIMessage.js"],"sourcesContent":["'use strict';\n\nconst MessageAttachment = require('./MessageAttachment');\nconst MessageEmbed = require('./MessageEmbed');\nconst { RangeError } = require('../errors');\nconst { browser } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst MessageFlags = require('../util/MessageFlags');\nconst Util = require('../util/Util');\n\n/**\n * Represents a message to be sent to the API.\n */\nclass APIMessage {\n  /**\n   * @param {MessageTarget} target - The target for this message to be sent to\n   * @param {MessageOptions|WebhookMessageOptions} options - Options passed in from send\n   */\n  constructor(target, options) {\n    /**\n     * The target for this message to be sent to\n     * @type {MessageTarget}\n     */\n    this.target = target;\n\n    /**\n     * Options passed in from send\n     * @type {MessageOptions|WebhookMessageOptions}\n     */\n    this.options = options;\n\n    /**\n     * Data sendable to the API\n     * @type {?Object}\n     */\n    this.data = null;\n\n    /**\n     * Files sendable to the API\n     * @type {?Object[]}\n     */\n    this.files = null;\n  }\n\n  /**\n   * Whether or not the target is a webhook\n   * @type {boolean}\n   * @readonly\n   */\n  get isWebhook() {\n    const Webhook = require('./Webhook');\n    const WebhookClient = require('../client/WebhookClient');\n    return this.target instanceof Webhook || this.target instanceof WebhookClient;\n  }\n\n  /**\n   * Whether or not the target is a user\n   * @type {boolean}\n   * @readonly\n   */\n  get isUser() {\n    const User = require('./User');\n    const GuildMember = require('./GuildMember');\n    return this.target instanceof User || this.target instanceof GuildMember;\n  }\n\n  /**\n   * Whether or not the target is a message\n   * @type {boolean}\n   * @readonly\n   */\n  get isMessage() {\n    const Message = require('./Message');\n    return this.target instanceof Message;\n  }\n\n  /**\n   * Makes the content of this message.\n   * @returns {?(string|string[])}\n   */\n  makeContent() {\n    const GuildMember = require('./GuildMember');\n\n    let content;\n    if (this.options.content === null) {\n      content = '';\n    } else if (typeof this.options.content !== 'undefined') {\n      content = Util.resolveString(this.options.content);\n    }\n\n    if (typeof content !== 'string') return content;\n\n    const disableMentions =\n      typeof this.options.disableMentions === 'undefined'\n        ? this.target.client.options.disableMentions\n        : this.options.disableMentions;\n    if (disableMentions === 'all') {\n      content = Util.removeMentions(content);\n    } else if (disableMentions === 'everyone') {\n      content = content.replace(/@([^<>@ ]*)/gmsu, (match, target) => {\n        if (target.match(/^[&!]?\\d+$/)) {\n          return `@${target}`;\n        } else {\n          return `@\\u200b${target}`;\n        }\n      });\n    }\n\n    const isSplit = typeof this.options.split !== 'undefined' && this.options.split !== false;\n    const isCode = typeof this.options.code !== 'undefined' && this.options.code !== false;\n    const splitOptions = isSplit ? { ...this.options.split } : undefined;\n\n    let mentionPart = '';\n    if (this.options.reply && !this.isUser && this.target.type !== 'dm') {\n      const id = this.target.client.users.resolveID(this.options.reply);\n      mentionPart = `<@${this.options.reply instanceof GuildMember && this.options.reply.nickname ? '!' : ''}${id}>, `;\n      if (isSplit) {\n        splitOptions.prepend = `${mentionPart}${splitOptions.prepend || ''}`;\n      }\n    }\n\n    if (content || mentionPart) {\n      if (isCode) {\n        const codeName = typeof this.options.code === 'string' ? this.options.code : '';\n        content = `${mentionPart}\\`\\`\\`${codeName}\\n${Util.cleanCodeBlockContent(content)}\\n\\`\\`\\``;\n        if (isSplit) {\n          splitOptions.prepend = `${splitOptions.prepend || ''}\\`\\`\\`${codeName}\\n`;\n          splitOptions.append = `\\n\\`\\`\\`${splitOptions.append || ''}`;\n        }\n      } else if (mentionPart) {\n        content = `${mentionPart}${content}`;\n      }\n\n      if (isSplit) {\n        content = Util.splitMessage(content, splitOptions);\n      }\n    }\n\n    return content;\n  }\n\n  /**\n   * Resolves data.\n   * @returns {APIMessage}\n   */\n  resolveData() {\n    if (this.data) return this;\n\n    const content = this.makeContent();\n    const tts = Boolean(this.options.tts);\n\n    let nonce;\n    if (typeof this.options.nonce !== 'undefined') {\n      nonce = parseInt(this.options.nonce);\n      if (isNaN(nonce) || nonce < 0) throw new RangeError('MESSAGE_NONCE_TYPE');\n    }\n\n    const embedLikes = [];\n    if (this.isWebhook) {\n      if (this.options.embeds) {\n        embedLikes.push(...this.options.embeds);\n      }\n    } else if (this.options.embed) {\n      embedLikes.push(this.options.embed);\n    }\n    const embeds = embedLikes.map(e => new MessageEmbed(e).toJSON());\n\n    let username;\n    let avatarURL;\n    if (this.isWebhook) {\n      username = this.options.username || this.target.name;\n      if (this.options.avatarURL) avatarURL = this.options.avatarURL;\n    }\n\n    let flags;\n    if (this.isMessage) {\n      // eslint-disable-next-line eqeqeq\n      flags = this.options.flags != null ? new MessageFlags(this.options.flags).bitfield : this.target.flags.bitfield;\n    }\n\n    let allowedMentions =\n      typeof this.options.allowedMentions === 'undefined'\n        ? this.target.client.options.allowedMentions\n        : this.options.allowedMentions;\n    if (this.options.reply) {\n      const id = this.target.client.users.resolveID(this.options.reply);\n      if (allowedMentions) {\n        // Clone the object as not to alter the ClientOptions object\n        allowedMentions = Util.cloneObject(allowedMentions);\n        const parsed = allowedMentions.parse && allowedMentions.parse.includes('users');\n        // Check if the mention won't be parsed, and isn't supplied in `users`\n        if (!parsed && !(allowedMentions.users && allowedMentions.users.includes(id))) {\n          if (!allowedMentions.users) allowedMentions.users = [];\n          allowedMentions.users.push(id);\n        }\n      } else {\n        allowedMentions = { users: [id] };\n      }\n    }\n\n    this.data = {\n      content,\n      tts,\n      nonce,\n      embed: this.options.embed === null ? null : embeds[0],\n      embeds,\n      username,\n      avatar_url: avatarURL,\n      allowed_mentions: typeof content === 'undefined' ? undefined : allowedMentions,\n      flags,\n    };\n    return this;\n  }\n\n  /**\n   * Resolves files.\n   * @returns {Promise<APIMessage>}\n   */\n  async resolveFiles() {\n    if (this.files) return this;\n\n    const embedLikes = [];\n    if (this.isWebhook) {\n      if (this.options.embeds) {\n        embedLikes.push(...this.options.embeds);\n      }\n    } else if (this.options.embed) {\n      embedLikes.push(this.options.embed);\n    }\n\n    const fileLikes = [];\n    if (this.options.files) {\n      fileLikes.push(...this.options.files);\n    }\n    for (const embed of embedLikes) {\n      if (embed.files) {\n        fileLikes.push(...embed.files);\n      }\n    }\n\n    this.files = await Promise.all(fileLikes.map(f => this.constructor.resolveFile(f)));\n    return this;\n  }\n\n  /**\n   * Converts this APIMessage into an array of APIMessages for each split content\n   * @returns {APIMessage[]}\n   */\n  split() {\n    if (!this.data) this.resolveData();\n\n    if (!Array.isArray(this.data.content)) return [this];\n\n    const apiMessages = [];\n\n    for (let i = 0; i < this.data.content.length; i++) {\n      let data;\n      let opt;\n\n      if (i === this.data.content.length - 1) {\n        data = { ...this.data, content: this.data.content[i] };\n        opt = { ...this.options, content: this.data.content[i] };\n      } else {\n        data = { content: this.data.content[i], tts: this.data.tts, allowed_mentions: this.options.allowedMentions };\n        opt = { content: this.data.content[i], tts: this.data.tts, allowedMentions: this.options.allowedMentions };\n      }\n\n      const apiMessage = new APIMessage(this.target, opt);\n      apiMessage.data = data;\n      apiMessages.push(apiMessage);\n    }\n\n    return apiMessages;\n  }\n\n  /**\n   * Resolves a single file into an object sendable to the API.\n   * @param {BufferResolvable|Stream|FileOptions|MessageAttachment} fileLike Something that could be resolved to a file\n   * @returns {Object}\n   */\n  static async resolveFile(fileLike) {\n    let attachment;\n    let name;\n\n    const findName = thing => {\n      if (typeof thing === 'string') {\n        return Util.basename(thing);\n      }\n\n      if (thing.path) {\n        return Util.basename(thing.path);\n      }\n\n      return 'file.jpg';\n    };\n\n    const ownAttachment =\n      typeof fileLike === 'string' ||\n      fileLike instanceof (browser ? ArrayBuffer : Buffer) ||\n      typeof fileLike.pipe === 'function';\n    if (ownAttachment) {\n      attachment = fileLike;\n      name = findName(attachment);\n    } else {\n      attachment = fileLike.attachment;\n      name = fileLike.name || findName(attachment);\n    }\n\n    const resource = await DataResolver.resolveFile(attachment);\n    return { attachment, name, file: resource };\n  }\n\n  /**\n   * Partitions embeds and attachments.\n   * @param {Array<MessageEmbed|MessageAttachment>} items Items to partition\n   * @returns {Array<MessageEmbed[], MessageAttachment[]>}\n   */\n  static partitionMessageAdditions(items) {\n    const embeds = [];\n    const files = [];\n    for (const item of items) {\n      if (item instanceof MessageEmbed) {\n        embeds.push(item);\n      } else if (item instanceof MessageAttachment) {\n        files.push(item);\n      }\n    }\n\n    return [embeds, files];\n  }\n\n  /**\n   * Transforms the user-level arguments into a final options object. Passing a transformed options object alone into\n   * this method will keep it the same, allowing for the reuse of the final options object.\n   * @param {StringResolvable} [content] Content to send\n   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n   * @param {MessageOptions|WebhookMessageOptions} [extra={}] Extra options to add onto transformed options\n   * @param {boolean} [isWebhook=false] Whether or not to use WebhookMessageOptions as the result\n   * @returns {MessageOptions|WebhookMessageOptions}\n   */\n  static transformOptions(content, options, extra = {}, isWebhook = false) {\n    if (!options && typeof content === 'object' && !Array.isArray(content)) {\n      options = content;\n      content = undefined;\n    }\n\n    if (!options) {\n      options = {};\n    } else if (options instanceof MessageEmbed) {\n      return isWebhook ? { content, embeds: [options], ...extra } : { content, embed: options, ...extra };\n    } else if (options instanceof MessageAttachment) {\n      return { content, files: [options], ...extra };\n    }\n\n    if (Array.isArray(options)) {\n      const [embeds, files] = this.partitionMessageAdditions(options);\n      return isWebhook ? { content, embeds, files, ...extra } : { content, embed: embeds[0], files, ...extra };\n    } else if (Array.isArray(content)) {\n      const [embeds, files] = this.partitionMessageAdditions(content);\n      if (embeds.length || files.length) {\n        return isWebhook ? { embeds, files, ...extra } : { embed: embeds[0], files, ...extra };\n      }\n    }\n\n    return { content, ...options, ...extra };\n  }\n\n  /**\n   * Creates an `APIMessage` from user-level arguments.\n   * @param {MessageTarget} target Target to send to\n   * @param {StringResolvable} [content] Content to send\n   * @param {MessageOptions|WebhookMessageOptions|MessageAdditions} [options={}] Options to use\n   * @param {MessageOptions|WebhookMessageOptions} [extra={}] - Extra options to add onto transformed options\n   * @returns {MessageOptions|WebhookMessageOptions}\n   */\n  static create(target, content, options, extra = {}) {\n    const Webhook = require('./Webhook');\n    const WebhookClient = require('../client/WebhookClient');\n\n    const isWebhook = target instanceof Webhook || target instanceof WebhookClient;\n    const transformed = this.transformOptions(content, options, extra, isWebhook);\n    return new this(target, transformed);\n  }\n}\n\nmodule.exports = APIMessage;\n\n/**\n * A target for a message.\n * @typedef {TextChannel|DMChannel|User|GuildMember|Webhook|WebhookClient} MessageTarget\n */\n\n/**\n * Additional items that can be sent with a message.\n * @typedef {MessageEmbed|MessageAttachment|Array<MessageEmbed|MessageAttachment>} MessageAdditions\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}