{"ast":null,"code":"'use strict';\n\nconst Collector = require('./interfaces/Collector');\nconst {\n  Events\n} = require('../util/Constants');\n\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel (`'channelDelete'`) or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextChannel|DMChannel} channel The channel\n   * @param {CollectorFilter} filter The filter to be applied to this collector\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel, filter) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(channel.client, filter, options);\n\n    /**\n     * The channel\n     * @type {TextBasedChannel}\n     */\n    this.channel = channel;\n\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n    this.received = 0;\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);\n    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);\n    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channel.id !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channel.id === this.channel.id ? message.id : null;\n  }\n\n  /**\n   * Checks after un/collection to see if the collector is done.\n   * @returns {?string}\n   * @private\n   */\n  endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return null;\n  }\n\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id) {\n      this.stop('channelDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n  _handleGuildDeletion(guild) {\n    if (this.channel.guild && guild.id === this.channel.guild.id) {\n      this.stop('guildDelete');\n    }\n  }\n}\nmodule.exports = MessageCollector;","map":{"version":3,"names":["Collector","require","Events","MessageCollector","constructor","channel","filter","options","client","received","bulkDeleteListener","messages","message","values","handleDispose","_handleChannelDeletion","bind","_handleGuildDeletion","incrementMaxListeners","on","MESSAGE_CREATE","handleCollect","MESSAGE_DELETE","MESSAGE_BULK_DELETE","CHANNEL_DELETE","GUILD_DELETE","once","removeListener","decrementMaxListeners","collect","id","dispose","endReason","max","collected","size","maxProcessed","stop","guild","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/MessageCollector.js"],"sourcesContent":["'use strict';\n\nconst Collector = require('./interfaces/Collector');\nconst { Events } = require('../util/Constants');\n\n/**\n * @typedef {CollectorOptions} MessageCollectorOptions\n * @property {number} max The maximum amount of messages to collect\n * @property {number} maxProcessed The maximum amount of messages to process\n */\n\n/**\n * Collects messages on a channel.\n * Will automatically stop if the channel (`'channelDelete'`) or guild (`'guildDelete'`) are deleted.\n * @extends {Collector}\n */\nclass MessageCollector extends Collector {\n  /**\n   * @param {TextChannel|DMChannel} channel The channel\n   * @param {CollectorFilter} filter The filter to be applied to this collector\n   * @param {MessageCollectorOptions} options The options to be applied to this collector\n   * @emits MessageCollector#message\n   */\n  constructor(channel, filter, options = {}) {\n    super(channel.client, filter, options);\n\n    /**\n     * The channel\n     * @type {TextBasedChannel}\n     */\n    this.channel = channel;\n\n    /**\n     * Total number of messages that were received in the channel during message collection\n     * @type {number}\n     */\n    this.received = 0;\n\n    const bulkDeleteListener = messages => {\n      for (const message of messages.values()) this.handleDispose(message);\n    };\n    this._handleChannelDeletion = this._handleChannelDeletion.bind(this);\n    this._handleGuildDeletion = this._handleGuildDeletion.bind(this);\n\n    this.client.incrementMaxListeners();\n    this.client.on(Events.MESSAGE_CREATE, this.handleCollect);\n    this.client.on(Events.MESSAGE_DELETE, this.handleDispose);\n    this.client.on(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n    this.client.on(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n    this.client.on(Events.GUILD_DELETE, this._handleGuildDeletion);\n\n    this.once('end', () => {\n      this.client.removeListener(Events.MESSAGE_CREATE, this.handleCollect);\n      this.client.removeListener(Events.MESSAGE_DELETE, this.handleDispose);\n      this.client.removeListener(Events.MESSAGE_BULK_DELETE, bulkDeleteListener);\n      this.client.removeListener(Events.CHANNEL_DELETE, this._handleChannelDeletion);\n      this.client.removeListener(Events.GUILD_DELETE, this._handleGuildDeletion);\n      this.client.decrementMaxListeners();\n    });\n  }\n\n  /**\n   * Handles a message for possible collection.\n   * @param {Message} message The message that could be collected\n   * @returns {?Snowflake}\n   * @private\n   */\n  collect(message) {\n    /**\n     * Emitted whenever a message is collected.\n     * @event MessageCollector#collect\n     * @param {Message} message The message that was collected\n     */\n    if (message.channel.id !== this.channel.id) return null;\n    this.received++;\n    return message.id;\n  }\n\n  /**\n   * Handles a message for possible disposal.\n   * @param {Message} message The message that could be disposed of\n   * @returns {?Snowflake}\n   */\n  dispose(message) {\n    /**\n     * Emitted whenever a message is disposed of.\n     * @event MessageCollector#dispose\n     * @param {Message} message The message that was disposed of\n     */\n    return message.channel.id === this.channel.id ? message.id : null;\n  }\n\n  /**\n   * Checks after un/collection to see if the collector is done.\n   * @returns {?string}\n   * @private\n   */\n  endReason() {\n    if (this.options.max && this.collected.size >= this.options.max) return 'limit';\n    if (this.options.maxProcessed && this.received === this.options.maxProcessed) return 'processedLimit';\n    return null;\n  }\n\n  /**\n   * Handles checking if the channel has been deleted, and if so, stops the collector with the reason 'channelDelete'.\n   * @private\n   * @param {GuildChannel} channel The channel that was deleted\n   * @returns {void}\n   */\n  _handleChannelDeletion(channel) {\n    if (channel.id === this.channel.id) {\n      this.stop('channelDelete');\n    }\n  }\n\n  /**\n   * Handles checking if the guild has been deleted, and if so, stops the collector with the reason 'guildDelete'.\n   * @private\n   * @param {Guild} guild The guild that was deleted\n   * @returns {void}\n   */\n  _handleGuildDeletion(guild) {\n    if (this.channel.guild && guild.id === this.channel.guild.id) {\n      this.stop('guildDelete');\n    }\n  }\n}\n\nmodule.exports = MessageCollector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}