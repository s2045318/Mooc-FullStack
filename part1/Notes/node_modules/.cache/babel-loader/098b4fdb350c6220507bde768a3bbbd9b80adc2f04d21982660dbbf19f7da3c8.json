{"ast":null,"code":"'use strict';\n\nconst BaseGuildEmoji = require('./BaseGuildEmoji');\nconst {\n  Error\n} = require('../errors');\nconst GuildEmojiRoleManager = require('../managers/GuildEmojiRoleManager');\nconst Permissions = require('../util/Permissions');\n\n/**\n * Represents a custom emoji.\n * @extends {BaseGuildEmoji}\n */\nclass GuildEmoji extends BaseGuildEmoji {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild emoji\n   * @param {Guild} guild The guild the guild emoji is part of\n   */\n  constructor(client, data, guild) {\n    super(client, data, guild);\n\n    /**\n     * The user who created this emoji\n     * @type {?User}\n     */\n    this.author = null;\n  }\n\n  /**\n   * The guild this emoji is part of\n   * @type {Guild}\n   * @name GuildEmoji#guild\n   */\n\n  _clone() {\n    const clone = super._clone();\n    clone._roles = this._roles.slice();\n    return clone;\n  }\n  _patch(data) {\n    super._patch(data);\n    if (typeof data.user !== 'undefined') this.author = this.client.users.add(data.user);\n  }\n\n  /**\n   * Whether the emoji is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n    return !this.managed && this.guild.me.hasPermission(Permissions.FLAGS.MANAGE_EMOJIS);\n  }\n\n  /**\n   * A manager for roles this emoji is active for.\n   * @type {GuildEmojiRoleManager}\n   * @readonly\n   */\n  get roles() {\n    return new GuildEmojiRoleManager(this);\n  }\n\n  /**\n   * Fetches the author for this emoji\n   * @returns {Promise<User>}\n   */\n  async fetchAuthor() {\n    if (this.managed) {\n      throw new Error('EMOJI_MANAGED');\n    } else {\n      if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n      if (!this.guild.me.permissions.has(Permissions.FLAGS.MANAGE_EMOJIS)) {\n        throw new Error('MISSING_MANAGE_EMOJIS_PERMISSION', this.guild);\n      }\n    }\n    const data = await this.client.api.guilds(this.guild.id).emojis(this.id).get();\n    this._patch(data);\n    return this.author;\n  }\n\n  /**\n   * Data for editing an emoji.\n   * @typedef {Object} GuildEmojiEditData\n   * @property {string} [name] The name of the emoji\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] Roles to restrict emoji to\n   */\n\n  /**\n   * Edits the emoji.\n   * @param {GuildEmojiEditData} data The new data for the emoji\n   * @param {string} [reason] Reason for editing this emoji\n   * @returns {Promise<GuildEmoji>}\n   * @example\n   * // Edit an emoji\n   * emoji.edit({ name: 'newemoji' })\n   *   .then(e => console.log(`Edited emoji ${e}`))\n   *   .catch(console.error);\n   */\n  edit(data, reason) {\n    const roles = data.roles ? data.roles.map(r => r.id || r) : undefined;\n    return this.client.api.guilds(this.guild.id).emojis(this.id).patch({\n      data: {\n        name: data.name,\n        roles\n      },\n      reason\n    }).then(newData => {\n      const clone = this._clone();\n      clone._patch(newData);\n      return clone;\n    });\n  }\n\n  /**\n   * Sets the name of the emoji.\n   * @param {string} name The new name for the emoji\n   * @param {string} [reason] Reason for changing the emoji's name\n   * @returns {Promise<GuildEmoji>}\n   */\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n\n  /**\n   * Deletes the emoji.\n   * @param {string} [reason] Reason for deleting the emoji\n   * @returns {Promise<GuildEmoji>}\n   */\n  delete(reason) {\n    return this.client.api.guilds(this.guild.id).emojis(this.id).delete({\n      reason\n    }).then(() => this);\n  }\n\n  /**\n   * Whether this emoji is the same as another one.\n   * @param {GuildEmoji|Object} other The emoji to compare it to\n   * @returns {boolean} Whether the emoji is equal to the given emoji or not\n   */\n  equals(other) {\n    if (other instanceof GuildEmoji) {\n      return other.id === this.id && other.name === this.name && other.managed === this.managed && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every(role => this.roles.cache.has(role.id));\n    } else {\n      return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every(role => this.roles.cache.has(role));\n    }\n  }\n}\nmodule.exports = GuildEmoji;","map":{"version":3,"names":["BaseGuildEmoji","require","Error","GuildEmojiRoleManager","Permissions","GuildEmoji","constructor","client","data","guild","author","_clone","clone","_roles","slice","_patch","user","users","add","deletable","me","managed","hasPermission","FLAGS","MANAGE_EMOJIS","roles","fetchAuthor","permissions","has","api","guilds","id","emojis","get","edit","reason","map","r","undefined","patch","name","then","newData","setName","delete","equals","other","requiresColons","cache","size","every","role","length","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/GuildEmoji.js"],"sourcesContent":["'use strict';\n\nconst BaseGuildEmoji = require('./BaseGuildEmoji');\nconst { Error } = require('../errors');\nconst GuildEmojiRoleManager = require('../managers/GuildEmojiRoleManager');\nconst Permissions = require('../util/Permissions');\n\n/**\n * Represents a custom emoji.\n * @extends {BaseGuildEmoji}\n */\nclass GuildEmoji extends BaseGuildEmoji {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild emoji\n   * @param {Guild} guild The guild the guild emoji is part of\n   */\n  constructor(client, data, guild) {\n    super(client, data, guild);\n\n    /**\n     * The user who created this emoji\n     * @type {?User}\n     */\n    this.author = null;\n  }\n\n  /**\n   * The guild this emoji is part of\n   * @type {Guild}\n   * @name GuildEmoji#guild\n   */\n\n  _clone() {\n    const clone = super._clone();\n    clone._roles = this._roles.slice();\n    return clone;\n  }\n\n  _patch(data) {\n    super._patch(data);\n    if (typeof data.user !== 'undefined') this.author = this.client.users.add(data.user);\n  }\n\n  /**\n   * Whether the emoji is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n    return !this.managed && this.guild.me.hasPermission(Permissions.FLAGS.MANAGE_EMOJIS);\n  }\n\n  /**\n   * A manager for roles this emoji is active for.\n   * @type {GuildEmojiRoleManager}\n   * @readonly\n   */\n  get roles() {\n    return new GuildEmojiRoleManager(this);\n  }\n\n  /**\n   * Fetches the author for this emoji\n   * @returns {Promise<User>}\n   */\n  async fetchAuthor() {\n    if (this.managed) {\n      throw new Error('EMOJI_MANAGED');\n    } else {\n      if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n      if (!this.guild.me.permissions.has(Permissions.FLAGS.MANAGE_EMOJIS)) {\n        throw new Error('MISSING_MANAGE_EMOJIS_PERMISSION', this.guild);\n      }\n    }\n    const data = await this.client.api.guilds(this.guild.id).emojis(this.id).get();\n    this._patch(data);\n    return this.author;\n  }\n\n  /**\n   * Data for editing an emoji.\n   * @typedef {Object} GuildEmojiEditData\n   * @property {string} [name] The name of the emoji\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] Roles to restrict emoji to\n   */\n\n  /**\n   * Edits the emoji.\n   * @param {GuildEmojiEditData} data The new data for the emoji\n   * @param {string} [reason] Reason for editing this emoji\n   * @returns {Promise<GuildEmoji>}\n   * @example\n   * // Edit an emoji\n   * emoji.edit({ name: 'newemoji' })\n   *   .then(e => console.log(`Edited emoji ${e}`))\n   *   .catch(console.error);\n   */\n  edit(data, reason) {\n    const roles = data.roles ? data.roles.map(r => r.id || r) : undefined;\n    return this.client.api\n      .guilds(this.guild.id)\n      .emojis(this.id)\n      .patch({\n        data: {\n          name: data.name,\n          roles,\n        },\n        reason,\n      })\n      .then(newData => {\n        const clone = this._clone();\n        clone._patch(newData);\n        return clone;\n      });\n  }\n\n  /**\n   * Sets the name of the emoji.\n   * @param {string} name The new name for the emoji\n   * @param {string} [reason] Reason for changing the emoji's name\n   * @returns {Promise<GuildEmoji>}\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Deletes the emoji.\n   * @param {string} [reason] Reason for deleting the emoji\n   * @returns {Promise<GuildEmoji>}\n   */\n  delete(reason) {\n    return this.client.api\n      .guilds(this.guild.id)\n      .emojis(this.id)\n      .delete({ reason })\n      .then(() => this);\n  }\n\n  /**\n   * Whether this emoji is the same as another one.\n   * @param {GuildEmoji|Object} other The emoji to compare it to\n   * @returns {boolean} Whether the emoji is equal to the given emoji or not\n   */\n  equals(other) {\n    if (other instanceof GuildEmoji) {\n      return (\n        other.id === this.id &&\n        other.name === this.name &&\n        other.managed === this.managed &&\n        other.requiresColons === this.requiresColons &&\n        other.roles.cache.size === this.roles.cache.size &&\n        other.roles.cache.every(role => this.roles.cache.has(role.id))\n      );\n    } else {\n      return (\n        other.id === this.id &&\n        other.name === this.name &&\n        other.roles.length === this.roles.cache.size &&\n        other.roles.every(role => this.roles.cache.has(role))\n      );\n    }\n  }\n}\n\nmodule.exports = GuildEmoji;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}