{"ast":null,"code":"'use strict';\n\nconst Collection = require('../../../util/Collection');\nconst {\n  Events\n} = require('../../../util/Constants');\nmodule.exports = (client, _ref) => {\n  let {\n    d: data\n  } = _ref;\n  const guild = client.guilds.cache.get(data.guild_id);\n  if (!guild) return;\n  const members = new Collection();\n  for (const member of data.members) members.set(member.user.id, guild.members.add(member));\n  if (data.presences) {\n    for (const presence of data.presences) guild.presences.add(Object.assign(presence, {\n      guild\n    }));\n  }\n  /**\n   * Emitted whenever a chunk of guild members is received (all members come from the same guild).\n   * @event Client#guildMembersChunk\n   * @param {Collection<Snowflake, GuildMember>} members The members in the chunk\n   * @param {Guild} guild The guild related to the member chunk\n   * @param {Object} chunk Properties of the received chunk\n   * @param {number} chunk.index Index of the received chunk\n   * @param {number} chunk.count Number of chunks the client should receive\n   * @param {?string} chunk.nonce Nonce for this chunk\n   */\n  client.emit(Events.GUILD_MEMBERS_CHUNK, members, guild, {\n    count: data.chunk_count,\n    index: data.chunk_index,\n    nonce: data.nonce\n  });\n};","map":{"version":3,"names":["Collection","require","Events","module","exports","client","d","data","guild","guilds","cache","get","guild_id","members","member","set","user","id","add","presences","presence","Object","assign","emit","GUILD_MEMBERS_CHUNK","count","chunk_count","index","chunk_index","nonce"],"sources":["/Users/jessegill/node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js"],"sourcesContent":["'use strict';\n\nconst Collection = require('../../../util/Collection');\nconst { Events } = require('../../../util/Constants');\n\nmodule.exports = (client, { d: data }) => {\n  const guild = client.guilds.cache.get(data.guild_id);\n  if (!guild) return;\n  const members = new Collection();\n\n  for (const member of data.members) members.set(member.user.id, guild.members.add(member));\n  if (data.presences) {\n    for (const presence of data.presences) guild.presences.add(Object.assign(presence, { guild }));\n  }\n  /**\n   * Emitted whenever a chunk of guild members is received (all members come from the same guild).\n   * @event Client#guildMembersChunk\n   * @param {Collection<Snowflake, GuildMember>} members The members in the chunk\n   * @param {Guild} guild The guild related to the member chunk\n   * @param {Object} chunk Properties of the received chunk\n   * @param {number} chunk.index Index of the received chunk\n   * @param {number} chunk.count Number of chunks the client should receive\n   * @param {?string} chunk.nonce Nonce for this chunk\n   */\n  client.emit(Events.GUILD_MEMBERS_CHUNK, members, guild, {\n    count: data.chunk_count,\n    index: data.chunk_index,\n    nonce: data.nonce,\n  });\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,UAAU,GAAGC,OAAO,CAAC,0BAA0B,CAAC;AACtD,MAAM;EAAEC;AAAO,CAAC,GAAGD,OAAO,CAAC,yBAAyB,CAAC;AAErDE,MAAM,CAACC,OAAO,GAAG,CAACC,MAAM,WAAkB;EAAA,IAAhB;IAAEC,CAAC,EAAEC;EAAK,CAAC;EACnC,MAAMC,KAAK,GAAGH,MAAM,CAACI,MAAM,CAACC,KAAK,CAACC,GAAG,CAACJ,IAAI,CAACK,QAAQ,CAAC;EACpD,IAAI,CAACJ,KAAK,EAAE;EACZ,MAAMK,OAAO,GAAG,IAAIb,UAAU,EAAE;EAEhC,KAAK,MAAMc,MAAM,IAAIP,IAAI,CAACM,OAAO,EAAEA,OAAO,CAACE,GAAG,CAACD,MAAM,CAACE,IAAI,CAACC,EAAE,EAAET,KAAK,CAACK,OAAO,CAACK,GAAG,CAACJ,MAAM,CAAC,CAAC;EACzF,IAAIP,IAAI,CAACY,SAAS,EAAE;IAClB,KAAK,MAAMC,QAAQ,IAAIb,IAAI,CAACY,SAAS,EAAEX,KAAK,CAACW,SAAS,CAACD,GAAG,CAACG,MAAM,CAACC,MAAM,CAACF,QAAQ,EAAE;MAAEZ;IAAM,CAAC,CAAC,CAAC;EAChG;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEH,MAAM,CAACkB,IAAI,CAACrB,MAAM,CAACsB,mBAAmB,EAAEX,OAAO,EAAEL,KAAK,EAAE;IACtDiB,KAAK,EAAElB,IAAI,CAACmB,WAAW;IACvBC,KAAK,EAAEpB,IAAI,CAACqB,WAAW;IACvBC,KAAK,EAAEtB,IAAI,CAACsB;EACd,CAAC,CAAC;AACJ,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}