{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst {\n  Error: DJSError\n} = require('../../errors');\nconst Collection = require('../../util/Collection');\nconst {\n  Events,\n  ShardEvents,\n  Status,\n  WSCodes,\n  WSEvents\n} = require('../../util/Constants');\nconst Util = require('../../util/Util');\nconst BeforeReadyWhitelist = [WSEvents.READY, WSEvents.RESUMED, WSEvents.GUILD_CREATE, WSEvents.GUILD_DELETE, WSEvents.GUILD_MEMBERS_CHUNK, WSEvents.GUILD_MEMBER_ADD, WSEvents.GUILD_MEMBER_REMOVE];\nconst UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(1).map(Number);\nconst UNRESUMABLE_CLOSE_CODES = [1000, 4006, 4007];\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends EventEmitter\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * The amount of shards this manager handles\n     * @private\n     * @type {number}\n     */\n    this.totalShards = this.client.options.shards.length;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of shards to be connected or that need to reconnect\n     * @type {Set<WebSocketShard>}\n     * @private\n     * @name WebSocketManager#shardQueue\n     */\n    Object.defineProperty(this, 'shardQueue', {\n      value: new Set(),\n      writable: true\n    });\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', {\n      value: []\n    });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {number}\n     */\n    this.status = Status.IDLE;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * If this manager is currently reconnecting one or multiple shards\n     * @type {boolean}\n     * @private\n     */\n    this.reconnecting = false;\n\n    /**\n     * The current session limit of the client\n     * @private\n     * @type {?Object}\n     * @property {number} total Total number of identifies available\n     * @property {number} remaining Number of identifies remaining\n     * @property {number} reset_after Number of milliseconds after which the limit resets\n     */\n    this.sessionStartLimit = null;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shard) {\n    this.client.emit(Events.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new DJSError(WSCodes[4004]);\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit\n    } = await this.client.api.gateway.bot.get().catch(error => {\n      throw error.httpStatus === 401 ? invalidToken : error;\n    });\n    this.sessionStartLimit = sessionStartLimit;\n    const {\n      total,\n      remaining,\n      reset_after\n    } = sessionStartLimit;\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n    this.gateway = `${gatewayURL}/`;\n    let {\n      shards\n    } = this.client.options;\n    if (shards === 'auto') {\n      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);\n      this.totalShards = this.client.options.shardCount = recommendedShards;\n      shards = this.client.options.shards = Array.from({\n        length: recommendedShards\n      }, (_, i) => i);\n    }\n    this.totalShards = shards.length;\n    this.debug(`Spawning shards: ${shards.join(', ')}`);\n    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));\n    await this._handleSessionLimit(remaining, reset_after);\n    return this.createShards();\n  }\n\n  /**\n   * Handles the creation of a shard.\n   * @returns {Promise<boolean>}\n   * @private\n   */\n  async createShards() {\n    // If we don't have any shards to handle, return\n    if (!this.shardQueue.size) return false;\n    const [shard] = this.shardQueue;\n    this.shardQueue.delete(shard);\n    if (!shard.eventsAttached) {\n      shard.on(ShardEvents.ALL_READY, unavailableGuilds => {\n        /**\n         * Emitted when a shard turns ready.\n         * @event Client#shardReady\n         * @param {number} id The shard ID that turned ready\n         * @param {?Set<string>} unavailableGuilds Set of unavailable guild IDs, if any\n         */\n        this.client.emit(Events.SHARD_READY, shard.id, unavailableGuilds);\n        if (!this.shardQueue.size) this.reconnecting = false;\n        this.checkShardsReady();\n      });\n      shard.on(ShardEvents.CLOSE, event => {\n        if (event.code === 1000 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {\n          /**\n           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n           * @event Client#shardDisconnect\n           * @param {CloseEvent} event The WebSocket close event\n           * @param {number} id The shard ID that disconnected\n           */\n          this.client.emit(Events.SHARD_DISCONNECT, event, shard.id);\n          this.debug(WSCodes[event.code], shard);\n          return;\n        }\n        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {\n          // These event codes cannot be resumed\n          shard.sessionID = null;\n        }\n\n        /**\n         * Emitted when a shard is attempting to reconnect or re-identify.\n         * @event Client#shardReconnecting\n         * @param {number} id The shard ID that is attempting to reconnect\n         */\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n        this.shardQueue.add(shard);\n        if (shard.sessionID) {\n          this.debug(`Session ID is present, attempting an immediate reconnect...`, shard);\n          this.reconnect(true);\n        } else {\n          shard.destroy({\n            reset: true,\n            emit: false,\n            log: false\n          });\n          this.reconnect();\n        }\n      });\n      shard.on(ShardEvents.INVALID_SESSION, () => {\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n      });\n      shard.on(ShardEvents.DESTROYED, () => {\n        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n        this.shardQueue.add(shard);\n        this.reconnect();\n      });\n      shard.eventsAttached = true;\n    }\n    this.shards.set(shard.id, shard);\n    try {\n      await shard.connect();\n    } catch (error) {\n      if (error && error.code && UNRECOVERABLE_CLOSE_CODES.includes(error.code)) {\n        throw new DJSError(WSCodes[error.code]);\n        // Undefined if session is invalid, error event for regular closes\n      } else if (!error || error.code) {\n        this.debug('Failed to connect to the gateway, requeueing...', shard);\n        this.shardQueue.add(shard);\n      } else {\n        throw error;\n      }\n    }\n    // If we have more shards, add a 5s delay\n    if (this.shardQueue.size) {\n      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);\n      await Util.delayFor(5000);\n      await this._handleSessionLimit();\n      return this.createShards();\n    }\n    return true;\n  }\n\n  /**\n   * Handles reconnects for this manager.\n   * @param {boolean} [skipLimit=false] IF this reconnect should skip checking the session limit\n   * @private\n   * @returns {Promise<boolean>}\n   */\n  async reconnect() {\n    let skipLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.reconnecting || this.status !== Status.READY) return false;\n    this.reconnecting = true;\n    try {\n      if (!skipLimit) await this._handleSessionLimit();\n      await this.createShards();\n    } catch (error) {\n      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);\n      if (error.httpStatus !== 401) {\n        this.debug(`Possible network error occurred. Retrying in 5s...`);\n        await Util.delayFor(5000);\n        this.reconnecting = false;\n        return this.reconnect();\n      }\n      // If we get an error at this point, it means we cannot reconnect anymore\n      if (this.client.listenerCount(Events.INVALIDATED)) {\n        /**\n         * Emitted when the client's session becomes invalidated.\n         * You are expected to handle closing the process gracefully and preventing a boot loop\n         * if you are listening to this event.\n         * @event Client#invalidated\n         */\n        this.client.emit(Events.INVALIDATED);\n        // Destroy just the shards. This means you have to handle the cleanup yourself\n        this.destroy();\n      } else {\n        this.client.destroy();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return true;\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shard of this.shards.values()) shard.send(packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  destroy() {\n    if (this.destroyed) return;\n    this.debug(`Manager was destroyed. Called by:\\n${new Error('MANAGER_DESTROYED').stack}`);\n    this.destroyed = true;\n    this.shardQueue.clear();\n    for (const shard of this.shards.values()) shard.destroy({\n      closeCode: 1000,\n      reset: true,\n      emit: false,\n      log: false\n    });\n  }\n\n  /**\n   * Handles the timeout required if we cannot identify anymore.\n   * @param {number} [remaining] The amount of remaining identify sessions that can be done today\n   * @param {number} [resetAfter] The amount of time in which the identify counter resets\n   * @private\n   */\n  async _handleSessionLimit(remaining, resetAfter) {\n    if (typeof remaining === 'undefined' && typeof resetAfter === 'undefined') {\n      const {\n        session_start_limit\n      } = await this.client.api.gateway.bot.get();\n      this.sessionStartLimit = session_start_limit;\n      remaining = session_start_limit.remaining;\n      resetAfter = session_start_limit.reset_after;\n      this.debug(`Session Limit Information\n    Total: ${session_start_limit.total}\n    Remaining: ${remaining}`);\n    }\n    if (!remaining) {\n      this.debug(`Exceeded identify threshold. Will attempt a connection in ${resetAfter}ms`);\n      await Util.delayFor(resetAfter);\n    }\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.READY) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({\n          packet,\n          shard\n        });\n        return false;\n      }\n    }\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      this.client.setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      });\n    }\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  async checkShardsReady() {\n    if (this.status === Status.READY) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.READY)) {\n      return;\n    }\n    this.status = Status.NEARLY;\n    if (this.client.options.fetchAllMembers) {\n      try {\n        const promises = this.client.guilds.cache.map(guild => {\n          if (guild.available) return guild.members.fetch();\n          // Return empty promise if guild is unavailable\n          return Promise.resolve();\n        });\n        await Promise.all(promises);\n      } catch (err) {\n        this.debug(`Failed to fetch all members before ready! ${err}\\n${err.stack}`);\n      }\n    }\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.READY;\n    this.client.readyAt = new Date();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     */\n    this.client.emit(Events.CLIENT_READY);\n    this.handlePacket();\n  }\n}\nmodule.exports = WebSocketManager;","map":{"version":3,"names":["EventEmitter","require","WebSocketShard","PacketHandlers","Error","DJSError","Collection","Events","ShardEvents","Status","WSCodes","WSEvents","Util","BeforeReadyWhitelist","READY","RESUMED","GUILD_CREATE","GUILD_DELETE","GUILD_MEMBERS_CHUNK","GUILD_MEMBER_ADD","GUILD_MEMBER_REMOVE","UNRECOVERABLE_CLOSE_CODES","Object","keys","slice","map","Number","UNRESUMABLE_CLOSE_CODES","WebSocketManager","constructor","client","defineProperty","value","gateway","totalShards","options","shards","length","Set","writable","status","IDLE","destroyed","reconnecting","sessionStartLimit","ping","sum","reduce","a","b","size","debug","message","shard","emit","DEBUG","id","connect","invalidToken","url","gatewayURL","recommendedShards","session_start_limit","api","bot","get","catch","error","httpStatus","total","remaining","reset_after","shardCount","Array","from","_","i","join","shardQueue","_handleSessionLimit","createShards","delete","eventsAttached","on","ALL_READY","unavailableGuilds","SHARD_READY","checkShardsReady","CLOSE","event","code","includes","SHARD_DISCONNECT","sessionID","SHARD_RECONNECTING","add","reconnect","destroy","reset","log","INVALID_SESSION","DESTROYED","set","delayFor","skipLimit","listenerCount","INVALIDATED","broadcast","packet","values","send","stack","clear","closeCode","resetAfter","handlePacket","t","packetQueue","push","item","shift","setImmediate","some","s","NEARLY","fetchAllMembers","promises","guilds","cache","guild","available","members","fetch","Promise","resolve","all","err","triggerClientReady","readyAt","Date","CLIENT_READY","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/client/websocket/WebSocketManager.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst WebSocketShard = require('./WebSocketShard');\nconst PacketHandlers = require('./handlers');\nconst { Error: DJSError } = require('../../errors');\nconst Collection = require('../../util/Collection');\nconst { Events, ShardEvents, Status, WSCodes, WSEvents } = require('../../util/Constants');\nconst Util = require('../../util/Util');\n\nconst BeforeReadyWhitelist = [\n  WSEvents.READY,\n  WSEvents.RESUMED,\n  WSEvents.GUILD_CREATE,\n  WSEvents.GUILD_DELETE,\n  WSEvents.GUILD_MEMBERS_CHUNK,\n  WSEvents.GUILD_MEMBER_ADD,\n  WSEvents.GUILD_MEMBER_REMOVE,\n];\n\nconst UNRECOVERABLE_CLOSE_CODES = Object.keys(WSCodes).slice(1).map(Number);\nconst UNRESUMABLE_CLOSE_CODES = [1000, 4006, 4007];\n\n/**\n * The WebSocket manager for this client.\n * <info>This class forwards raw dispatch events,\n * read more about it here {@link https://discord.com/developers/docs/topics/gateway}</info>\n * @extends EventEmitter\n */\nclass WebSocketManager extends EventEmitter {\n  constructor(client) {\n    super();\n\n    /**\n     * The client that instantiated this WebSocketManager\n     * @type {Client}\n     * @readonly\n     * @name WebSocketManager#client\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The gateway this manager uses\n     * @type {?string}\n     */\n    this.gateway = null;\n\n    /**\n     * The amount of shards this manager handles\n     * @private\n     * @type {number}\n     */\n    this.totalShards = this.client.options.shards.length;\n\n    /**\n     * A collection of all shards this manager handles\n     * @type {Collection<number, WebSocketShard>}\n     */\n    this.shards = new Collection();\n\n    /**\n     * An array of shards to be connected or that need to reconnect\n     * @type {Set<WebSocketShard>}\n     * @private\n     * @name WebSocketManager#shardQueue\n     */\n    Object.defineProperty(this, 'shardQueue', { value: new Set(), writable: true });\n\n    /**\n     * An array of queued events before this WebSocketManager became ready\n     * @type {object[]}\n     * @private\n     * @name WebSocketManager#packetQueue\n     */\n    Object.defineProperty(this, 'packetQueue', { value: [] });\n\n    /**\n     * The current status of this WebSocketManager\n     * @type {number}\n     */\n    this.status = Status.IDLE;\n\n    /**\n     * If this manager was destroyed. It will prevent shards from reconnecting\n     * @type {boolean}\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * If this manager is currently reconnecting one or multiple shards\n     * @type {boolean}\n     * @private\n     */\n    this.reconnecting = false;\n\n    /**\n     * The current session limit of the client\n     * @private\n     * @type {?Object}\n     * @property {number} total Total number of identifies available\n     * @property {number} remaining Number of identifies remaining\n     * @property {number} reset_after Number of milliseconds after which the limit resets\n     */\n    this.sessionStartLimit = null;\n  }\n\n  /**\n   * The average ping of all WebSocketShards\n   * @type {number}\n   * @readonly\n   */\n  get ping() {\n    const sum = this.shards.reduce((a, b) => a + b.ping, 0);\n    return sum / this.shards.size;\n  }\n\n  /**\n   * Emits a debug message.\n   * @param {string} message The debug message\n   * @param {?WebSocketShard} [shard] The shard that emitted this message, if any\n   * @private\n   */\n  debug(message, shard) {\n    this.client.emit(Events.DEBUG, `[WS => ${shard ? `Shard ${shard.id}` : 'Manager'}] ${message}`);\n  }\n\n  /**\n   * Connects this manager to the gateway.\n   * @private\n   */\n  async connect() {\n    const invalidToken = new DJSError(WSCodes[4004]);\n    const {\n      url: gatewayURL,\n      shards: recommendedShards,\n      session_start_limit: sessionStartLimit,\n    } = await this.client.api.gateway.bot.get().catch(error => {\n      throw error.httpStatus === 401 ? invalidToken : error;\n    });\n\n    this.sessionStartLimit = sessionStartLimit;\n\n    const { total, remaining, reset_after } = sessionStartLimit;\n\n    this.debug(`Fetched Gateway Information\n    URL: ${gatewayURL}\n    Recommended Shards: ${recommendedShards}`);\n\n    this.debug(`Session Limit Information\n    Total: ${total}\n    Remaining: ${remaining}`);\n\n    this.gateway = `${gatewayURL}/`;\n\n    let { shards } = this.client.options;\n\n    if (shards === 'auto') {\n      this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);\n      this.totalShards = this.client.options.shardCount = recommendedShards;\n      shards = this.client.options.shards = Array.from({ length: recommendedShards }, (_, i) => i);\n    }\n\n    this.totalShards = shards.length;\n    this.debug(`Spawning shards: ${shards.join(', ')}`);\n    this.shardQueue = new Set(shards.map(id => new WebSocketShard(this, id)));\n\n    await this._handleSessionLimit(remaining, reset_after);\n\n    return this.createShards();\n  }\n\n  /**\n   * Handles the creation of a shard.\n   * @returns {Promise<boolean>}\n   * @private\n   */\n  async createShards() {\n    // If we don't have any shards to handle, return\n    if (!this.shardQueue.size) return false;\n\n    const [shard] = this.shardQueue;\n\n    this.shardQueue.delete(shard);\n\n    if (!shard.eventsAttached) {\n      shard.on(ShardEvents.ALL_READY, unavailableGuilds => {\n        /**\n         * Emitted when a shard turns ready.\n         * @event Client#shardReady\n         * @param {number} id The shard ID that turned ready\n         * @param {?Set<string>} unavailableGuilds Set of unavailable guild IDs, if any\n         */\n        this.client.emit(Events.SHARD_READY, shard.id, unavailableGuilds);\n\n        if (!this.shardQueue.size) this.reconnecting = false;\n        this.checkShardsReady();\n      });\n\n      shard.on(ShardEvents.CLOSE, event => {\n        if (event.code === 1000 ? this.destroyed : UNRECOVERABLE_CLOSE_CODES.includes(event.code)) {\n          /**\n           * Emitted when a shard's WebSocket disconnects and will no longer reconnect.\n           * @event Client#shardDisconnect\n           * @param {CloseEvent} event The WebSocket close event\n           * @param {number} id The shard ID that disconnected\n           */\n          this.client.emit(Events.SHARD_DISCONNECT, event, shard.id);\n          this.debug(WSCodes[event.code], shard);\n          return;\n        }\n\n        if (UNRESUMABLE_CLOSE_CODES.includes(event.code)) {\n          // These event codes cannot be resumed\n          shard.sessionID = null;\n        }\n\n        /**\n         * Emitted when a shard is attempting to reconnect or re-identify.\n         * @event Client#shardReconnecting\n         * @param {number} id The shard ID that is attempting to reconnect\n         */\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n\n        this.shardQueue.add(shard);\n\n        if (shard.sessionID) {\n          this.debug(`Session ID is present, attempting an immediate reconnect...`, shard);\n          this.reconnect(true);\n        } else {\n          shard.destroy({ reset: true, emit: false, log: false });\n          this.reconnect();\n        }\n      });\n\n      shard.on(ShardEvents.INVALID_SESSION, () => {\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n      });\n\n      shard.on(ShardEvents.DESTROYED, () => {\n        this.debug('Shard was destroyed but no WebSocket connection was present! Reconnecting...', shard);\n\n        this.client.emit(Events.SHARD_RECONNECTING, shard.id);\n\n        this.shardQueue.add(shard);\n        this.reconnect();\n      });\n\n      shard.eventsAttached = true;\n    }\n\n    this.shards.set(shard.id, shard);\n\n    try {\n      await shard.connect();\n    } catch (error) {\n      if (error && error.code && UNRECOVERABLE_CLOSE_CODES.includes(error.code)) {\n        throw new DJSError(WSCodes[error.code]);\n        // Undefined if session is invalid, error event for regular closes\n      } else if (!error || error.code) {\n        this.debug('Failed to connect to the gateway, requeueing...', shard);\n        this.shardQueue.add(shard);\n      } else {\n        throw error;\n      }\n    }\n    // If we have more shards, add a 5s delay\n    if (this.shardQueue.size) {\n      this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);\n      await Util.delayFor(5000);\n      await this._handleSessionLimit();\n      return this.createShards();\n    }\n\n    return true;\n  }\n\n  /**\n   * Handles reconnects for this manager.\n   * @param {boolean} [skipLimit=false] IF this reconnect should skip checking the session limit\n   * @private\n   * @returns {Promise<boolean>}\n   */\n  async reconnect(skipLimit = false) {\n    if (this.reconnecting || this.status !== Status.READY) return false;\n    this.reconnecting = true;\n    try {\n      if (!skipLimit) await this._handleSessionLimit();\n      await this.createShards();\n    } catch (error) {\n      this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);\n      if (error.httpStatus !== 401) {\n        this.debug(`Possible network error occurred. Retrying in 5s...`);\n        await Util.delayFor(5000);\n        this.reconnecting = false;\n        return this.reconnect();\n      }\n      // If we get an error at this point, it means we cannot reconnect anymore\n      if (this.client.listenerCount(Events.INVALIDATED)) {\n        /**\n         * Emitted when the client's session becomes invalidated.\n         * You are expected to handle closing the process gracefully and preventing a boot loop\n         * if you are listening to this event.\n         * @event Client#invalidated\n         */\n        this.client.emit(Events.INVALIDATED);\n        // Destroy just the shards. This means you have to handle the cleanup yourself\n        this.destroy();\n      } else {\n        this.client.destroy();\n      }\n    } finally {\n      this.reconnecting = false;\n    }\n    return true;\n  }\n\n  /**\n   * Broadcasts a packet to every shard this manager handles.\n   * @param {Object} packet The packet to send\n   * @private\n   */\n  broadcast(packet) {\n    for (const shard of this.shards.values()) shard.send(packet);\n  }\n\n  /**\n   * Destroys this manager and all its shards.\n   * @private\n   */\n  destroy() {\n    if (this.destroyed) return;\n    this.debug(`Manager was destroyed. Called by:\\n${new Error('MANAGER_DESTROYED').stack}`);\n    this.destroyed = true;\n    this.shardQueue.clear();\n    for (const shard of this.shards.values()) shard.destroy({ closeCode: 1000, reset: true, emit: false, log: false });\n  }\n\n  /**\n   * Handles the timeout required if we cannot identify anymore.\n   * @param {number} [remaining] The amount of remaining identify sessions that can be done today\n   * @param {number} [resetAfter] The amount of time in which the identify counter resets\n   * @private\n   */\n  async _handleSessionLimit(remaining, resetAfter) {\n    if (typeof remaining === 'undefined' && typeof resetAfter === 'undefined') {\n      const { session_start_limit } = await this.client.api.gateway.bot.get();\n      this.sessionStartLimit = session_start_limit;\n      remaining = session_start_limit.remaining;\n      resetAfter = session_start_limit.reset_after;\n      this.debug(`Session Limit Information\n    Total: ${session_start_limit.total}\n    Remaining: ${remaining}`);\n    }\n    if (!remaining) {\n      this.debug(`Exceeded identify threshold. Will attempt a connection in ${resetAfter}ms`);\n      await Util.delayFor(resetAfter);\n    }\n  }\n\n  /**\n   * Processes a packet and queues it if this WebSocketManager is not ready.\n   * @param {Object} [packet] The packet to be handled\n   * @param {WebSocketShard} [shard] The shard that will handle this packet\n   * @returns {boolean}\n   * @private\n   */\n  handlePacket(packet, shard) {\n    if (packet && this.status !== Status.READY) {\n      if (!BeforeReadyWhitelist.includes(packet.t)) {\n        this.packetQueue.push({ packet, shard });\n        return false;\n      }\n    }\n\n    if (this.packetQueue.length) {\n      const item = this.packetQueue.shift();\n      this.client.setImmediate(() => {\n        this.handlePacket(item.packet, item.shard);\n      });\n    }\n\n    if (packet && PacketHandlers[packet.t]) {\n      PacketHandlers[packet.t](this.client, packet, shard);\n    }\n\n    return true;\n  }\n\n  /**\n   * Checks whether the client is ready to be marked as ready.\n   * @private\n   */\n  async checkShardsReady() {\n    if (this.status === Status.READY) return;\n    if (this.shards.size !== this.totalShards || this.shards.some(s => s.status !== Status.READY)) {\n      return;\n    }\n\n    this.status = Status.NEARLY;\n\n    if (this.client.options.fetchAllMembers) {\n      try {\n        const promises = this.client.guilds.cache.map(guild => {\n          if (guild.available) return guild.members.fetch();\n          // Return empty promise if guild is unavailable\n          return Promise.resolve();\n        });\n        await Promise.all(promises);\n      } catch (err) {\n        this.debug(`Failed to fetch all members before ready! ${err}\\n${err.stack}`);\n      }\n    }\n\n    this.triggerClientReady();\n  }\n\n  /**\n   * Causes the client to be marked as ready and emits the ready event.\n   * @private\n   */\n  triggerClientReady() {\n    this.status = Status.READY;\n\n    this.client.readyAt = new Date();\n\n    /**\n     * Emitted when the client becomes ready to start working.\n     * @event Client#ready\n     */\n    this.client.emit(Events.CLIENT_READY);\n\n    this.handlePacket();\n  }\n}\n\nmodule.exports = WebSocketManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}