{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\nconst {\n  ChannelTypes\n} = require('../util/Constants');\nconst Snowflake = require('../util/Snowflake');\n\n/**\n * Represents any channel on Discord.\n * @extends {Base}\n * @abstract\n */\nclass Channel extends Base {\n  constructor(client, data) {\n    super(client);\n    const type = Object.keys(ChannelTypes)[data.type];\n    /**\n     * The type of the channel, either:\n     * * `dm` - a DM channel\n     * * `text` - a guild text channel\n     * * `voice` - a guild voice channel\n     * * `category` - a guild category channel\n     * * `news` - a guild news channel\n     * * `store` - a guild store channel\n     * * `unknown` - a generic channel of unknown type, could be Channel or GuildChannel\n     * @type {string}\n     */\n    this.type = type ? type.toLowerCase() : 'unknown';\n\n    /**\n     * Whether the channel has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n    if (data) this._patch(data);\n  }\n  _patch(data) {\n    /**\n     * The unique ID of the channel\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n  }\n\n  /**\n   * The timestamp the channel was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the channel was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the channel's mention instead of the Channel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <#123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n  toString() {\n    return `<#${this.id}>`;\n  }\n\n  /**\n   * Deletes this channel.\n   * @returns {Promise<Channel>}\n   * @example\n   * // Delete the channel\n   * channel.delete()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  delete() {\n    return this.client.api.channels(this.id).delete().then(() => this);\n  }\n\n  /**\n   * Fetches this channel.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Channel>}\n   */\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.client.channels.fetch(this.id, true, force);\n  }\n\n  /**\n   * Indicates whether this channel is text-based.\n   * @returns {boolean}\n   */\n  isText() {\n    return 'messages' in this;\n  }\n  static create(client, data, guild) {\n    const Structures = require('../util/Structures');\n    let channel;\n    if (!data.guild_id && !guild) {\n      if (data.recipients && data.type !== ChannelTypes.GROUP || data.type === ChannelTypes.DM) {\n        const DMChannel = Structures.get('DMChannel');\n        channel = new DMChannel(client, data);\n      } else if (data.type === ChannelTypes.GROUP) {\n        const PartialGroupDMChannel = require('./PartialGroupDMChannel');\n        channel = new PartialGroupDMChannel(client, data);\n      }\n    } else {\n      guild = guild || client.guilds.cache.get(data.guild_id);\n      if (guild) {\n        switch (data.type) {\n          case ChannelTypes.TEXT:\n            {\n              const TextChannel = Structures.get('TextChannel');\n              channel = new TextChannel(guild, data);\n              break;\n            }\n          case ChannelTypes.VOICE:\n            {\n              const VoiceChannel = Structures.get('VoiceChannel');\n              channel = new VoiceChannel(guild, data);\n              break;\n            }\n          case ChannelTypes.CATEGORY:\n            {\n              const CategoryChannel = Structures.get('CategoryChannel');\n              channel = new CategoryChannel(guild, data);\n              break;\n            }\n          case ChannelTypes.NEWS:\n            {\n              const NewsChannel = Structures.get('NewsChannel');\n              channel = new NewsChannel(guild, data);\n              break;\n            }\n          case ChannelTypes.STORE:\n            {\n              const StoreChannel = Structures.get('StoreChannel');\n              channel = new StoreChannel(guild, data);\n              break;\n            }\n        }\n        if (channel) guild.channels.cache.set(channel.id, channel);\n      }\n    }\n    return channel;\n  }\n  toJSON() {\n    for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n      props[_key] = arguments[_key];\n    }\n    return super.toJSON({\n      createdTimestamp: true\n    }, ...props);\n  }\n}\nmodule.exports = Channel;","map":{"version":3,"names":["Base","require","ChannelTypes","Snowflake","Channel","constructor","client","data","type","Object","keys","toLowerCase","deleted","_patch","id","createdTimestamp","deconstruct","timestamp","createdAt","Date","toString","delete","api","channels","then","fetch","force","isText","create","guild","Structures","channel","guild_id","recipients","GROUP","DM","DMChannel","get","PartialGroupDMChannel","guilds","cache","TEXT","TextChannel","VOICE","VoiceChannel","CATEGORY","CategoryChannel","NEWS","NewsChannel","STORE","StoreChannel","set","toJSON","props","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/Channel.js"],"sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst { ChannelTypes } = require('../util/Constants');\nconst Snowflake = require('../util/Snowflake');\n\n/**\n * Represents any channel on Discord.\n * @extends {Base}\n * @abstract\n */\nclass Channel extends Base {\n  constructor(client, data) {\n    super(client);\n\n    const type = Object.keys(ChannelTypes)[data.type];\n    /**\n     * The type of the channel, either:\n     * * `dm` - a DM channel\n     * * `text` - a guild text channel\n     * * `voice` - a guild voice channel\n     * * `category` - a guild category channel\n     * * `news` - a guild news channel\n     * * `store` - a guild store channel\n     * * `unknown` - a generic channel of unknown type, could be Channel or GuildChannel\n     * @type {string}\n     */\n    this.type = type ? type.toLowerCase() : 'unknown';\n\n    /**\n     * Whether the channel has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The unique ID of the channel\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n  }\n\n  /**\n   * The timestamp the channel was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the channel was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the channel's mention instead of the Channel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <#123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n  toString() {\n    return `<#${this.id}>`;\n  }\n\n  /**\n   * Deletes this channel.\n   * @returns {Promise<Channel>}\n   * @example\n   * // Delete the channel\n   * channel.delete()\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  delete() {\n    return this.client.api\n      .channels(this.id)\n      .delete()\n      .then(() => this);\n  }\n\n  /**\n   * Fetches this channel.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Channel>}\n   */\n  fetch(force = false) {\n    return this.client.channels.fetch(this.id, true, force);\n  }\n\n  /**\n   * Indicates whether this channel is text-based.\n   * @returns {boolean}\n   */\n  isText() {\n    return 'messages' in this;\n  }\n\n  static create(client, data, guild) {\n    const Structures = require('../util/Structures');\n    let channel;\n    if (!data.guild_id && !guild) {\n      if ((data.recipients && data.type !== ChannelTypes.GROUP) || data.type === ChannelTypes.DM) {\n        const DMChannel = Structures.get('DMChannel');\n        channel = new DMChannel(client, data);\n      } else if (data.type === ChannelTypes.GROUP) {\n        const PartialGroupDMChannel = require('./PartialGroupDMChannel');\n        channel = new PartialGroupDMChannel(client, data);\n      }\n    } else {\n      guild = guild || client.guilds.cache.get(data.guild_id);\n      if (guild) {\n        switch (data.type) {\n          case ChannelTypes.TEXT: {\n            const TextChannel = Structures.get('TextChannel');\n            channel = new TextChannel(guild, data);\n            break;\n          }\n          case ChannelTypes.VOICE: {\n            const VoiceChannel = Structures.get('VoiceChannel');\n            channel = new VoiceChannel(guild, data);\n            break;\n          }\n          case ChannelTypes.CATEGORY: {\n            const CategoryChannel = Structures.get('CategoryChannel');\n            channel = new CategoryChannel(guild, data);\n            break;\n          }\n          case ChannelTypes.NEWS: {\n            const NewsChannel = Structures.get('NewsChannel');\n            channel = new NewsChannel(guild, data);\n            break;\n          }\n          case ChannelTypes.STORE: {\n            const StoreChannel = Structures.get('StoreChannel');\n            channel = new StoreChannel(guild, data);\n            break;\n          }\n        }\n        if (channel) guild.channels.cache.set(channel.id, channel);\n      }\n    }\n    return channel;\n  }\n\n  toJSON(...props) {\n    return super.toJSON({ createdTimestamp: true }, ...props);\n  }\n}\n\nmodule.exports = Channel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}