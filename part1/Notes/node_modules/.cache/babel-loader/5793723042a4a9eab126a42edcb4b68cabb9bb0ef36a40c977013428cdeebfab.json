{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst {\n  Error\n} = require('../errors');\nconst Snowflake = require('../util/Snowflake');\nconst UserFlags = require('../util/UserFlags');\nlet Structures;\n\n/**\n * Represents a user on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\nclass User extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the user\n   */\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * The ID of the user\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    this.system = null;\n    this.locale = null;\n    this.flags = null;\n    this._patch(data);\n  }\n  _patch(data) {\n    if ('username' in data) {\n      /**\n       * The username of the user\n       * @type {?string}\n       */\n      this.username = data.username;\n    } else if (typeof this.username !== 'string') {\n      this.username = null;\n    }\n    if ('bot' in data || typeof this.bot !== 'boolean') {\n      /**\n       * Whether or not the user is a bot\n       * @type {boolean}\n       */\n      this.bot = Boolean(data.bot);\n    }\n    if ('discriminator' in data) {\n      /**\n       * A discriminator based on username for the user\n       * @type {?string}\n       */\n      this.discriminator = data.discriminator;\n    } else if (typeof this.discriminator !== 'string') {\n      this.discriminator = null;\n    }\n    if ('avatar' in data) {\n      /**\n       * The ID of the user's avatar\n       * @type {?string}\n       */\n      this.avatar = data.avatar;\n    } else if (typeof this.avatar !== 'string') {\n      this.avatar = null;\n    }\n    if ('system' in data) {\n      /**\n       * Whether the user is an Official Discord System user (part of the urgent message system)\n       * @type {?boolean}\n       */\n      this.system = Boolean(data.system);\n    }\n    if ('locale' in data) {\n      /**\n       * The locale of the user's client (ISO 639-1)\n       * @type {?string}\n       */\n      this.locale = data.locale;\n    }\n    if ('public_flags' in data) {\n      /**\n       * The flags for this user\n       * @type {?UserFlags}\n       */\n      this.flags = new UserFlags(data.public_flags);\n    }\n\n    /**\n     * The ID of the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = null;\n\n    /**\n     * The ID of the channel for the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageChannelID = null;\n  }\n\n  /**\n   * Whether this User is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.username !== 'string';\n  }\n\n  /**\n   * The timestamp the user was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the user was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The Message object of the last message sent by the user, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    const channel = this.client.channels.cache.get(this.lastMessageChannelID);\n    return channel && channel.messages.cache.get(this.lastMessageID) || null;\n  }\n\n  /**\n   * The presence of this user\n   * @type {Presence}\n   * @readonly\n   */\n  get presence() {\n    for (const guild of this.client.guilds.cache.values()) {\n      if (guild.presences.cache.has(this.id)) return guild.presences.cache.get(this.id);\n    }\n    if (!Structures) Structures = require('../util/Structures');\n    const Presence = Structures.get('Presence');\n    return new Presence(this.client, {\n      user: {\n        id: this.id\n      }\n    });\n  }\n\n  /**\n   * A link to the user's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  avatarURL() {\n    let {\n      format,\n      size,\n      dynamic\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size, dynamic);\n  }\n\n  /**\n   * A link to the user's default avatar\n   * @type {string}\n   * @readonly\n   */\n  get defaultAvatarURL() {\n    return this.client.rest.cdn.DefaultAvatar(this.discriminator % 5);\n  }\n\n  /**\n   * A link to the user's avatar if they have one.\n   * Otherwise a link to their default avatar will be returned.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {string}\n   */\n  displayAvatarURL(options) {\n    return this.avatarURL(options) || this.defaultAvatarURL;\n  }\n\n  /**\n   * The Discord \"tag\" (e.g. `hydrabolt#0001`) for this user\n   * @type {?string}\n   * @readonly\n   */\n  get tag() {\n    return typeof this.username === 'string' ? `${this.username}#${this.discriminator}` : null;\n  }\n\n  /**\n   * Checks whether the user is typing in a channel.\n   * @param {ChannelResolvable} channel The channel to check in\n   * @returns {boolean}\n   */\n  typingIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id);\n  }\n\n  /**\n   * Gets the time that the user started typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {?Date}\n   */\n  typingSinceIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? new Date(channel._typing.get(this.id).since) : null;\n  }\n\n  /**\n   * Gets the amount of time the user has been typing in a channel for (in milliseconds), or -1 if they're not typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {number}\n   */\n  typingDurationIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1;\n  }\n\n  /**\n   * The DM between the client's user and this user\n   * @type {?DMChannel}\n   * @readonly\n   */\n  get dmChannel() {\n    return this.client.channels.cache.find(c => c.type === 'dm' && c.recipient.id === this.id) || null;\n  }\n\n  /**\n   * Creates a DM channel between the client and the user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n  async createDM() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!force) {\n      const {\n        dmChannel\n      } = this;\n      if (dmChannel && !dmChannel.partial) return dmChannel;\n    }\n    const data = await this.client.api.users(this.client.user.id).channels.post({\n      data: {\n        recipient_id: this.id\n      }\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.\n   * @returns {Promise<DMChannel>}\n   */\n  async deleteDM() {\n    const {\n      dmChannel\n    } = this;\n    if (!dmChannel) throw new Error('USER_NO_DMCHANNEL');\n    const data = await this.client.api.channels(dmChannel.id).delete();\n    return this.client.actions.ChannelDelete.handle(data).channel;\n  }\n\n  /**\n   * Checks if the user is equal to another. It compares ID, username, discriminator, avatar, and bot flags.\n   * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.\n   * @param {User} user User to compare with\n   * @returns {boolean}\n   */\n  equals(user) {\n    let equal = user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar;\n    return equal;\n  }\n\n  /**\n   * Fetches this user's flags.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the AP\n   * @returns {Promise<UserFlags>}\n   */\n  async fetchFlags() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.flags && !force) return this.flags;\n    const data = await this.client.api.users(this.id).get();\n    this._patch(data);\n    return this.flags;\n  }\n\n  /**\n   * Fetches this user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the AP\n   * @returns {Promise<User>}\n   */\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.client.users.fetch(this.id, true, force);\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the user's mention instead of the User object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${user}!`);\n   */\n  toString() {\n    return `<@${this.id}>`;\n  }\n  toJSON() {\n    for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {\n      props[_key] = arguments[_key];\n    }\n    const json = super.toJSON({\n      createdTimestamp: true,\n      defaultAvatarURL: true,\n      tag: true,\n      lastMessage: false,\n      lastMessageID: false\n    }, ...props);\n    json.avatarURL = this.avatarURL();\n    json.displayAvatarURL = this.displayAvatarURL();\n    return json;\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  send() {}\n}\nTextBasedChannel.applyToClass(User);\nmodule.exports = User;","map":{"version":3,"names":["Base","require","TextBasedChannel","Error","Snowflake","UserFlags","Structures","User","constructor","client","data","id","system","locale","flags","_patch","username","bot","Boolean","discriminator","avatar","public_flags","lastMessageID","lastMessageChannelID","partial","createdTimestamp","deconstruct","timestamp","createdAt","Date","lastMessage","channel","channels","cache","get","messages","presence","guild","guilds","values","presences","has","Presence","user","avatarURL","format","size","dynamic","rest","cdn","Avatar","defaultAvatarURL","DefaultAvatar","displayAvatarURL","options","tag","typingIn","resolve","_typing","typingSinceIn","since","typingDurationIn","elapsedTime","dmChannel","find","c","type","recipient","createDM","force","api","users","post","recipient_id","actions","ChannelCreate","handle","deleteDM","delete","ChannelDelete","equals","equal","fetchFlags","fetch","toString","toJSON","props","json","send","applyToClass","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/User.js"],"sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst { Error } = require('../errors');\nconst Snowflake = require('../util/Snowflake');\nconst UserFlags = require('../util/UserFlags');\n\nlet Structures;\n\n/**\n * Represents a user on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\nclass User extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the user\n   */\n  constructor(client, data) {\n    super(client);\n\n    /**\n     * The ID of the user\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    this.system = null;\n    this.locale = null;\n    this.flags = null;\n\n    this._patch(data);\n  }\n\n  _patch(data) {\n    if ('username' in data) {\n      /**\n       * The username of the user\n       * @type {?string}\n       */\n      this.username = data.username;\n    } else if (typeof this.username !== 'string') {\n      this.username = null;\n    }\n\n    if ('bot' in data || typeof this.bot !== 'boolean') {\n      /**\n       * Whether or not the user is a bot\n       * @type {boolean}\n       */\n      this.bot = Boolean(data.bot);\n    }\n\n    if ('discriminator' in data) {\n      /**\n       * A discriminator based on username for the user\n       * @type {?string}\n       */\n      this.discriminator = data.discriminator;\n    } else if (typeof this.discriminator !== 'string') {\n      this.discriminator = null;\n    }\n\n    if ('avatar' in data) {\n      /**\n       * The ID of the user's avatar\n       * @type {?string}\n       */\n      this.avatar = data.avatar;\n    } else if (typeof this.avatar !== 'string') {\n      this.avatar = null;\n    }\n\n    if ('system' in data) {\n      /**\n       * Whether the user is an Official Discord System user (part of the urgent message system)\n       * @type {?boolean}\n       */\n      this.system = Boolean(data.system);\n    }\n\n    if ('locale' in data) {\n      /**\n       * The locale of the user's client (ISO 639-1)\n       * @type {?string}\n       */\n      this.locale = data.locale;\n    }\n\n    if ('public_flags' in data) {\n      /**\n       * The flags for this user\n       * @type {?UserFlags}\n       */\n      this.flags = new UserFlags(data.public_flags);\n    }\n\n    /**\n     * The ID of the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = null;\n\n    /**\n     * The ID of the channel for the last message sent by the user, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageChannelID = null;\n  }\n\n  /**\n   * Whether this User is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.username !== 'string';\n  }\n\n  /**\n   * The timestamp the user was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the user was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The Message object of the last message sent by the user, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    const channel = this.client.channels.cache.get(this.lastMessageChannelID);\n    return (channel && channel.messages.cache.get(this.lastMessageID)) || null;\n  }\n\n  /**\n   * The presence of this user\n   * @type {Presence}\n   * @readonly\n   */\n  get presence() {\n    for (const guild of this.client.guilds.cache.values()) {\n      if (guild.presences.cache.has(this.id)) return guild.presences.cache.get(this.id);\n    }\n    if (!Structures) Structures = require('../util/Structures');\n    const Presence = Structures.get('Presence');\n    return new Presence(this.client, { user: { id: this.id } });\n  }\n\n  /**\n   * A link to the user's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  avatarURL({ format, size, dynamic } = {}) {\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size, dynamic);\n  }\n\n  /**\n   * A link to the user's default avatar\n   * @type {string}\n   * @readonly\n   */\n  get defaultAvatarURL() {\n    return this.client.rest.cdn.DefaultAvatar(this.discriminator % 5);\n  }\n\n  /**\n   * A link to the user's avatar if they have one.\n   * Otherwise a link to their default avatar will be returned.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {string}\n   */\n  displayAvatarURL(options) {\n    return this.avatarURL(options) || this.defaultAvatarURL;\n  }\n\n  /**\n   * The Discord \"tag\" (e.g. `hydrabolt#0001`) for this user\n   * @type {?string}\n   * @readonly\n   */\n  get tag() {\n    return typeof this.username === 'string' ? `${this.username}#${this.discriminator}` : null;\n  }\n\n  /**\n   * Checks whether the user is typing in a channel.\n   * @param {ChannelResolvable} channel The channel to check in\n   * @returns {boolean}\n   */\n  typingIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id);\n  }\n\n  /**\n   * Gets the time that the user started typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {?Date}\n   */\n  typingSinceIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? new Date(channel._typing.get(this.id).since) : null;\n  }\n\n  /**\n   * Gets the amount of time the user has been typing in a channel for (in milliseconds), or -1 if they're not typing.\n   * @param {ChannelResolvable} channel The channel to get the time in\n   * @returns {number}\n   */\n  typingDurationIn(channel) {\n    channel = this.client.channels.resolve(channel);\n    return channel._typing.has(this.id) ? channel._typing.get(this.id).elapsedTime : -1;\n  }\n\n  /**\n   * The DM between the client's user and this user\n   * @type {?DMChannel}\n   * @readonly\n   */\n  get dmChannel() {\n    return this.client.channels.cache.find(c => c.type === 'dm' && c.recipient.id === this.id) || null;\n  }\n\n  /**\n   * Creates a DM channel between the client and the user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n  async createDM(force = false) {\n    if (!force) {\n      const { dmChannel } = this;\n      if (dmChannel && !dmChannel.partial) return dmChannel;\n    }\n\n    const data = await this.client.api.users(this.client.user.id).channels.post({\n      data: {\n        recipient_id: this.id,\n      },\n    });\n    return this.client.actions.ChannelCreate.handle(data).channel;\n  }\n\n  /**\n   * Deletes a DM channel (if one exists) between the client and the user. Resolves with the channel if successful.\n   * @returns {Promise<DMChannel>}\n   */\n  async deleteDM() {\n    const { dmChannel } = this;\n    if (!dmChannel) throw new Error('USER_NO_DMCHANNEL');\n    const data = await this.client.api.channels(dmChannel.id).delete();\n    return this.client.actions.ChannelDelete.handle(data).channel;\n  }\n\n  /**\n   * Checks if the user is equal to another. It compares ID, username, discriminator, avatar, and bot flags.\n   * It is recommended to compare equality by using `user.id === user2.id` unless you want to compare all properties.\n   * @param {User} user User to compare with\n   * @returns {boolean}\n   */\n  equals(user) {\n    let equal =\n      user &&\n      this.id === user.id &&\n      this.username === user.username &&\n      this.discriminator === user.discriminator &&\n      this.avatar === user.avatar;\n\n    return equal;\n  }\n\n  /**\n   * Fetches this user's flags.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the AP\n   * @returns {Promise<UserFlags>}\n   */\n  async fetchFlags(force = false) {\n    if (this.flags && !force) return this.flags;\n    const data = await this.client.api.users(this.id).get();\n    this._patch(data);\n    return this.flags;\n  }\n\n  /**\n   * Fetches this user.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the AP\n   * @returns {Promise<User>}\n   */\n  fetch(force = false) {\n    return this.client.users.fetch(this.id, true, force);\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the user's mention instead of the User object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${user}!`);\n   */\n  toString() {\n    return `<@${this.id}>`;\n  }\n\n  toJSON(...props) {\n    const json = super.toJSON(\n      {\n        createdTimestamp: true,\n        defaultAvatarURL: true,\n        tag: true,\n        lastMessage: false,\n        lastMessageID: false,\n      },\n      ...props,\n    );\n    json.avatarURL = this.avatarURL();\n    json.displayAvatarURL = this.displayAvatarURL();\n    return json;\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  send() {}\n}\n\nTextBasedChannel.applyToClass(User);\n\nmodule.exports = User;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}