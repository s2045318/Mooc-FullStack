{"ast":null,"code":"'use strict';\n\nconst APIMessage = require('./APIMessage');\nconst Channel = require('./Channel');\nconst {\n  WebhookTypes\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Snowflake = require('../util/Snowflake');\n\n/**\n * Represents a webhook.\n */\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n    if (data) this._patch(data);\n  }\n  _patch(data) {\n    /**\n     * The name of the webhook\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The token for the webhook\n     * @name Webhook#token\n     * @type {?string}\n     */\n    Object.defineProperty(this, 'token', {\n      value: data.token || null,\n      writable: true,\n      configurable: true\n    });\n\n    /**\n     * The avatar for the webhook\n     * @type {?string}\n     */\n    this.avatar = data.avatar;\n\n    /**\n     * The ID of the webhook\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The type of the webhook\n     * @type {WebhookTypes}\n     */\n    this.type = WebhookTypes[data.type];\n\n    /**\n     * The guild the webhook belongs to\n     * @type {Snowflake}\n     */\n    this.guildID = data.guild_id;\n\n    /**\n     * The channel the webhook belongs to\n     * @type {Snowflake}\n     */\n    this.channelID = data.channel_id;\n    if (data.user) {\n      /**\n       * The owner of the webhook\n       * @type {?User|Object}\n       */\n      this.owner = this.client.users ? this.client.users.cache.get(data.user.id) : data.user;\n    } else {\n      this.owner = null;\n    }\n  }\n\n  /**\n   * Options that can be passed into send.\n   * @typedef {Object} WebhookMessageOptions\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {Object[]} [embeds] An array of embeds for the message\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n   * everyone/here mentions should be sanitized to prevent unexpected mentions\n   * @property {FileOptions[]|string[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message.\n   */\n\n  /**\n   * Sends a message with this webhook.\n   * @param {StringResolvable|APIMessage} [content=''] The content to send\n   * @param {WebhookMessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Object>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send('This is an embed', {\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(content, options) {\n    let apiMessage;\n    if (content instanceof APIMessage) {\n      apiMessage = content.resolveData();\n    } else {\n      apiMessage = APIMessage.create(this, content, options).resolveData();\n      if (Array.isArray(apiMessage.data.content)) {\n        return Promise.all(apiMessage.split().map(this.send.bind(this)));\n      }\n    }\n    const {\n      data,\n      files\n    } = await apiMessage.resolveFiles();\n    return this.client.api.webhooks(this.id, this.token).post({\n      data,\n      files,\n      query: {\n        wait: true\n      },\n      auth: false\n    }).then(d => {\n      const channel = this.client.channels ? this.client.channels.cache.get(d.channel_id) : undefined;\n      if (!channel) return d;\n      return channel.messages.add(d, false);\n    });\n  }\n\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1000\n   *   }]\n   * }).catch(console.error);\n   */\n  sendSlackMessage(body) {\n    return this.client.api.webhooks(this.id, this.token).slack.post({\n      query: {\n        wait: true\n      },\n      auth: false,\n      data: body\n    }).then(data => data.toString() === 'ok');\n  }\n\n  /**\n   * Edits the webhook.\n   * @param {Object} options Options\n   * @param {string} [options.name=this.name] New name for this webhook\n   * @param {BufferResolvable} [options.avatar] New avatar for this webhook\n   * @param {ChannelResolvable} [options.channel] New channel for this webhook\n   * @param {string} [reason] Reason for editing this webhook\n   * @returns {Promise<Webhook>}\n   */\n  async edit(_ref, reason) {\n    let {\n      name = this.name,\n      avatar,\n      channel\n    } = _ref;\n    if (avatar && typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    if (channel) channel = channel instanceof Channel ? channel.id : channel;\n    const data = await this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({\n      data: {\n        name,\n        avatar,\n        channel_id: channel\n      },\n      reason\n    });\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelID = data.channel_id;\n    return this;\n  }\n\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise}\n   */\n  delete(reason) {\n    return this.client.api.webhooks(this.id, this.token).delete({\n      reason\n    });\n  }\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The url of this webhook\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);\n  }\n\n  /**\n   * A link to the webhook's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  avatarURL() {\n    let {\n      format,\n      size\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);\n  }\n  static applyToClass(structure) {\n    for (const prop of ['send', 'sendSlackMessage', 'edit', 'delete', 'createdTimestamp', 'createdAt', 'url']) {\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n}\nmodule.exports = Webhook;","map":{"version":3,"names":["APIMessage","require","Channel","WebhookTypes","DataResolver","Snowflake","Webhook","constructor","client","data","Object","defineProperty","value","_patch","name","token","writable","configurable","avatar","id","type","guildID","guild_id","channelID","channel_id","user","owner","users","cache","get","send","content","options","apiMessage","resolveData","create","Array","isArray","Promise","all","split","map","bind","files","resolveFiles","api","webhooks","post","query","wait","auth","then","d","channel","channels","undefined","messages","add","sendSlackMessage","body","slack","toString","edit","reason","startsWith","resolveImage","patch","delete","createdTimestamp","deconstruct","timestamp","createdAt","Date","url","http","avatarURL","format","size","rest","cdn","Avatar","applyToClass","structure","prop","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/Webhook.js"],"sourcesContent":["'use strict';\n\nconst APIMessage = require('./APIMessage');\nconst Channel = require('./Channel');\nconst { WebhookTypes } = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Snowflake = require('../util/Snowflake');\n\n/**\n * Represents a webhook.\n */\nclass Webhook {\n  constructor(client, data) {\n    /**\n     * The client that instantiated the webhook\n     * @name Webhook#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The name of the webhook\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The token for the webhook\n     * @name Webhook#token\n     * @type {?string}\n     */\n    Object.defineProperty(this, 'token', { value: data.token || null, writable: true, configurable: true });\n\n    /**\n     * The avatar for the webhook\n     * @type {?string}\n     */\n    this.avatar = data.avatar;\n\n    /**\n     * The ID of the webhook\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    /**\n     * The type of the webhook\n     * @type {WebhookTypes}\n     */\n    this.type = WebhookTypes[data.type];\n\n    /**\n     * The guild the webhook belongs to\n     * @type {Snowflake}\n     */\n    this.guildID = data.guild_id;\n\n    /**\n     * The channel the webhook belongs to\n     * @type {Snowflake}\n     */\n    this.channelID = data.channel_id;\n\n    if (data.user) {\n      /**\n       * The owner of the webhook\n       * @type {?User|Object}\n       */\n      this.owner = this.client.users ? this.client.users.cache.get(data.user.id) : data.user;\n    } else {\n      this.owner = null;\n    }\n  }\n\n  /**\n   * Options that can be passed into send.\n   * @typedef {Object} WebhookMessageOptions\n   * @property {string} [username=this.name] Username override for the message\n   * @property {string} [avatarURL] Avatar URL override for the message\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {Object[]} [embeds] An array of embeds for the message\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n   * everyone/here mentions should be sanitized to prevent unexpected mentions\n   * @property {FileOptions[]|string[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message.\n   */\n\n  /**\n   * Sends a message with this webhook.\n   * @param {StringResolvable|APIMessage} [content=''] The content to send\n   * @param {WebhookMessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Object>}\n   * @example\n   * // Send a basic message\n   * webhook.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * webhook.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * webhook.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * webhook.send('This is an embed', {\n   *   embeds: [{\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    }],\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(content, options) {\n    let apiMessage;\n\n    if (content instanceof APIMessage) {\n      apiMessage = content.resolveData();\n    } else {\n      apiMessage = APIMessage.create(this, content, options).resolveData();\n      if (Array.isArray(apiMessage.data.content)) {\n        return Promise.all(apiMessage.split().map(this.send.bind(this)));\n      }\n    }\n\n    const { data, files } = await apiMessage.resolveFiles();\n    return this.client.api\n      .webhooks(this.id, this.token)\n      .post({\n        data,\n        files,\n        query: { wait: true },\n        auth: false,\n      })\n      .then(d => {\n        const channel = this.client.channels ? this.client.channels.cache.get(d.channel_id) : undefined;\n        if (!channel) return d;\n        return channel.messages.add(d, false);\n      });\n  }\n\n  /**\n   * Sends a raw slack message with this webhook.\n   * @param {Object} body The raw body to send\n   * @returns {Promise<boolean>}\n   * @example\n   * // Send a slack message\n   * webhook.sendSlackMessage({\n   *   'username': 'Wumpus',\n   *   'attachments': [{\n   *     'pretext': 'this looks pretty cool',\n   *     'color': '#F0F',\n   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',\n   *     'footer': 'Powered by sneks',\n   *     'ts': Date.now() / 1000\n   *   }]\n   * }).catch(console.error);\n   */\n  sendSlackMessage(body) {\n    return this.client.api\n      .webhooks(this.id, this.token)\n      .slack.post({\n        query: { wait: true },\n        auth: false,\n        data: body,\n      })\n      .then(data => data.toString() === 'ok');\n  }\n\n  /**\n   * Edits the webhook.\n   * @param {Object} options Options\n   * @param {string} [options.name=this.name] New name for this webhook\n   * @param {BufferResolvable} [options.avatar] New avatar for this webhook\n   * @param {ChannelResolvable} [options.channel] New channel for this webhook\n   * @param {string} [reason] Reason for editing this webhook\n   * @returns {Promise<Webhook>}\n   */\n  async edit({ name = this.name, avatar, channel }, reason) {\n    if (avatar && typeof avatar === 'string' && !avatar.startsWith('data:')) {\n      avatar = await DataResolver.resolveImage(avatar);\n    }\n    if (channel) channel = channel instanceof Channel ? channel.id : channel;\n    const data = await this.client.api.webhooks(this.id, channel ? undefined : this.token).patch({\n      data: { name, avatar, channel_id: channel },\n      reason,\n    });\n\n    this.name = data.name;\n    this.avatar = data.avatar;\n    this.channelID = data.channel_id;\n    return this;\n  }\n\n  /**\n   * Deletes the webhook.\n   * @param {string} [reason] Reason for deleting this webhook\n   * @returns {Promise}\n   */\n  delete(reason) {\n    return this.client.api.webhooks(this.id, this.token).delete({ reason });\n  }\n  /**\n   * The timestamp the webhook was created at\n   * @type {number}\n   * @readonly\n   */\n  get createdTimestamp() {\n    return Snowflake.deconstruct(this.id).timestamp;\n  }\n\n  /**\n   * The time the webhook was created at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The url of this webhook\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return this.client.options.http.api + this.client.api.webhooks(this.id, this.token);\n  }\n\n  /**\n   * A link to the webhook's avatar.\n   * @param {ImageURLOptions} [options={}] Options for the Image URL\n   * @returns {?string}\n   */\n  avatarURL({ format, size } = {}) {\n    if (!this.avatar) return null;\n    return this.client.rest.cdn.Avatar(this.id, this.avatar, format, size);\n  }\n\n  static applyToClass(structure) {\n    for (const prop of ['send', 'sendSlackMessage', 'edit', 'delete', 'createdTimestamp', 'createdAt', 'url']) {\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));\n    }\n  }\n}\n\nmodule.exports = Webhook;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}