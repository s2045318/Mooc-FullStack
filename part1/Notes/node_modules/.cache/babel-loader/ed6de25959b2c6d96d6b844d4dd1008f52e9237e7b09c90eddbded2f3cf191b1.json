{"ast":null,"code":"'use strict';\n\nconst APIMessage = require('./APIMessage');\nconst Base = require('./Base');\nconst ClientApplication = require('./ClientApplication');\nconst MessageAttachment = require('./MessageAttachment');\nconst Embed = require('./MessageEmbed');\nconst Mentions = require('./MessageMentions');\nconst ReactionCollector = require('./ReactionCollector');\nconst {\n  Error,\n  TypeError\n} = require('../errors');\nconst ReactionManager = require('../managers/ReactionManager');\nconst Collection = require('../util/Collection');\nconst {\n  MessageTypes\n} = require('../util/Constants');\nconst MessageFlags = require('../util/MessageFlags');\nconst Permissions = require('../util/Permissions');\nconst SnowflakeUtil = require('../util/Snowflake');\nconst Util = require('../util/Util');\n\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\nclass Message extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the message\n   * @param {TextChannel|DMChannel|NewsChannel} channel The channel the message was sent in\n   */\n  constructor(client, data, channel) {\n    super(client);\n\n    /**\n     * The channel that the message was sent in\n     * @type {TextChannel|DMChannel|NewsChannel}\n     */\n    this.channel = channel;\n\n    /**\n     * Whether this message has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n    if (data) this._patch(data);\n  }\n  _patch(data) {\n    /**\n     * The ID of the message\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = MessageTypes[data.type];\n\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n      this.system = data.type !== 0;\n    } else if (typeof this.type !== 'string') {\n      this.system = null;\n      this.type = null;\n    }\n    if ('content' in data) {\n      /**\n       * The content of the message\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else if (typeof this.content !== 'string') {\n      this.content = null;\n    }\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users.add(data.author, !data.webhook_id);\n    } else if (!this.author) {\n      this.author = null;\n    }\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else if (typeof this.pinned !== 'boolean') {\n      this.pinned = null;\n    }\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else if (typeof this.tts !== 'boolean') {\n      this.tts = null;\n    }\n\n    /**\n     * A random number or string used for checking message delivery\n     * <warn>This is only received after the message was sent successfully, and\n     * lost if re-fetched</warn>\n     * @type {?string}\n     */\n    this.nonce = 'nonce' in data ? data.nonce : null;\n\n    /**\n     * A list of embeds in the message - e.g. YouTube Player\n     * @type {MessageEmbed[]}\n     */\n    this.embeds = (data.embeds || []).map(e => new Embed(e, true));\n\n    /**\n     * A collection of attachments in the message - e.g. Pictures - mapped by their ID\n     * @type {Collection<Snowflake, MessageAttachment>}\n     */\n    this.attachments = new Collection();\n    if (data.attachments) {\n      for (const attachment of data.attachments) {\n        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n      }\n    }\n\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n    this.createdTimestamp = SnowflakeUtil.deconstruct(this.id).timestamp;\n\n    /**\n     * The timestamp the message was last edited at (if applicable)\n     * @type {?number}\n     */\n    this.editedTimestamp = 'edited_timestamp' in data ? new Date(data.edited_timestamp).getTime() : null;\n\n    /**\n     * A manager of the reactions belonging to this message\n     * @type {ReactionManager}\n     */\n    this.reactions = new ReactionManager(this);\n    if (data.reactions && data.reactions.length > 0) {\n      for (const reaction of data.reactions) {\n        this.reactions.add(reaction);\n      }\n    }\n\n    /**\n     * All valid mentions that the message contains\n     * @type {MessageMentions}\n     */\n    this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels);\n\n    /**\n     * ID of the webhook that sent the message, if applicable\n     * @type {?Snowflake}\n     */\n    this.webhookID = data.webhook_id || null;\n\n    /**\n     * Supplemental application information for group activities\n     * @type {?ClientApplication}\n     */\n    this.application = data.application ? new ClientApplication(this.client, data.application) : null;\n\n    /**\n     * Group activity\n     * @type {?MessageActivity}\n     */\n    this.activity = data.activity ? {\n      partyID: data.activity.party_id,\n      type: data.activity.type\n    } : null;\n\n    /**\n     * The previous versions of the message, sorted with the most recent first\n     * @type {Message[]}\n     * @private\n     */\n    this._edits = [];\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members.add(Object.assign(data.member, {\n        user: this.author\n      }));\n    }\n\n    /**\n     * Flags that are applied to the message\n     * @type {Readonly<MessageFlags>}\n     */\n    this.flags = new MessageFlags(data.flags).freeze();\n\n    /**\n     * Reference data sent in a crossposted message.\n     * @typedef {Object} MessageReference\n     * @property {string} channelID ID of the channel the message was crossposted from\n     * @property {?string} guildID ID of the guild the message was crossposted from\n     * @property {?string} messageID ID of the message that was crossposted\n     */\n\n    /**\n     * Message reference data\n     * @type {?MessageReference}\n     */\n    this.reference = data.message_reference ? {\n      channelID: data.message_reference.channel_id,\n      guildID: data.message_reference.guild_id,\n      messageID: data.message_reference.message_id\n    } : null;\n  }\n\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n\n  /**\n   * Updates the message and returns the old message.\n   * @param {Object} data Raw Discord message update data\n   * @returns {Message}\n   * @private\n   */\n  patch(data) {\n    const clone = this._clone();\n    const {\n      messageEditHistoryMaxSize\n    } = this.client.options;\n    if (messageEditHistoryMaxSize !== 0) {\n      const editsLimit = messageEditHistoryMaxSize === -1 ? Infinity : messageEditHistoryMaxSize;\n      if (this._edits.unshift(clone) > editsLimit) this._edits.pop();\n    }\n    if ('edited_timestamp' in data) this.editedTimestamp = new Date(data.edited_timestamp).getTime();\n    if ('content' in data) this.content = data.content;\n    if ('pinned' in data) this.pinned = data.pinned;\n    if ('tts' in data) this.tts = data.tts;\n    if ('embeds' in data) this.embeds = data.embeds.map(e => new Embed(e, true));else this.embeds = this.embeds.slice();\n    if ('attachments' in data) {\n      this.attachments = new Collection();\n      for (const attachment of data.attachments) {\n        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n    this.mentions = new Mentions(this, 'mentions' in data ? data.mentions : this.mentions.users, 'mention_roles' in data ? data.mention_roles : this.mentions.roles, 'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone, 'mention_channels' in data ? data.mention_channels : this.mentions.crosspostedChannels);\n    this.flags = new MessageFlags('flags' in data ? data.flags : 0).freeze();\n    return clone;\n  }\n\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild ? this.guild.member(this.author) || null : null;\n  }\n\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n  get editedAt() {\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n  }\n\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n  get guild() {\n    return this.channel.guild || null;\n  }\n\n  /**\n   * The url to jump to this message\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return `https://discord.com/channels/${this.guild ? this.guild.id : '@me'}/${this.channel.id}/${this.id}`;\n  }\n\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {string}\n   * @readonly\n   */\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? Util.cleanContent(this.content, this) : null;\n  }\n\n  /**\n   * Creates a reaction collector.\n   * @param {CollectorFilter} filter The filter to apply\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID';\n   * const collector = message.createReactionCollector(filter, { time: 15000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createReactionCollector(filter) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new ReactionCollector(this, filter, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {CollectorFilter} filter The filter function to use\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID'\n   * message.awaitReactions(filter, { time: 15000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n  awaitReactions(filter) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(filter, options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors && options.errors.includes(reason)) reject(reactions);else resolve(reactions);\n      });\n    });\n  }\n\n  /**\n   * An array of cached versions of the message, including the current version\n   * Sorted from latest (first) to oldest (last)\n   * @type {Message[]}\n   * @readonly\n   */\n  get edits() {\n    const copy = this._edits.slice();\n    copy.unshift(this);\n    return copy;\n  }\n\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return this.author.id === this.client.user.id;\n  }\n\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return !this.deleted && (this.author.id === this.client.user.id || this.guild && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false));\n  }\n\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get pinnable() {\n    return this.type === 'DEFAULT' && (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false));\n  }\n\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get crosspostable() {\n    return this.channel.type === 'news' && !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) && this.type === 'DEFAULT' && this.channel.viewable && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.SEND_MESSAGES) && (this.author.id === this.client.user.id || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES));\n  }\n\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {Object} MessageEditOptions\n   * @property {string} [content] Content to be edited\n   * @property {MessageEmbed|Object} [embed] An embed to be added/edited\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   */\n\n  /**\n   * Edits the content of the message.\n   * @param {StringResolvable|APIMessage} [content] The new content for the message\n   * @param {MessageEditOptions|MessageEmbed} [options] The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n  edit(content, options) {\n    const {\n      data\n    } = content instanceof APIMessage ? content.resolveData() : APIMessage.create(this, content, options).resolveData();\n    return this.client.api.channels[this.channel.id].messages[this.id].patch({\n      data\n    }).then(d => {\n      const clone = this._clone();\n      clone._patch(d);\n      return clone;\n    });\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === 'news') {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n  async crosspost() {\n    await this.client.api.channels(this.channel.id).messages(this.id).crosspost.post();\n    return this;\n  }\n\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @param {Object} [options] Options for pinning\n   * @param {string} [options.reason] Reason for pinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message with a reason\n   * message.pin({ reason: 'important' })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  pin(options) {\n    return this.client.api.channels(this.channel.id).pins(this.id).put(options).then(() => this);\n  }\n\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @param {Object} [options] Options for unpinning\n   * @param {string} [options.reason] Reason for unpinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message with a reason\n   * message.unpin({ reason: 'no longer relevant' })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  unpin(options) {\n    return this.client.api.channels(this.channel.id).pins(this.id).delete(options).then(() => this);\n  }\n\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('🤔')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  react(emoji) {\n    emoji = this.client.emojis.resolveIdentifier(emoji);\n    if (!emoji) throw new TypeError('EMOJI_TYPE');\n    return this.client.api.channels(this.channel.id).messages(this.id).reactions(emoji, '@me').put().then(() => this.client.actions.MessageReactionAdd.handle({\n      user: this.client.user,\n      channel: this.channel,\n      message: this,\n      emoji: Util.parseEmoji(emoji)\n    }).reaction);\n  }\n\n  /**\n   * Deletes the message.\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout=0] How long to wait to delete the message in milliseconds\n   * @param {string} [options.reason] Reason for deleting this message, if it does not belong to the client user\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete({ timeout: 5000 })\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username} after 5 seconds`))\n   *   .catch(console.error);\n   */\n  delete() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof options !== 'object') return Promise.reject(new TypeError('INVALID_TYPE', 'options', 'object', true));\n    const {\n      timeout = 0,\n      reason\n    } = options;\n    if (timeout <= 0) {\n      return this.channel.messages.delete(this.id, reason).then(() => this);\n    } else {\n      return new Promise(resolve => {\n        this.client.setTimeout(() => {\n          resolve(this.delete({\n            reason\n          }));\n        }, timeout);\n      });\n    }\n  }\n\n  /**\n   * Replies to the message.\n   * @param {StringResolvable|APIMessage} [content=''] The content for the message\n   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Reply to a message\n   * message.reply('Hey, I\\'m a reply!')\n   *   .then(() => console.log(`Sent a reply to ${message.author.username}`))\n   *   .catch(console.error);\n   */\n  reply(content, options) {\n    return this.channel.send(content instanceof APIMessage ? content : APIMessage.transformOptions(content, options, {\n      reply: this.member || this.author\n    }));\n  }\n\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.channel.messages.fetch(this.id, true, force);\n  }\n\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n  fetchWebhook() {\n    if (!this.webhookID) return Promise.reject(new Error('WEBHOOK_MESSAGE'));\n    return this.client.fetchWebhook(this.webhookID);\n  }\n\n  /**\n   * Suppresses or unsuppresses embeds on a message\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n  suppressEmbeds() {\n    let suppress = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const flags = new MessageFlags(this.flags.bitfield);\n    if (suppress) {\n      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    } else {\n      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    }\n    return this.edit({\n      flags\n    });\n  }\n\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {Object} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n    let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;\n    if (equal && rawData) {\n      equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === new Date(rawData.timestamp).getTime() && this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n    }\n    return equal;\n  }\n\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n  toString() {\n    return this.content;\n  }\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelID',\n      author: 'authorID',\n      application: 'applicationID',\n      guild: 'guildID',\n      cleanContent: true,\n      member: false,\n      reactions: false\n    });\n  }\n}\nmodule.exports = Message;","map":{"version":3,"names":["APIMessage","require","Base","ClientApplication","MessageAttachment","Embed","Mentions","ReactionCollector","Error","TypeError","ReactionManager","Collection","MessageTypes","MessageFlags","Permissions","SnowflakeUtil","Util","Message","constructor","client","data","channel","deleted","_patch","id","type","system","content","author","users","add","webhook_id","pinned","Boolean","tts","nonce","embeds","map","e","attachments","attachment","set","url","filename","createdTimestamp","deconstruct","timestamp","editedTimestamp","Date","edited_timestamp","getTime","reactions","length","reaction","mentions","mention_roles","mention_everyone","mention_channels","webhookID","application","activity","partyID","party_id","_edits","member","guild","members","Object","assign","user","flags","freeze","reference","message_reference","channelID","channel_id","guildID","guild_id","messageID","message_id","partial","patch","clone","_clone","messageEditHistoryMaxSize","options","editsLimit","Infinity","unshift","pop","slice","roles","everyone","crosspostedChannels","createdAt","editedAt","cleanContent","createReactionCollector","filter","awaitReactions","Promise","resolve","reject","collector","once","reason","errors","includes","edits","copy","editable","deletable","permissionsFor","has","FLAGS","MANAGE_MESSAGES","pinnable","crosspostable","CROSSPOSTED","viewable","SEND_MESSAGES","edit","resolveData","create","api","channels","messages","then","d","crosspost","post","pin","pins","put","unpin","delete","react","emoji","emojis","resolveIdentifier","actions","MessageReactionAdd","handle","message","parseEmoji","timeout","setTimeout","reply","send","transformOptions","fetch","force","fetchWebhook","suppressEmbeds","suppress","bitfield","SUPPRESS_EMBEDS","remove","equals","rawData","embedUpdate","equal","toString","toJSON","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/Message.js"],"sourcesContent":["'use strict';\n\nconst APIMessage = require('./APIMessage');\nconst Base = require('./Base');\nconst ClientApplication = require('./ClientApplication');\nconst MessageAttachment = require('./MessageAttachment');\nconst Embed = require('./MessageEmbed');\nconst Mentions = require('./MessageMentions');\nconst ReactionCollector = require('./ReactionCollector');\nconst { Error, TypeError } = require('../errors');\nconst ReactionManager = require('../managers/ReactionManager');\nconst Collection = require('../util/Collection');\nconst { MessageTypes } = require('../util/Constants');\nconst MessageFlags = require('../util/MessageFlags');\nconst Permissions = require('../util/Permissions');\nconst SnowflakeUtil = require('../util/Snowflake');\nconst Util = require('../util/Util');\n\n/**\n * Represents a message on Discord.\n * @extends {Base}\n */\nclass Message extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the message\n   * @param {TextChannel|DMChannel|NewsChannel} channel The channel the message was sent in\n   */\n  constructor(client, data, channel) {\n    super(client);\n\n    /**\n     * The channel that the message was sent in\n     * @type {TextChannel|DMChannel|NewsChannel}\n     */\n    this.channel = channel;\n\n    /**\n     * Whether this message has been deleted\n     * @type {boolean}\n     */\n    this.deleted = false;\n\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    /**\n     * The ID of the message\n     * @type {Snowflake}\n     */\n    this.id = data.id;\n\n    if ('type' in data) {\n      /**\n       * The type of the message\n       * @type {?MessageType}\n       */\n      this.type = MessageTypes[data.type];\n\n      /**\n       * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)\n       * @type {?boolean}\n       */\n      this.system = data.type !== 0;\n    } else if (typeof this.type !== 'string') {\n      this.system = null;\n      this.type = null;\n    }\n\n    if ('content' in data) {\n      /**\n       * The content of the message\n       * @type {?string}\n       */\n      this.content = data.content;\n    } else if (typeof this.content !== 'string') {\n      this.content = null;\n    }\n\n    if ('author' in data) {\n      /**\n       * The author of the message\n       * @type {?User}\n       */\n      this.author = this.client.users.add(data.author, !data.webhook_id);\n    } else if (!this.author) {\n      this.author = null;\n    }\n\n    if ('pinned' in data) {\n      /**\n       * Whether or not this message is pinned\n       * @type {?boolean}\n       */\n      this.pinned = Boolean(data.pinned);\n    } else if (typeof this.pinned !== 'boolean') {\n      this.pinned = null;\n    }\n\n    if ('tts' in data) {\n      /**\n       * Whether or not the message was Text-To-Speech\n       * @type {?boolean}\n       */\n      this.tts = data.tts;\n    } else if (typeof this.tts !== 'boolean') {\n      this.tts = null;\n    }\n\n    /**\n     * A random number or string used for checking message delivery\n     * <warn>This is only received after the message was sent successfully, and\n     * lost if re-fetched</warn>\n     * @type {?string}\n     */\n    this.nonce = 'nonce' in data ? data.nonce : null;\n\n    /**\n     * A list of embeds in the message - e.g. YouTube Player\n     * @type {MessageEmbed[]}\n     */\n    this.embeds = (data.embeds || []).map(e => new Embed(e, true));\n\n    /**\n     * A collection of attachments in the message - e.g. Pictures - mapped by their ID\n     * @type {Collection<Snowflake, MessageAttachment>}\n     */\n    this.attachments = new Collection();\n    if (data.attachments) {\n      for (const attachment of data.attachments) {\n        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n      }\n    }\n\n    /**\n     * The timestamp the message was sent at\n     * @type {number}\n     */\n    this.createdTimestamp = SnowflakeUtil.deconstruct(this.id).timestamp;\n\n    /**\n     * The timestamp the message was last edited at (if applicable)\n     * @type {?number}\n     */\n    this.editedTimestamp = 'edited_timestamp' in data ? new Date(data.edited_timestamp).getTime() : null;\n\n    /**\n     * A manager of the reactions belonging to this message\n     * @type {ReactionManager}\n     */\n    this.reactions = new ReactionManager(this);\n    if (data.reactions && data.reactions.length > 0) {\n      for (const reaction of data.reactions) {\n        this.reactions.add(reaction);\n      }\n    }\n\n    /**\n     * All valid mentions that the message contains\n     * @type {MessageMentions}\n     */\n    this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels);\n\n    /**\n     * ID of the webhook that sent the message, if applicable\n     * @type {?Snowflake}\n     */\n    this.webhookID = data.webhook_id || null;\n\n    /**\n     * Supplemental application information for group activities\n     * @type {?ClientApplication}\n     */\n    this.application = data.application ? new ClientApplication(this.client, data.application) : null;\n\n    /**\n     * Group activity\n     * @type {?MessageActivity}\n     */\n    this.activity = data.activity\n      ? {\n          partyID: data.activity.party_id,\n          type: data.activity.type,\n        }\n      : null;\n\n    /**\n     * The previous versions of the message, sorted with the most recent first\n     * @type {Message[]}\n     * @private\n     */\n    this._edits = [];\n\n    if (this.member && data.member) {\n      this.member._patch(data.member);\n    } else if (data.member && this.guild && this.author) {\n      this.guild.members.add(Object.assign(data.member, { user: this.author }));\n    }\n\n    /**\n     * Flags that are applied to the message\n     * @type {Readonly<MessageFlags>}\n     */\n    this.flags = new MessageFlags(data.flags).freeze();\n\n    /**\n     * Reference data sent in a crossposted message.\n     * @typedef {Object} MessageReference\n     * @property {string} channelID ID of the channel the message was crossposted from\n     * @property {?string} guildID ID of the guild the message was crossposted from\n     * @property {?string} messageID ID of the message that was crossposted\n     */\n\n    /**\n     * Message reference data\n     * @type {?MessageReference}\n     */\n    this.reference = data.message_reference\n      ? {\n          channelID: data.message_reference.channel_id,\n          guildID: data.message_reference.guild_id,\n          messageID: data.message_reference.message_id,\n        }\n      : null;\n  }\n\n  /**\n   * Whether or not this message is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.content !== 'string' || !this.author;\n  }\n\n  /**\n   * Updates the message and returns the old message.\n   * @param {Object} data Raw Discord message update data\n   * @returns {Message}\n   * @private\n   */\n  patch(data) {\n    const clone = this._clone();\n    const { messageEditHistoryMaxSize } = this.client.options;\n    if (messageEditHistoryMaxSize !== 0) {\n      const editsLimit = messageEditHistoryMaxSize === -1 ? Infinity : messageEditHistoryMaxSize;\n      if (this._edits.unshift(clone) > editsLimit) this._edits.pop();\n    }\n\n    if ('edited_timestamp' in data) this.editedTimestamp = new Date(data.edited_timestamp).getTime();\n    if ('content' in data) this.content = data.content;\n    if ('pinned' in data) this.pinned = data.pinned;\n    if ('tts' in data) this.tts = data.tts;\n    if ('embeds' in data) this.embeds = data.embeds.map(e => new Embed(e, true));\n    else this.embeds = this.embeds.slice();\n\n    if ('attachments' in data) {\n      this.attachments = new Collection();\n      for (const attachment of data.attachments) {\n        this.attachments.set(attachment.id, new MessageAttachment(attachment.url, attachment.filename, attachment));\n      }\n    } else {\n      this.attachments = new Collection(this.attachments);\n    }\n\n    this.mentions = new Mentions(\n      this,\n      'mentions' in data ? data.mentions : this.mentions.users,\n      'mention_roles' in data ? data.mention_roles : this.mentions.roles,\n      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone,\n      'mention_channels' in data ? data.mention_channels : this.mentions.crosspostedChannels,\n    );\n\n    this.flags = new MessageFlags('flags' in data ? data.flags : 0).freeze();\n\n    return clone;\n  }\n\n  /**\n   * Represents the author of the message as a guild member.\n   * Only available if the message comes from a guild where the author is still a member\n   * @type {?GuildMember}\n   * @readonly\n   */\n  get member() {\n    return this.guild ? this.guild.member(this.author) || null : null;\n  }\n\n  /**\n   * The time the message was sent at\n   * @type {Date}\n   * @readonly\n   */\n  get createdAt() {\n    return new Date(this.createdTimestamp);\n  }\n\n  /**\n   * The time the message was last edited at (if applicable)\n   * @type {?Date}\n   * @readonly\n   */\n  get editedAt() {\n    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;\n  }\n\n  /**\n   * The guild the message was sent in (if in a guild channel)\n   * @type {?Guild}\n   * @readonly\n   */\n  get guild() {\n    return this.channel.guild || null;\n  }\n\n  /**\n   * The url to jump to this message\n   * @type {string}\n   * @readonly\n   */\n  get url() {\n    return `https://discord.com/channels/${this.guild ? this.guild.id : '@me'}/${this.channel.id}/${this.id}`;\n  }\n\n  /**\n   * The message contents with all mentions replaced by the equivalent text.\n   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.\n   * @type {string}\n   * @readonly\n   */\n  get cleanContent() {\n    // eslint-disable-next-line eqeqeq\n    return this.content != null ? Util.cleanContent(this.content, this) : null;\n  }\n\n  /**\n   * Creates a reaction collector.\n   * @param {CollectorFilter} filter The filter to apply\n   * @param {ReactionCollectorOptions} [options={}] Options to send to the collector\n   * @returns {ReactionCollector}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID';\n   * const collector = message.createReactionCollector(filter, { time: 15000 });\n   * collector.on('collect', r => console.log(`Collected ${r.emoji.name}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createReactionCollector(filter, options = {}) {\n    return new ReactionCollector(this, filter, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {ReactionCollectorOptions} AwaitReactionsOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createReactionCollector but in promise form.\n   * Resolves with a collection of reactions that pass the specified filter.\n   * @param {CollectorFilter} filter The filter function to use\n   * @param {AwaitReactionsOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<string, MessageReaction>>}\n   * @example\n   * // Create a reaction collector\n   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID'\n   * message.awaitReactions(filter, { time: 15000 })\n   *   .then(collected => console.log(`Collected ${collected.size} reactions`))\n   *   .catch(console.error);\n   */\n  awaitReactions(filter, options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createReactionCollector(filter, options);\n      collector.once('end', (reactions, reason) => {\n        if (options.errors && options.errors.includes(reason)) reject(reactions);\n        else resolve(reactions);\n      });\n    });\n  }\n\n  /**\n   * An array of cached versions of the message, including the current version\n   * Sorted from latest (first) to oldest (last)\n   * @type {Message[]}\n   * @readonly\n   */\n  get edits() {\n    const copy = this._edits.slice();\n    copy.unshift(this);\n    return copy;\n  }\n\n  /**\n   * Whether the message is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return this.author.id === this.client.user.id;\n  }\n\n  /**\n   * Whether the message is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return (\n      !this.deleted &&\n      (this.author.id === this.client.user.id ||\n        (this.guild && this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false)))\n    );\n  }\n\n  /**\n   * Whether the message is pinnable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get pinnable() {\n    return (\n      this.type === 'DEFAULT' &&\n      (!this.guild || this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES, false))\n    );\n  }\n\n  /**\n   * Whether the message is crosspostable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get crosspostable() {\n    return (\n      this.channel.type === 'news' &&\n      !this.flags.has(MessageFlags.FLAGS.CROSSPOSTED) &&\n      this.type === 'DEFAULT' &&\n      this.channel.viewable &&\n      this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.SEND_MESSAGES) &&\n      (this.author.id === this.client.user.id ||\n        this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES))\n    );\n  }\n\n  /**\n   * Options that can be passed into editMessage.\n   * @typedef {Object} MessageEditOptions\n   * @property {string} [content] Content to be edited\n   * @property {MessageEmbed|Object} [embed] An embed to be added/edited\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   */\n\n  /**\n   * Edits the content of the message.\n   * @param {StringResolvable|APIMessage} [content] The new content for the message\n   * @param {MessageEditOptions|MessageEmbed} [options] The options to provide\n   * @returns {Promise<Message>}\n   * @example\n   * // Update the content of a message\n   * message.edit('This is my new content!')\n   *   .then(msg => console.log(`Updated the content of a message to ${msg.content}`))\n   *   .catch(console.error);\n   */\n  edit(content, options) {\n    const { data } =\n      content instanceof APIMessage ? content.resolveData() : APIMessage.create(this, content, options).resolveData();\n    return this.client.api.channels[this.channel.id].messages[this.id].patch({ data }).then(d => {\n      const clone = this._clone();\n      clone._patch(d);\n      return clone;\n    });\n  }\n\n  /**\n   * Publishes a message in an announcement channel to all channels following it.\n   * @returns {Promise<Message>}\n   * @example\n   * // Crosspost a message\n   * if (message.channel.type === 'news') {\n   *   message.crosspost()\n   *     .then(() => console.log('Crossposted message'))\n   *     .catch(console.error);\n   * }\n   */\n  async crosspost() {\n    await this.client.api.channels(this.channel.id).messages(this.id).crosspost.post();\n    return this;\n  }\n\n  /**\n   * Pins this message to the channel's pinned messages.\n   * @param {Object} [options] Options for pinning\n   * @param {string} [options.reason] Reason for pinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Pin a message with a reason\n   * message.pin({ reason: 'important' })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  pin(options) {\n    return this.client.api\n      .channels(this.channel.id)\n      .pins(this.id)\n      .put(options)\n      .then(() => this);\n  }\n\n  /**\n   * Unpins this message from the channel's pinned messages.\n   * @param {Object} [options] Options for unpinning\n   * @param {string} [options.reason] Reason for unpinning\n   * @returns {Promise<Message>}\n   * @example\n   * // Unpin a message with a reason\n   * message.unpin({ reason: 'no longer relevant' })\n   *   .then(console.log)\n   *   .catch(console.error)\n   */\n  unpin(options) {\n    return this.client.api\n      .channels(this.channel.id)\n      .pins(this.id)\n      .delete(options)\n      .then(() => this);\n  }\n\n  /**\n   * Adds a reaction to the message.\n   * @param {EmojiIdentifierResolvable} emoji The emoji to react with\n   * @returns {Promise<MessageReaction>}\n   * @example\n   * // React to a message with a unicode emoji\n   * message.react('🤔')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // React to a message with a custom emoji\n   * message.react(message.guild.emojis.cache.get('123456789012345678'))\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  react(emoji) {\n    emoji = this.client.emojis.resolveIdentifier(emoji);\n    if (!emoji) throw new TypeError('EMOJI_TYPE');\n\n    return this.client.api\n      .channels(this.channel.id)\n      .messages(this.id)\n      .reactions(emoji, '@me')\n      .put()\n      .then(\n        () =>\n          this.client.actions.MessageReactionAdd.handle({\n            user: this.client.user,\n            channel: this.channel,\n            message: this,\n            emoji: Util.parseEmoji(emoji),\n          }).reaction,\n      );\n  }\n\n  /**\n   * Deletes the message.\n   * @param {Object} [options] Options\n   * @param {number} [options.timeout=0] How long to wait to delete the message in milliseconds\n   * @param {string} [options.reason] Reason for deleting this message, if it does not belong to the client user\n   * @returns {Promise<Message>}\n   * @example\n   * // Delete a message\n   * message.delete({ timeout: 5000 })\n   *   .then(msg => console.log(`Deleted message from ${msg.author.username} after 5 seconds`))\n   *   .catch(console.error);\n   */\n  delete(options = {}) {\n    if (typeof options !== 'object') return Promise.reject(new TypeError('INVALID_TYPE', 'options', 'object', true));\n    const { timeout = 0, reason } = options;\n    if (timeout <= 0) {\n      return this.channel.messages.delete(this.id, reason).then(() => this);\n    } else {\n      return new Promise(resolve => {\n        this.client.setTimeout(() => {\n          resolve(this.delete({ reason }));\n        }, timeout);\n      });\n    }\n  }\n\n  /**\n   * Replies to the message.\n   * @param {StringResolvable|APIMessage} [content=''] The content for the message\n   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Reply to a message\n   * message.reply('Hey, I\\'m a reply!')\n   *   .then(() => console.log(`Sent a reply to ${message.author.username}`))\n   *   .catch(console.error);\n   */\n  reply(content, options) {\n    return this.channel.send(\n      content instanceof APIMessage\n        ? content\n        : APIMessage.transformOptions(content, options, { reply: this.member || this.author }),\n    );\n  }\n\n  /**\n   * Fetch this message.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Message>}\n   */\n  fetch(force = false) {\n    return this.channel.messages.fetch(this.id, true, force);\n  }\n\n  /**\n   * Fetches the webhook used to create this message.\n   * @returns {Promise<?Webhook>}\n   */\n  fetchWebhook() {\n    if (!this.webhookID) return Promise.reject(new Error('WEBHOOK_MESSAGE'));\n    return this.client.fetchWebhook(this.webhookID);\n  }\n\n  /**\n   * Suppresses or unsuppresses embeds on a message\n   * @param {boolean} [suppress=true] If the embeds should be suppressed or not\n   * @returns {Promise<Message>}\n   */\n  suppressEmbeds(suppress = true) {\n    const flags = new MessageFlags(this.flags.bitfield);\n\n    if (suppress) {\n      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    } else {\n      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);\n    }\n\n    return this.edit({ flags });\n  }\n\n  /**\n   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages\n   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This\n   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.\n   * @param {Message} message The message to compare it to\n   * @param {Object} rawData Raw data passed through the WebSocket about this message\n   * @returns {boolean}\n   */\n  equals(message, rawData) {\n    if (!message) return false;\n    const embedUpdate = !message.author && !message.attachments;\n    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;\n\n    let equal =\n      this.id === message.id &&\n      this.author.id === message.author.id &&\n      this.content === message.content &&\n      this.tts === message.tts &&\n      this.nonce === message.nonce &&\n      this.embeds.length === message.embeds.length &&\n      this.attachments.length === message.attachments.length;\n\n    if (equal && rawData) {\n      equal =\n        this.mentions.everyone === message.mentions.everyone &&\n        this.createdTimestamp === new Date(rawData.timestamp).getTime() &&\n        this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();\n    }\n\n    return equal;\n  }\n\n  /**\n   * When concatenated with a string, this automatically concatenates the message's content instead of the object.\n   * @returns {string}\n   * @example\n   * // Logs: Message: This is a message!\n   * console.log(`Message: ${message}`);\n   */\n  toString() {\n    return this.content;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      channel: 'channelID',\n      author: 'authorID',\n      application: 'applicationID',\n      guild: 'guildID',\n      cleanContent: true,\n      member: false,\n      reactions: false,\n    });\n  }\n}\n\nmodule.exports = Message;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}