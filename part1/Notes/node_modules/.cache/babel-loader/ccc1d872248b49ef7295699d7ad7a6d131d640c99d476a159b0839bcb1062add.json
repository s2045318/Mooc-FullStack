{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst GuildMember = require('../structures/GuildMember');\nconst Message = require('../structures/Message');\nconst User = require('../structures/User');\n\n/**\n * Manages API methods for users and stores their cache.\n * @extends {BaseManager}\n */\nclass UserManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, User);\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name UserManager#cache\n   */\n\n  /**\n   * Data that resolves to give a User object. This can be:\n   * * A User object\n   * * A Snowflake\n   * * A Message object (resolves to the message author)\n   * * A GuildMember object\n   * @typedef {User|Snowflake|Message|GuildMember} UserResolvable\n   */\n\n  /**\n   * Resolves a UserResolvable to a User object.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?User}\n   */\n  resolve(user) {\n    if (user instanceof GuildMember) return user.user;\n    if (user instanceof Message) return user.author;\n    return super.resolve(user);\n  }\n\n  /**\n   * Resolves a UserResolvable to a user ID string.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveID(user) {\n    if (user instanceof GuildMember) return user.user.id;\n    if (user instanceof Message) return user.author.id;\n    return super.resolveID(user);\n  }\n\n  /**\n   * Obtains a user from Discord, or the user cache if it's already available.\n   * @param {Snowflake} id ID of the user\n   * @param {boolean} [cache=true] Whether to cache the new user object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<User>}\n   */\n  async fetch(id) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n    const data = await this.client.api.users(id).get();\n    return this.add(data, cache);\n  }\n}\nmodule.exports = UserManager;","map":{"version":3,"names":["BaseManager","require","GuildMember","Message","User","UserManager","constructor","client","iterable","resolve","user","author","resolveID","id","fetch","cache","force","existing","get","partial","data","api","users","add","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/managers/UserManager.js"],"sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst GuildMember = require('../structures/GuildMember');\nconst Message = require('../structures/Message');\nconst User = require('../structures/User');\n\n/**\n * Manages API methods for users and stores their cache.\n * @extends {BaseManager}\n */\nclass UserManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, User);\n  }\n\n  /**\n   * The cache of this manager\n   * @type {Collection<Snowflake, User>}\n   * @name UserManager#cache\n   */\n\n  /**\n   * Data that resolves to give a User object. This can be:\n   * * A User object\n   * * A Snowflake\n   * * A Message object (resolves to the message author)\n   * * A GuildMember object\n   * @typedef {User|Snowflake|Message|GuildMember} UserResolvable\n   */\n\n  /**\n   * Resolves a UserResolvable to a User object.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?User}\n   */\n  resolve(user) {\n    if (user instanceof GuildMember) return user.user;\n    if (user instanceof Message) return user.author;\n    return super.resolve(user);\n  }\n\n  /**\n   * Resolves a UserResolvable to a user ID string.\n   * @param {UserResolvable} user The UserResolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveID(user) {\n    if (user instanceof GuildMember) return user.user.id;\n    if (user instanceof Message) return user.author.id;\n    return super.resolveID(user);\n  }\n\n  /**\n   * Obtains a user from Discord, or the user cache if it's already available.\n   * @param {Snowflake} id ID of the user\n   * @param {boolean} [cache=true] Whether to cache the new user object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<User>}\n   */\n  async fetch(id, cache = true, force = false) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.users(id).get();\n    return this.add(data, cache);\n  }\n}\n\nmodule.exports = UserManager;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC5C,MAAMC,WAAW,GAAGD,OAAO,CAAC,2BAA2B,CAAC;AACxD,MAAME,OAAO,GAAGF,OAAO,CAAC,uBAAuB,CAAC;AAChD,MAAMG,IAAI,GAAGH,OAAO,CAAC,oBAAoB,CAAC;;AAE1C;AACA;AACA;AACA;AACA,MAAMI,WAAW,SAASL,WAAW,CAAC;EACpCM,WAAW,CAACC,MAAM,EAAEC,QAAQ,EAAE;IAC5B,KAAK,CAACD,MAAM,EAAEC,QAAQ,EAAEJ,IAAI,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;EACEK,OAAO,CAACC,IAAI,EAAE;IACZ,IAAIA,IAAI,YAAYR,WAAW,EAAE,OAAOQ,IAAI,CAACA,IAAI;IACjD,IAAIA,IAAI,YAAYP,OAAO,EAAE,OAAOO,IAAI,CAACC,MAAM;IAC/C,OAAO,KAAK,CAACF,OAAO,CAACC,IAAI,CAAC;EAC5B;;EAEA;AACF;AACA;AACA;AACA;EACEE,SAAS,CAACF,IAAI,EAAE;IACd,IAAIA,IAAI,YAAYR,WAAW,EAAE,OAAOQ,IAAI,CAACA,IAAI,CAACG,EAAE;IACpD,IAAIH,IAAI,YAAYP,OAAO,EAAE,OAAOO,IAAI,CAACC,MAAM,CAACE,EAAE;IAClD,OAAO,KAAK,CAACD,SAAS,CAACF,IAAI,CAAC;EAC9B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMI,KAAK,CAACD,EAAE,EAA+B;IAAA,IAA7BE,KAAK,uEAAG,IAAI;IAAA,IAAEC,KAAK,uEAAG,KAAK;IACzC,IAAI,CAACA,KAAK,EAAE;MACV,MAAMC,QAAQ,GAAG,IAAI,CAACF,KAAK,CAACG,GAAG,CAACL,EAAE,CAAC;MACnC,IAAII,QAAQ,IAAI,CAACA,QAAQ,CAACE,OAAO,EAAE,OAAOF,QAAQ;IACpD;IAEA,MAAMG,IAAI,GAAG,MAAM,IAAI,CAACb,MAAM,CAACc,GAAG,CAACC,KAAK,CAACT,EAAE,CAAC,CAACK,GAAG,EAAE;IAClD,OAAO,IAAI,CAACK,GAAG,CAACH,IAAI,EAAEL,KAAK,CAAC;EAC9B;AACF;AAEAS,MAAM,CAACC,OAAO,GAAGpB,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}