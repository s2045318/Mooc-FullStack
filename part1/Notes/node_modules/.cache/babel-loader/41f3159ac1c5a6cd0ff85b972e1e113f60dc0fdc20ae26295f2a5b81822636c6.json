{"ast":null,"code":"'use strict';\n\nconst {\n  parse\n} = require('path');\nconst fetch = require('node-fetch');\nconst {\n  Colors,\n  DefaultOptions,\n  Endpoints\n} = require('./Constants');\nconst {\n  Error: DiscordError,\n  RangeError,\n  TypeError\n} = require('../errors');\nconst has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);\nconst isObject = d => typeof d === 'object' && d !== null;\n\n/**\n * Contains various general-purpose utility methods. These functions are also available on the base `Discord` object.\n */\nclass Util {\n  constructor() {\n    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);\n  }\n\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n  static flatten(obj) {\n    for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      props[_key - 1] = arguments[_key];\n    }\n    if (!isObject(obj)) return obj;\n    const objProps = Object.keys(obj).filter(k => !k.startsWith('_')).map(k => ({\n      [k]: true\n    }));\n    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n    const out = {};\n    for (let [prop, newProp] of Object.entries(props)) {\n      if (!newProp) continue;\n      newProp = newProp === true ? prop : newProp;\n      const element = obj[prop];\n      const elemIsObj = isObject(element);\n      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null;\n\n      // If it's a Collection, make the array of keys\n      if (element instanceof require('./Collection')) out[newProp] = Array.from(element.keys());\n      // If the valueOf is a Collection, use its array of keys\n      else if (valueOf instanceof require('./Collection')) out[newProp] = Array.from(valueOf.keys());\n      // If it's an array, flatten each element\n      else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e));\n      // If it's an object with a primitive `valueOf`, use that value\n      else if (typeof valueOf !== 'object') out[newProp] = valueOf;\n      // If it's a primitive\n      else if (!elemIsObj) out[newProp] = element;\n    }\n    return out;\n  }\n\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {StringResolvable} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behavior of the split\n   * @returns {string[]}\n   */\n  static splitMessage(text) {\n    let {\n      maxLength = 2000,\n      char = '\\n',\n      prepend = '',\n      append = ''\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    text = Util.resolveString(text);\n    if (text.length <= maxLength) return [text];\n    const splitText = text.split(char);\n    if (splitText.some(chunk => chunk.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');\n    const messages = [];\n    let msg = '';\n    for (const chunk of splitText) {\n      if (msg && (msg + char + chunk + append).length > maxLength) {\n        messages.push(msg + append);\n        msg = prepend;\n      }\n      msg += (msg && msg !== prepend ? char : '') + chunk;\n    }\n    return messages.concat(msg).filter(m => m);\n  }\n\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {Object} [options={}] What types of markdown to escape\n   * @param {boolean} [options.codeBlock=true] Whether to escape code blocks or not\n   * @param {boolean} [options.inlineCode=true] Whether to escape inline code or not\n   * @param {boolean} [options.bold=true] Whether to escape bolds or not\n   * @param {boolean} [options.italic=true] Whether to escape italics or not\n   * @param {boolean} [options.underline=true] Whether to escape underlines or not\n   * @param {boolean} [options.strikethrough=true] Whether to escape strikethroughs or not\n   * @param {boolean} [options.spoiler=true] Whether to escape spoilers or not\n   * @param {boolean} [options.codeBlockContent=true] Whether to escape text inside code blocks or not\n   * @param {boolean} [options.inlineCodeContent=true] Whether to escape text inside inline code or not\n   * @returns {string}\n   */\n  static escapeMarkdown(text) {\n    let {\n      codeBlock = true,\n      inlineCode = true,\n      bold = true,\n      italic = true,\n      underline = true,\n      strikethrough = true,\n      spoiler = true,\n      codeBlockContent = true,\n      inlineCodeContent = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!codeBlockContent) {\n      return text.split('```').map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          inlineCode,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler,\n          inlineCodeContent\n        });\n      }).join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n    }\n    if (!inlineCodeContent) {\n      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {\n        if (index % 2 && index !== array.length - 1) return subString;\n        return Util.escapeMarkdown(subString, {\n          codeBlock,\n          bold,\n          italic,\n          underline,\n          strikethrough,\n          spoiler\n        });\n      }).join(inlineCode ? '\\\\`' : '`');\n    }\n    if (inlineCode) text = Util.escapeInlineCode(text);\n    if (codeBlock) text = Util.escapeCodeBlock(text);\n    if (italic) text = Util.escapeItalic(text);\n    if (bold) text = Util.escapeBold(text);\n    if (underline) text = Util.escapeUnderline(text);\n    if (strikethrough) text = Util.escapeStrikethrough(text);\n    if (spoiler) text = Util.escapeSpoiler(text);\n    return text;\n  }\n\n  /**\n   * Escapes code block markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeCodeBlock(text) {\n    return text.replace(/```/g, '\\\\`\\\\`\\\\`');\n  }\n\n  /**\n   * Escapes inline code markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeInlineCode(text) {\n    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n  }\n\n  /**\n   * Escapes italic markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeItalic(text) {\n    let i = 0;\n    text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n      if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n      return `\\\\*${match}`;\n    });\n    i = 0;\n    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n      if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n      return `\\\\_${match}`;\n    });\n  }\n\n  /**\n   * Escapes bold markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeBold(text) {\n    let i = 0;\n    return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n      return '\\\\*\\\\*';\n    });\n  }\n\n  /**\n   * Escapes underline markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeUnderline(text) {\n    let i = 0;\n    return text.replace(/__(_)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n      return '\\\\_\\\\_';\n    });\n  }\n\n  /**\n   * Escapes strikethrough markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeStrikethrough(text) {\n    return text.replace(/~~/g, '\\\\~\\\\~');\n  }\n\n  /**\n   * Escapes spoiler markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeSpoiler(text) {\n    return text.replace(/\\|\\|/g, '\\\\|\\\\|');\n  }\n\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {number} [guildsPerShard=1000] Number of guilds per shard\n   * @returns {Promise<number>} The recommended number of shards\n   */\n  static fetchRecommendedShards(token) {\n    let guildsPerShard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n    if (!token) throw new DiscordError('TOKEN_MISSING');\n    return fetch(`${DefaultOptions.http.api}/v${DefaultOptions.http.version}${Endpoints.botGateway}`, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}`\n      }\n    }).then(res => {\n      if (res.ok) return res.json();\n      if (res.status === 401) throw new DiscordError('TOKEN_INVALID');\n      throw res;\n    }).then(data => data.shards * (1000 / guildsPerShard));\n  }\n\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no ID)\n   * * A URL-encoded UTF-8 emoji (no ID)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {Object} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return {\n      animated: false,\n      name: text,\n      id: null\n    };\n    const m = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n    if (!m) return null;\n    return {\n      animated: Boolean(m[1]),\n      name: m[2],\n      id: m[3] || null\n    };\n  }\n\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n  static mergeDefault(def, given) {\n    if (!given) return def;\n    for (const key in def) {\n      if (!has(given, key) || given[key] === undefined) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = Util.mergeDefault(def[key], given[key]);\n      }\n    }\n    return given;\n  }\n\n  /**\n   * Converts an ArrayBuffer or string to a Buffer.\n   * @param {ArrayBuffer|string} ab ArrayBuffer to convert\n   * @returns {Buffer}\n   * @private\n   */\n  static convertToBuffer(ab) {\n    if (typeof ab === 'string') ab = Util.str2ab(ab);\n    return Buffer.from(ab);\n  }\n\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param {string} str String to convert\n   * @returns {ArrayBuffer}\n   * @private\n   */\n  static str2ab(str) {\n    const buffer = new ArrayBuffer(str.length * 2);\n    const view = new Uint16Array(buffer);\n    for (var i = 0, strLen = str.length; i < strLen; i++) view[i] = str.charCodeAt(i);\n    return buffer;\n  }\n\n  /**\n   * Makes an Error from a plain info object.\n   * @param {Object} obj Error info\n   * @param {string} obj.name Error type\n   * @param {string} obj.message Message for the error\n   * @param {string} obj.stack Stack for the error\n   * @returns {Error}\n   * @private\n   */\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {Object}\n   * @private\n   */\n  static makePlainError(err) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack\n    };\n  }\n\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n  static moveElementInArray(array, element, newIndex) {\n    let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n    return array.indexOf(element);\n  }\n\n  /**\n   * Data that can be resolved to give a string. This can be:\n   * * A string\n   * * An array (joined with a new line delimiter to give a string)\n   * * Any value\n   * @typedef {string|Array|*} StringResolvable\n   */\n\n  /**\n   * Resolves a StringResolvable to a string.\n   * @param {StringResolvable} data The string resolvable to resolve\n   * @returns {string}\n   */\n  static resolveString(data) {\n    if (typeof data === 'string') return data;\n    if (Array.isArray(data)) return data.join('\\n');\n    return String(data);\n  }\n\n  /**\n   * Can be a number, hex string, an RGB array like:\n   * ```js\n   * [255, 0, 255] // purple\n   * ```\n   * or one of the following strings:\n   * - `DEFAULT`\n   * - `WHITE`\n   * - `AQUA`\n   * - `GREEN`\n   * - `BLUE`\n   * - `YELLOW`\n   * - `PURPLE`\n   * - `LUMINOUS_VIVID_PINK`\n   * - `GOLD`\n   * - `ORANGE`\n   * - `RED`\n   * - `GREY`\n   * - `DARKER_GREY`\n   * - `NAVY`\n   * - `DARK_AQUA`\n   * - `DARK_GREEN`\n   * - `DARK_BLUE`\n   * - `DARK_PURPLE`\n   * - `DARK_VIVID_PINK`\n   * - `DARK_GOLD`\n   * - `DARK_ORANGE`\n   * - `DARK_RED`\n   * - `DARK_GREY`\n   * - `LIGHT_GREY`\n   * - `DARK_NAVY`\n   * - `BLURPLE`\n   * - `GREYPLE`\n   * - `DARK_BUT_NOT_BLACK`\n   * - `NOT_QUITE_BLACK`\n   * - `RANDOM`\n   * @typedef {string|number|number[]} ColorResolvable\n   */\n\n  /**\n   * Resolves a ColorResolvable into a color number.\n   * @param {ColorResolvable} color Color to resolve\n   * @returns {number} A color\n   */\n  static resolveColor(color) {\n    if (typeof color === 'string') {\n      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n      if (color === 'DEFAULT') return 0;\n      color = Colors[color] || parseInt(color.replace('#', ''), 16);\n    } else if (Array.isArray(color)) {\n      color = (color[0] << 16) + (color[1] << 8) + color[2];\n    }\n    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');else if (color && isNaN(color)) throw new TypeError('COLOR_CONVERT');\n    return color;\n  }\n\n  /**\n   * Sorts by Discord's position and ID.\n   * @param  {Collection} collection Collection of objects to sort\n   * @returns {Collection}\n   */\n  static discordSort(collection) {\n    return collection.sorted((a, b) => a.rawPosition - b.rawPosition || parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) || parseInt(b.id.slice(10)) - parseInt(a.id.slice(10)));\n  }\n\n  /**\n   * Sets the position of a Channel or Role.\n   * @param {Channel|Role} item Object to set the position of\n   * @param {number} position New position for the object\n   * @param {boolean} relative Whether `position` is relative to its current position\n   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n   * @param {APIRouter} route Route to call PATCH on\n   * @param {string} [reason] Reason for the change\n   * @returns {Promise<Object[]>} Updated item list, with `id` and `position` properties\n   * @private\n   */\n  static setPosition(item, position, relative, sorted, route, reason) {\n    let updatedItems = sorted.array();\n    Util.moveElementInArray(updatedItems, item, position, relative);\n    updatedItems = updatedItems.map((r, i) => ({\n      id: r.id,\n      position: i\n    }));\n    return route.patch({\n      data: updatedItems,\n      reason\n    }).then(() => updatedItems);\n  }\n\n  /**\n   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n   * @param {string} path Path to get the basename of\n   * @param {string} [ext] File extension to remove\n   * @returns {string} Basename of the path\n   * @private\n   */\n  static basename(path, ext) {\n    let res = parse(path);\n    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n  }\n\n  /**\n   * Transforms a snowflake from a decimal string to a bit string.\n   * @param  {Snowflake} num Snowflake to be transformed\n   * @returns {string}\n   * @private\n   */\n  static idToBinary(num) {\n    let bin = '';\n    let high = parseInt(num.slice(0, -10)) || 0;\n    let low = parseInt(num.slice(-10));\n    while (low > 0 || high > 0) {\n      bin = String(low & 1) + bin;\n      low = Math.floor(low / 2);\n      if (high > 0) {\n        low += 5000000000 * (high % 2);\n        high = Math.floor(high / 2);\n      }\n    }\n    return bin;\n  }\n\n  /**\n   * Transforms a snowflake from a bit string to a decimal string.\n   * @param  {string} num Bit string to be transformed\n   * @returns {Snowflake}\n   * @private\n   */\n  static binaryToID(num) {\n    let dec = '';\n    while (num.length > 50) {\n      const high = parseInt(num.slice(0, -32), 2);\n      const low = parseInt((high % 10).toString(2) + num.slice(-32), 2);\n      dec = (low % 10).toString() + dec;\n      num = Math.floor(high / 10).toString(2) + Math.floor(low / 10).toString(2).padStart(32, '0');\n    }\n    num = parseInt(num, 2);\n    while (num > 0) {\n      dec = (num % 10).toString() + dec;\n      num = Math.floor(num / 10);\n    }\n    return dec;\n  }\n\n  /**\n   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n   * @param {string} str The string to sanitize\n   * @returns {string}\n   */\n  static removeMentions(str) {\n    return str.replace(/@/g, '@\\u200b');\n  }\n\n  /**\n   * The content to have all mentions replaced by the equivalent text.\n   * @param {string} str The string to be converted\n   * @param {Message} message The message object to reference\n   * @returns {string}\n   */\n  static cleanContent(str, message) {\n    str = str.replace(/<@!?[0-9]+>/g, input => {\n      const id = input.replace(/<|!|>|@/g, '');\n      if (message.channel.type === 'dm') {\n        const user = message.client.users.cache.get(id);\n        return user ? Util.removeMentions(`@${user.username}`) : input;\n      }\n      const member = message.channel.guild.members.cache.get(id);\n      if (member) {\n        return Util.removeMentions(`@${member.displayName}`);\n      } else {\n        const user = message.client.users.cache.get(id);\n        return user ? Util.removeMentions(`@${user.username}`) : input;\n      }\n    }).replace(/<#[0-9]+>/g, input => {\n      const channel = message.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n      return channel ? `#${channel.name}` : input;\n    }).replace(/<@&[0-9]+>/g, input => {\n      if (message.channel.type === 'dm') return input;\n      const role = message.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n      return role ? `@${role.name}` : input;\n    });\n    if (message.client.options.disableMentions === 'everyone') {\n      str = str.replace(/@([^<>@ ]*)/gmsu, (match, target) => {\n        if (target.match(/^[&!]?\\d+$/)) {\n          return `@${target}`;\n        } else {\n          return `@\\u200b${target}`;\n        }\n      });\n    }\n    if (message.client.options.disableMentions === 'all') {\n      return Util.removeMentions(str);\n    } else {\n      return str;\n    }\n  }\n\n  /**\n   * The content to put in a codeblock with all codeblock fences replaced by the equivalent backticks.\n   * @param {string} text The string to be converted\n   * @returns {string}\n   */\n  static cleanCodeBlockContent(text) {\n    return text.replace(/```/g, '`\\u200b``');\n  }\n\n  /**\n   * Creates a Promise that resolves after a specified duration.\n   * @param {number} ms How long to wait before resolving (in milliseconds)\n   * @returns {Promise<void>}\n   * @private\n   */\n  static delayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n}\nmodule.exports = Util;","map":{"version":3,"names":["parse","require","fetch","Colors","DefaultOptions","Endpoints","Error","DiscordError","RangeError","TypeError","has","o","k","Object","prototype","hasOwnProperty","call","isObject","d","Util","constructor","name","flatten","obj","props","objProps","keys","filter","startsWith","map","length","assign","out","prop","newProp","entries","element","elemIsObj","valueOf","Array","from","isArray","e","splitMessage","text","maxLength","char","prepend","append","resolveString","splitText","split","some","chunk","messages","msg","push","concat","m","escapeMarkdown","codeBlock","inlineCode","bold","italic","underline","strikethrough","spoiler","codeBlockContent","inlineCodeContent","subString","index","array","join","escapeInlineCode","escapeCodeBlock","escapeItalic","escapeBold","escapeUnderline","escapeStrikethrough","escapeSpoiler","replace","i","_","match","fetchRecommendedShards","token","guildsPerShard","http","api","version","botGateway","method","headers","Authorization","then","res","ok","json","status","data","shards","parseEmoji","includes","decodeURIComponent","animated","id","Boolean","cloneObject","create","mergeDefault","def","given","key","undefined","convertToBuffer","ab","str2ab","Buffer","str","buffer","ArrayBuffer","view","Uint16Array","strLen","charCodeAt","makeError","err","message","stack","makePlainError","moveElementInArray","newIndex","offset","indexOf","removedElement","splice","String","resolveColor","color","Math","floor","random","parseInt","isNaN","discordSort","collection","sorted","a","b","rawPosition","slice","setPosition","item","position","relative","route","reason","updatedItems","r","patch","basename","path","ext","base","idToBinary","num","bin","high","low","binaryToID","dec","toString","padStart","removeMentions","cleanContent","input","channel","type","user","client","users","cache","get","username","member","guild","members","displayName","channels","role","roles","options","disableMentions","target","cleanCodeBlockContent","delayFor","ms","Promise","resolve","setTimeout","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/util/Util.js"],"sourcesContent":["'use strict';\n\nconst { parse } = require('path');\nconst fetch = require('node-fetch');\nconst { Colors, DefaultOptions, Endpoints } = require('./Constants');\nconst { Error: DiscordError, RangeError, TypeError } = require('../errors');\nconst has = (o, k) => Object.prototype.hasOwnProperty.call(o, k);\nconst isObject = d => typeof d === 'object' && d !== null;\n\n/**\n * Contains various general-purpose utility methods. These functions are also available on the base `Discord` object.\n */\nclass Util {\n  constructor() {\n    throw new Error(`The ${this.constructor.name} class may not be instantiated.`);\n  }\n\n  /**\n   * Flatten an object. Any properties that are collections will get converted to an array of keys.\n   * @param {Object} obj The object to flatten.\n   * @param {...Object<string, boolean|string>} [props] Specific properties to include/exclude.\n   * @returns {Object}\n   */\n  static flatten(obj, ...props) {\n    if (!isObject(obj)) return obj;\n\n    const objProps = Object.keys(obj)\n      .filter(k => !k.startsWith('_'))\n      .map(k => ({ [k]: true }));\n\n    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);\n\n    const out = {};\n\n    for (let [prop, newProp] of Object.entries(props)) {\n      if (!newProp) continue;\n      newProp = newProp === true ? prop : newProp;\n\n      const element = obj[prop];\n      const elemIsObj = isObject(element);\n      const valueOf = elemIsObj && typeof element.valueOf === 'function' ? element.valueOf() : null;\n\n      // If it's a Collection, make the array of keys\n      if (element instanceof require('./Collection')) out[newProp] = Array.from(element.keys());\n      // If the valueOf is a Collection, use its array of keys\n      else if (valueOf instanceof require('./Collection')) out[newProp] = Array.from(valueOf.keys());\n      // If it's an array, flatten each element\n      else if (Array.isArray(element)) out[newProp] = element.map(e => Util.flatten(e));\n      // If it's an object with a primitive `valueOf`, use that value\n      else if (typeof valueOf !== 'object') out[newProp] = valueOf;\n      // If it's a primitive\n      else if (!elemIsObj) out[newProp] = element;\n    }\n\n    return out;\n  }\n\n  /**\n   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.\n   * @param {StringResolvable} text Content to split\n   * @param {SplitOptions} [options] Options controlling the behavior of the split\n   * @returns {string[]}\n   */\n  static splitMessage(text, { maxLength = 2000, char = '\\n', prepend = '', append = '' } = {}) {\n    text = Util.resolveString(text);\n    if (text.length <= maxLength) return [text];\n    const splitText = text.split(char);\n    if (splitText.some(chunk => chunk.length > maxLength)) throw new RangeError('SPLIT_MAX_LEN');\n    const messages = [];\n    let msg = '';\n    for (const chunk of splitText) {\n      if (msg && (msg + char + chunk + append).length > maxLength) {\n        messages.push(msg + append);\n        msg = prepend;\n      }\n      msg += (msg && msg !== prepend ? char : '') + chunk;\n    }\n    return messages.concat(msg).filter(m => m);\n  }\n\n  /**\n   * Escapes any Discord-flavour markdown in a string.\n   * @param {string} text Content to escape\n   * @param {Object} [options={}] What types of markdown to escape\n   * @param {boolean} [options.codeBlock=true] Whether to escape code blocks or not\n   * @param {boolean} [options.inlineCode=true] Whether to escape inline code or not\n   * @param {boolean} [options.bold=true] Whether to escape bolds or not\n   * @param {boolean} [options.italic=true] Whether to escape italics or not\n   * @param {boolean} [options.underline=true] Whether to escape underlines or not\n   * @param {boolean} [options.strikethrough=true] Whether to escape strikethroughs or not\n   * @param {boolean} [options.spoiler=true] Whether to escape spoilers or not\n   * @param {boolean} [options.codeBlockContent=true] Whether to escape text inside code blocks or not\n   * @param {boolean} [options.inlineCodeContent=true] Whether to escape text inside inline code or not\n   * @returns {string}\n   */\n  static escapeMarkdown(\n    text,\n    {\n      codeBlock = true,\n      inlineCode = true,\n      bold = true,\n      italic = true,\n      underline = true,\n      strikethrough = true,\n      spoiler = true,\n      codeBlockContent = true,\n      inlineCodeContent = true,\n    } = {},\n  ) {\n    if (!codeBlockContent) {\n      return text\n        .split('```')\n        .map((subString, index, array) => {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            inlineCode,\n            bold,\n            italic,\n            underline,\n            strikethrough,\n            spoiler,\n            inlineCodeContent,\n          });\n        })\n        .join(codeBlock ? '\\\\`\\\\`\\\\`' : '```');\n    }\n    if (!inlineCodeContent) {\n      return text\n        .split(/(?<=^|[^`])`(?=[^`]|$)/g)\n        .map((subString, index, array) => {\n          if (index % 2 && index !== array.length - 1) return subString;\n          return Util.escapeMarkdown(subString, {\n            codeBlock,\n            bold,\n            italic,\n            underline,\n            strikethrough,\n            spoiler,\n          });\n        })\n        .join(inlineCode ? '\\\\`' : '`');\n    }\n    if (inlineCode) text = Util.escapeInlineCode(text);\n    if (codeBlock) text = Util.escapeCodeBlock(text);\n    if (italic) text = Util.escapeItalic(text);\n    if (bold) text = Util.escapeBold(text);\n    if (underline) text = Util.escapeUnderline(text);\n    if (strikethrough) text = Util.escapeStrikethrough(text);\n    if (spoiler) text = Util.escapeSpoiler(text);\n    return text;\n  }\n\n  /**\n   * Escapes code block markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeCodeBlock(text) {\n    return text.replace(/```/g, '\\\\`\\\\`\\\\`');\n  }\n\n  /**\n   * Escapes inline code markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeInlineCode(text) {\n    return text.replace(/(?<=^|[^`])`(?=[^`]|$)/g, '\\\\`');\n  }\n\n  /**\n   * Escapes italic markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeItalic(text) {\n    let i = 0;\n    text = text.replace(/(?<=^|[^*])\\*([^*]|\\*\\*|$)/g, (_, match) => {\n      if (match === '**') return ++i % 2 ? `\\\\*${match}` : `${match}\\\\*`;\n      return `\\\\*${match}`;\n    });\n    i = 0;\n    return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {\n      if (match === '__') return ++i % 2 ? `\\\\_${match}` : `${match}\\\\_`;\n      return `\\\\_${match}`;\n    });\n  }\n\n  /**\n   * Escapes bold markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeBold(text) {\n    let i = 0;\n    return text.replace(/\\*\\*(\\*)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\*\\\\*` : `\\\\*\\\\*${match}`;\n      return '\\\\*\\\\*';\n    });\n  }\n\n  /**\n   * Escapes underline markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeUnderline(text) {\n    let i = 0;\n    return text.replace(/__(_)?/g, (_, match) => {\n      if (match) return ++i % 2 ? `${match}\\\\_\\\\_` : `\\\\_\\\\_${match}`;\n      return '\\\\_\\\\_';\n    });\n  }\n\n  /**\n   * Escapes strikethrough markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeStrikethrough(text) {\n    return text.replace(/~~/g, '\\\\~\\\\~');\n  }\n\n  /**\n   * Escapes spoiler markdown in a string.\n   * @param {string} text Content to escape\n   * @returns {string}\n   */\n  static escapeSpoiler(text) {\n    return text.replace(/\\|\\|/g, '\\\\|\\\\|');\n  }\n\n  /**\n   * Gets the recommended shard count from Discord.\n   * @param {string} token Discord auth token\n   * @param {number} [guildsPerShard=1000] Number of guilds per shard\n   * @returns {Promise<number>} The recommended number of shards\n   */\n  static fetchRecommendedShards(token, guildsPerShard = 1000) {\n    if (!token) throw new DiscordError('TOKEN_MISSING');\n    return fetch(`${DefaultOptions.http.api}/v${DefaultOptions.http.version}${Endpoints.botGateway}`, {\n      method: 'GET',\n      headers: { Authorization: `Bot ${token.replace(/^Bot\\s*/i, '')}` },\n    })\n      .then(res => {\n        if (res.ok) return res.json();\n        if (res.status === 401) throw new DiscordError('TOKEN_INVALID');\n        throw res;\n      })\n      .then(data => data.shards * (1000 / guildsPerShard));\n  }\n\n  /**\n   * Parses emoji info out of a string. The string must be one of:\n   * * A UTF-8 emoji (no ID)\n   * * A URL-encoded UTF-8 emoji (no ID)\n   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)\n   * @param {string} text Emoji string to parse\n   * @returns {Object} Object with `animated`, `name`, and `id` properties\n   * @private\n   */\n  static parseEmoji(text) {\n    if (text.includes('%')) text = decodeURIComponent(text);\n    if (!text.includes(':')) return { animated: false, name: text, id: null };\n    const m = text.match(/<?(?:(a):)?(\\w{2,32}):(\\d{17,19})?>?/);\n    if (!m) return null;\n    return { animated: Boolean(m[1]), name: m[2], id: m[3] || null };\n  }\n\n  /**\n   * Shallow-copies an object with its class/prototype intact.\n   * @param {Object} obj Object to clone\n   * @returns {Object}\n   * @private\n   */\n  static cloneObject(obj) {\n    return Object.assign(Object.create(obj), obj);\n  }\n\n  /**\n   * Sets default properties on an object that aren't already specified.\n   * @param {Object} def Default properties\n   * @param {Object} given Object to assign defaults to\n   * @returns {Object}\n   * @private\n   */\n  static mergeDefault(def, given) {\n    if (!given) return def;\n    for (const key in def) {\n      if (!has(given, key) || given[key] === undefined) {\n        given[key] = def[key];\n      } else if (given[key] === Object(given[key])) {\n        given[key] = Util.mergeDefault(def[key], given[key]);\n      }\n    }\n\n    return given;\n  }\n\n  /**\n   * Converts an ArrayBuffer or string to a Buffer.\n   * @param {ArrayBuffer|string} ab ArrayBuffer to convert\n   * @returns {Buffer}\n   * @private\n   */\n  static convertToBuffer(ab) {\n    if (typeof ab === 'string') ab = Util.str2ab(ab);\n    return Buffer.from(ab);\n  }\n\n  /**\n   * Converts a string to an ArrayBuffer.\n   * @param {string} str String to convert\n   * @returns {ArrayBuffer}\n   * @private\n   */\n  static str2ab(str) {\n    const buffer = new ArrayBuffer(str.length * 2);\n    const view = new Uint16Array(buffer);\n    for (var i = 0, strLen = str.length; i < strLen; i++) view[i] = str.charCodeAt(i);\n    return buffer;\n  }\n\n  /**\n   * Makes an Error from a plain info object.\n   * @param {Object} obj Error info\n   * @param {string} obj.name Error type\n   * @param {string} obj.message Message for the error\n   * @param {string} obj.stack Stack for the error\n   * @returns {Error}\n   * @private\n   */\n  static makeError(obj) {\n    const err = new Error(obj.message);\n    err.name = obj.name;\n    err.stack = obj.stack;\n    return err;\n  }\n\n  /**\n   * Makes a plain error info object from an Error.\n   * @param {Error} err Error to get info from\n   * @returns {Object}\n   * @private\n   */\n  static makePlainError(err) {\n    return {\n      name: err.name,\n      message: err.message,\n      stack: err.stack,\n    };\n  }\n\n  /**\n   * Moves an element in an array *in place*.\n   * @param {Array<*>} array Array to modify\n   * @param {*} element Element to move\n   * @param {number} newIndex Index or offset to move the element to\n   * @param {boolean} [offset=false] Move the element by an offset amount rather than to a set index\n   * @returns {number}\n   * @private\n   */\n  static moveElementInArray(array, element, newIndex, offset = false) {\n    const index = array.indexOf(element);\n    newIndex = (offset ? index : 0) + newIndex;\n    if (newIndex > -1 && newIndex < array.length) {\n      const removedElement = array.splice(index, 1)[0];\n      array.splice(newIndex, 0, removedElement);\n    }\n    return array.indexOf(element);\n  }\n\n  /**\n   * Data that can be resolved to give a string. This can be:\n   * * A string\n   * * An array (joined with a new line delimiter to give a string)\n   * * Any value\n   * @typedef {string|Array|*} StringResolvable\n   */\n\n  /**\n   * Resolves a StringResolvable to a string.\n   * @param {StringResolvable} data The string resolvable to resolve\n   * @returns {string}\n   */\n  static resolveString(data) {\n    if (typeof data === 'string') return data;\n    if (Array.isArray(data)) return data.join('\\n');\n    return String(data);\n  }\n\n  /**\n   * Can be a number, hex string, an RGB array like:\n   * ```js\n   * [255, 0, 255] // purple\n   * ```\n   * or one of the following strings:\n   * - `DEFAULT`\n   * - `WHITE`\n   * - `AQUA`\n   * - `GREEN`\n   * - `BLUE`\n   * - `YELLOW`\n   * - `PURPLE`\n   * - `LUMINOUS_VIVID_PINK`\n   * - `GOLD`\n   * - `ORANGE`\n   * - `RED`\n   * - `GREY`\n   * - `DARKER_GREY`\n   * - `NAVY`\n   * - `DARK_AQUA`\n   * - `DARK_GREEN`\n   * - `DARK_BLUE`\n   * - `DARK_PURPLE`\n   * - `DARK_VIVID_PINK`\n   * - `DARK_GOLD`\n   * - `DARK_ORANGE`\n   * - `DARK_RED`\n   * - `DARK_GREY`\n   * - `LIGHT_GREY`\n   * - `DARK_NAVY`\n   * - `BLURPLE`\n   * - `GREYPLE`\n   * - `DARK_BUT_NOT_BLACK`\n   * - `NOT_QUITE_BLACK`\n   * - `RANDOM`\n   * @typedef {string|number|number[]} ColorResolvable\n   */\n\n  /**\n   * Resolves a ColorResolvable into a color number.\n   * @param {ColorResolvable} color Color to resolve\n   * @returns {number} A color\n   */\n  static resolveColor(color) {\n    if (typeof color === 'string') {\n      if (color === 'RANDOM') return Math.floor(Math.random() * (0xffffff + 1));\n      if (color === 'DEFAULT') return 0;\n      color = Colors[color] || parseInt(color.replace('#', ''), 16);\n    } else if (Array.isArray(color)) {\n      color = (color[0] << 16) + (color[1] << 8) + color[2];\n    }\n\n    if (color < 0 || color > 0xffffff) throw new RangeError('COLOR_RANGE');\n    else if (color && isNaN(color)) throw new TypeError('COLOR_CONVERT');\n\n    return color;\n  }\n\n  /**\n   * Sorts by Discord's position and ID.\n   * @param  {Collection} collection Collection of objects to sort\n   * @returns {Collection}\n   */\n  static discordSort(collection) {\n    return collection.sorted(\n      (a, b) =>\n        a.rawPosition - b.rawPosition ||\n        parseInt(b.id.slice(0, -10)) - parseInt(a.id.slice(0, -10)) ||\n        parseInt(b.id.slice(10)) - parseInt(a.id.slice(10)),\n    );\n  }\n\n  /**\n   * Sets the position of a Channel or Role.\n   * @param {Channel|Role} item Object to set the position of\n   * @param {number} position New position for the object\n   * @param {boolean} relative Whether `position` is relative to its current position\n   * @param {Collection<string, Channel|Role>} sorted A collection of the objects sorted properly\n   * @param {APIRouter} route Route to call PATCH on\n   * @param {string} [reason] Reason for the change\n   * @returns {Promise<Object[]>} Updated item list, with `id` and `position` properties\n   * @private\n   */\n  static setPosition(item, position, relative, sorted, route, reason) {\n    let updatedItems = sorted.array();\n    Util.moveElementInArray(updatedItems, item, position, relative);\n    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));\n    return route.patch({ data: updatedItems, reason }).then(() => updatedItems);\n  }\n\n  /**\n   * Alternative to Node's `path.basename`, removing query string after the extension if it exists.\n   * @param {string} path Path to get the basename of\n   * @param {string} [ext] File extension to remove\n   * @returns {string} Basename of the path\n   * @private\n   */\n  static basename(path, ext) {\n    let res = parse(path);\n    return ext && res.ext.startsWith(ext) ? res.name : res.base.split('?')[0];\n  }\n\n  /**\n   * Transforms a snowflake from a decimal string to a bit string.\n   * @param  {Snowflake} num Snowflake to be transformed\n   * @returns {string}\n   * @private\n   */\n  static idToBinary(num) {\n    let bin = '';\n    let high = parseInt(num.slice(0, -10)) || 0;\n    let low = parseInt(num.slice(-10));\n    while (low > 0 || high > 0) {\n      bin = String(low & 1) + bin;\n      low = Math.floor(low / 2);\n      if (high > 0) {\n        low += 5000000000 * (high % 2);\n        high = Math.floor(high / 2);\n      }\n    }\n    return bin;\n  }\n\n  /**\n   * Transforms a snowflake from a bit string to a decimal string.\n   * @param  {string} num Bit string to be transformed\n   * @returns {Snowflake}\n   * @private\n   */\n  static binaryToID(num) {\n    let dec = '';\n\n    while (num.length > 50) {\n      const high = parseInt(num.slice(0, -32), 2);\n      const low = parseInt((high % 10).toString(2) + num.slice(-32), 2);\n\n      dec = (low % 10).toString() + dec;\n      num =\n        Math.floor(high / 10).toString(2) +\n        Math.floor(low / 10)\n          .toString(2)\n          .padStart(32, '0');\n    }\n\n    num = parseInt(num, 2);\n    while (num > 0) {\n      dec = (num % 10).toString() + dec;\n      num = Math.floor(num / 10);\n    }\n\n    return dec;\n  }\n\n  /**\n   * Breaks user, role and everyone/here mentions by adding a zero width space after every @ character\n   * @param {string} str The string to sanitize\n   * @returns {string}\n   */\n  static removeMentions(str) {\n    return str.replace(/@/g, '@\\u200b');\n  }\n\n  /**\n   * The content to have all mentions replaced by the equivalent text.\n   * @param {string} str The string to be converted\n   * @param {Message} message The message object to reference\n   * @returns {string}\n   */\n  static cleanContent(str, message) {\n    str = str\n      .replace(/<@!?[0-9]+>/g, input => {\n        const id = input.replace(/<|!|>|@/g, '');\n        if (message.channel.type === 'dm') {\n          const user = message.client.users.cache.get(id);\n          return user ? Util.removeMentions(`@${user.username}`) : input;\n        }\n\n        const member = message.channel.guild.members.cache.get(id);\n        if (member) {\n          return Util.removeMentions(`@${member.displayName}`);\n        } else {\n          const user = message.client.users.cache.get(id);\n          return user ? Util.removeMentions(`@${user.username}`) : input;\n        }\n      })\n      .replace(/<#[0-9]+>/g, input => {\n        const channel = message.client.channels.cache.get(input.replace(/<|#|>/g, ''));\n        return channel ? `#${channel.name}` : input;\n      })\n      .replace(/<@&[0-9]+>/g, input => {\n        if (message.channel.type === 'dm') return input;\n        const role = message.guild.roles.cache.get(input.replace(/<|@|>|&/g, ''));\n        return role ? `@${role.name}` : input;\n      });\n    if (message.client.options.disableMentions === 'everyone') {\n      str = str.replace(/@([^<>@ ]*)/gmsu, (match, target) => {\n        if (target.match(/^[&!]?\\d+$/)) {\n          return `@${target}`;\n        } else {\n          return `@\\u200b${target}`;\n        }\n      });\n    }\n    if (message.client.options.disableMentions === 'all') {\n      return Util.removeMentions(str);\n    } else {\n      return str;\n    }\n  }\n\n  /**\n   * The content to put in a codeblock with all codeblock fences replaced by the equivalent backticks.\n   * @param {string} text The string to be converted\n   * @returns {string}\n   */\n  static cleanCodeBlockContent(text) {\n    return text.replace(/```/g, '`\\u200b``');\n  }\n\n  /**\n   * Creates a Promise that resolves after a specified duration.\n   * @param {number} ms How long to wait before resolving (in milliseconds)\n   * @returns {Promise<void>}\n   * @private\n   */\n  static delayFor(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n}\n\nmodule.exports = Util;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}