{"ast":null,"code":"'use strict';\n\nconst Channel = require('./Channel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst MessageManager = require('../managers/MessageManager');\n\n/**\n * Represents a direct message channel between two users.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\nclass DMChannel extends Channel {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the DM channel\n   */\n  constructor(client, data) {\n    super(client, data);\n    // Override the channel type so partials have a known type\n    this.type = 'dm';\n    /**\n     * A manager of the messages belonging to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n    this._typing = new Map();\n  }\n  _patch(data) {\n    super._patch(data);\n    if (data.recipients) {\n      /**\n       * The recipient on the other end of the DM\n       * @type {User}\n       */\n      this.recipient = this.client.users.add(data.recipients[0]);\n    }\n\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = data.last_message_id;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n  }\n\n  /**\n   * Whether this DMChannel is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.lastMessageID === 'undefined';\n  }\n\n  /**\n   * Fetch this DMChannel.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.recipient.createDM(force);\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the recipient's mention instead of the\n   * DMChannel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n  toString() {\n    return this.recipient.toString();\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  startTyping() {}\n  stopTyping() {}\n  get typing() {}\n  get typingCount() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  // Doesn't work on DM channels; bulkDelete() {}\n}\n\nTextBasedChannel.applyToClass(DMChannel, true, ['bulkDelete']);\nmodule.exports = DMChannel;","map":{"version":3,"names":["Channel","require","TextBasedChannel","MessageManager","DMChannel","constructor","client","data","type","messages","_typing","Map","_patch","recipients","recipient","users","add","lastMessageID","last_message_id","lastPinTimestamp","last_pin_timestamp","Date","getTime","partial","fetch","force","createDM","toString","lastMessage","lastPinAt","send","startTyping","stopTyping","typing","typingCount","createMessageCollector","awaitMessages","applyToClass","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/DMChannel.js"],"sourcesContent":["'use strict';\n\nconst Channel = require('./Channel');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst MessageManager = require('../managers/MessageManager');\n\n/**\n * Represents a direct message channel between two users.\n * @extends {Channel}\n * @implements {TextBasedChannel}\n */\nclass DMChannel extends Channel {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the DM channel\n   */\n  constructor(client, data) {\n    super(client, data);\n    // Override the channel type so partials have a known type\n    this.type = 'dm';\n    /**\n     * A manager of the messages belonging to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n    this._typing = new Map();\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    if (data.recipients) {\n      /**\n       * The recipient on the other end of the DM\n       * @type {User}\n       */\n      this.recipient = this.client.users.add(data.recipients[0]);\n    }\n\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = data.last_message_id;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;\n  }\n\n  /**\n   * Whether this DMChannel is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return typeof this.lastMessageID === 'undefined';\n  }\n\n  /**\n   * Fetch this DMChannel.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<DMChannel>}\n   */\n  fetch(force = false) {\n    return this.recipient.createDM(force);\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the recipient's mention instead of the\n   * DMChannel object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${channel}!`);\n   */\n  toString() {\n    return this.recipient.toString();\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  get lastMessage() {}\n  get lastPinAt() {}\n  send() {}\n  startTyping() {}\n  stopTyping() {}\n  get typing() {}\n  get typingCount() {}\n  createMessageCollector() {}\n  awaitMessages() {}\n  // Doesn't work on DM channels; bulkDelete() {}\n}\n\nTextBasedChannel.applyToClass(DMChannel, true, ['bulkDelete']);\n\nmodule.exports = DMChannel;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,WAAW,CAAC;AACpC,MAAMC,gBAAgB,GAAGD,OAAO,CAAC,+BAA+B,CAAC;AACjE,MAAME,cAAc,GAAGF,OAAO,CAAC,4BAA4B,CAAC;;AAE5D;AACA;AACA;AACA;AACA;AACA,MAAMG,SAAS,SAASJ,OAAO,CAAC;EAC9B;AACF;AACA;AACA;EACEK,WAAW,CAACC,MAAM,EAAEC,IAAI,EAAE;IACxB,KAAK,CAACD,MAAM,EAAEC,IAAI,CAAC;IACnB;IACA,IAAI,CAACC,IAAI,GAAG,IAAI;IAChB;AACJ;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAG,IAAIN,cAAc,CAAC,IAAI,CAAC;IACxC,IAAI,CAACO,OAAO,GAAG,IAAIC,GAAG,EAAE;EAC1B;EAEAC,MAAM,CAACL,IAAI,EAAE;IACX,KAAK,CAACK,MAAM,CAACL,IAAI,CAAC;IAElB,IAAIA,IAAI,CAACM,UAAU,EAAE;MACnB;AACN;AACA;AACA;MACM,IAAI,CAACC,SAAS,GAAG,IAAI,CAACR,MAAM,CAACS,KAAK,CAACC,GAAG,CAACT,IAAI,CAACM,UAAU,CAAC,CAAC,CAAC,CAAC;IAC5D;;IAEA;AACJ;AACA;AACA;IACI,IAAI,CAACI,aAAa,GAAGV,IAAI,CAACW,eAAe;;IAEzC;AACJ;AACA;AACA;IACI,IAAI,CAACC,gBAAgB,GAAGZ,IAAI,CAACa,kBAAkB,GAAG,IAAIC,IAAI,CAACd,IAAI,CAACa,kBAAkB,CAAC,CAACE,OAAO,EAAE,GAAG,IAAI;EACtG;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIC,OAAO,GAAG;IACZ,OAAO,OAAO,IAAI,CAACN,aAAa,KAAK,WAAW;EAClD;;EAEA;AACF;AACA;AACA;AACA;EACEO,KAAK,GAAgB;IAAA,IAAfC,KAAK,uEAAG,KAAK;IACjB,OAAO,IAAI,CAACX,SAAS,CAACY,QAAQ,CAACD,KAAK,CAAC;EACvC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,QAAQ,GAAG;IACT,OAAO,IAAI,CAACb,SAAS,CAACa,QAAQ,EAAE;EAClC;;EAEA;EACA;EACA,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,SAAS,GAAG,CAAC;EACjBC,IAAI,GAAG,CAAC;EACRC,WAAW,GAAG,CAAC;EACfC,UAAU,GAAG,CAAC;EACd,IAAIC,MAAM,GAAG,CAAC;EACd,IAAIC,WAAW,GAAG,CAAC;EACnBC,sBAAsB,GAAG,CAAC;EAC1BC,aAAa,GAAG,CAAC;EACjB;AACF;;AAEAlC,gBAAgB,CAACmC,YAAY,CAACjC,SAAS,EAAE,IAAI,EAAE,CAAC,YAAY,CAAC,CAAC;AAE9DkC,MAAM,CAACC,OAAO,GAAGnC,SAAS"},"metadata":{},"sourceType":"script","externalDependencies":[]}