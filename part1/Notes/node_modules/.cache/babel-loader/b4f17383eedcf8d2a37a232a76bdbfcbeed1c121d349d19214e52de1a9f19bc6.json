{"ast":null,"code":"'use strict';\n\nconst GuildChannel = require('./GuildChannel');\nconst {\n  Error\n} = require('../errors');\nconst Collection = require('../util/Collection');\nconst {\n  browser\n} = require('../util/Constants');\nconst Permissions = require('../util/Permissions');\n\n/**\n * Represents a guild voice channel on Discord.\n * @extends {GuildChannel}\n */\nclass VoiceChannel extends GuildChannel {\n  _patch(data) {\n    super._patch(data);\n    /**\n     * The bitrate of this voice channel\n     * @type {number}\n     */\n    this.bitrate = data.bitrate;\n\n    /**\n     * The maximum amount of users allowed in this channel - 0 means unlimited.\n     * @type {number}\n     */\n    this.userLimit = data.user_limit;\n  }\n\n  /**\n   * The members in this voice channel\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    const coll = new Collection();\n    for (const state of this.guild.voiceStates.cache.values()) {\n      if (state.channelID === this.id && state.member) {\n        coll.set(state.id, state.member);\n      }\n    }\n    return coll;\n  }\n\n  /**\n   * Checks if the voice channel is full\n   * @type {boolean}\n   * @readonly\n   */\n  get full() {\n    return this.userLimit > 0 && this.members.size >= this.userLimit;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return super.deletable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n\n  /**\n   * Whether the channel is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return this.manageable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n\n  /**\n   * Whether the channel is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get joinable() {\n    if (browser) return false;\n    if (!this.viewable) return false;\n    if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) return false;\n    if (this.full && !this.permissionsFor(this.client.user).has(Permissions.FLAGS.MOVE_MEMBERS, false)) return false;\n    return true;\n  }\n\n  /**\n   * Checks if the client has permission to send audio to the voice channel\n   * @type {boolean}\n   * @readonly\n   */\n  get speakable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.SPEAK, false);\n  }\n\n  /**\n   * Sets the bitrate of the channel.\n   * @param {number} bitrate The new bitrate\n   * @param {string} [reason] Reason for changing the channel's bitrate\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the bitrate of a voice channel\n   * voiceChannel.setBitrate(48000)\n   *   .then(vc => console.log(`Set bitrate to ${vc.bitrate}bps for ${vc.name}`))\n   *   .catch(console.error);\n   */\n  setBitrate(bitrate, reason) {\n    return this.edit({\n      bitrate\n    }, reason);\n  }\n\n  /**\n   * Sets the user limit of the channel.\n   * @param {number} userLimit The new user limit\n   * @param {string} [reason] Reason for changing the user limit\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the user limit of a voice channel\n   * voiceChannel.setUserLimit(42)\n   *   .then(vc => console.log(`Set user limit to ${vc.userLimit} for ${vc.name}`))\n   *   .catch(console.error);\n   */\n  setUserLimit(userLimit, reason) {\n    return this.edit({\n      userLimit\n    }, reason);\n  }\n\n  /**\n   * Attempts to join this voice channel.\n   * @returns {Promise<VoiceConnection>}\n   * @example\n   * // Join a voice channel\n   * voiceChannel.join()\n   *   .then(connection => console.log('Connected!'))\n   *   .catch(console.error);\n   */\n  join() {\n    if (browser) return Promise.reject(new Error('VOICE_NO_BROWSER'));\n    return this.client.voice.joinChannel(this);\n  }\n\n  /**\n   * Leaves this voice channel.\n   * @example\n   * // Leave a voice channel\n   * voiceChannel.leave();\n   */\n  leave() {\n    if (browser) return;\n    const connection = this.client.voice.connections.get(this.guild.id);\n    if (connection && connection.channel.id === this.id) connection.disconnect();\n  }\n}\nmodule.exports = VoiceChannel;","map":{"version":3,"names":["GuildChannel","require","Error","Collection","browser","Permissions","VoiceChannel","_patch","data","bitrate","userLimit","user_limit","members","coll","state","guild","voiceStates","cache","values","channelID","id","member","set","full","size","deletable","permissionsFor","client","user","has","FLAGS","CONNECT","editable","manageable","joinable","viewable","MOVE_MEMBERS","speakable","SPEAK","setBitrate","reason","edit","setUserLimit","join","Promise","reject","voice","joinChannel","leave","connection","connections","get","channel","disconnect","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/VoiceChannel.js"],"sourcesContent":["'use strict';\n\nconst GuildChannel = require('./GuildChannel');\nconst { Error } = require('../errors');\nconst Collection = require('../util/Collection');\nconst { browser } = require('../util/Constants');\nconst Permissions = require('../util/Permissions');\n\n/**\n * Represents a guild voice channel on Discord.\n * @extends {GuildChannel}\n */\nclass VoiceChannel extends GuildChannel {\n  _patch(data) {\n    super._patch(data);\n    /**\n     * The bitrate of this voice channel\n     * @type {number}\n     */\n    this.bitrate = data.bitrate;\n\n    /**\n     * The maximum amount of users allowed in this channel - 0 means unlimited.\n     * @type {number}\n     */\n    this.userLimit = data.user_limit;\n  }\n\n  /**\n   * The members in this voice channel\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    const coll = new Collection();\n    for (const state of this.guild.voiceStates.cache.values()) {\n      if (state.channelID === this.id && state.member) {\n        coll.set(state.id, state.member);\n      }\n    }\n    return coll;\n  }\n\n  /**\n   * Checks if the voice channel is full\n   * @type {boolean}\n   * @readonly\n   */\n  get full() {\n    return this.userLimit > 0 && this.members.size >= this.userLimit;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return super.deletable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n\n  /**\n   * Whether the channel is editable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get editable() {\n    return this.manageable && this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false);\n  }\n\n  /**\n   * Whether the channel is joinable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get joinable() {\n    if (browser) return false;\n    if (!this.viewable) return false;\n    if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) return false;\n    if (this.full && !this.permissionsFor(this.client.user).has(Permissions.FLAGS.MOVE_MEMBERS, false)) return false;\n    return true;\n  }\n\n  /**\n   * Checks if the client has permission to send audio to the voice channel\n   * @type {boolean}\n   * @readonly\n   */\n  get speakable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.SPEAK, false);\n  }\n\n  /**\n   * Sets the bitrate of the channel.\n   * @param {number} bitrate The new bitrate\n   * @param {string} [reason] Reason for changing the channel's bitrate\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the bitrate of a voice channel\n   * voiceChannel.setBitrate(48000)\n   *   .then(vc => console.log(`Set bitrate to ${vc.bitrate}bps for ${vc.name}`))\n   *   .catch(console.error);\n   */\n  setBitrate(bitrate, reason) {\n    return this.edit({ bitrate }, reason);\n  }\n\n  /**\n   * Sets the user limit of the channel.\n   * @param {number} userLimit The new user limit\n   * @param {string} [reason] Reason for changing the user limit\n   * @returns {Promise<VoiceChannel>}\n   * @example\n   * // Set the user limit of a voice channel\n   * voiceChannel.setUserLimit(42)\n   *   .then(vc => console.log(`Set user limit to ${vc.userLimit} for ${vc.name}`))\n   *   .catch(console.error);\n   */\n  setUserLimit(userLimit, reason) {\n    return this.edit({ userLimit }, reason);\n  }\n\n  /**\n   * Attempts to join this voice channel.\n   * @returns {Promise<VoiceConnection>}\n   * @example\n   * // Join a voice channel\n   * voiceChannel.join()\n   *   .then(connection => console.log('Connected!'))\n   *   .catch(console.error);\n   */\n  join() {\n    if (browser) return Promise.reject(new Error('VOICE_NO_BROWSER'));\n    return this.client.voice.joinChannel(this);\n  }\n\n  /**\n   * Leaves this voice channel.\n   * @example\n   * // Leave a voice channel\n   * voiceChannel.leave();\n   */\n  leave() {\n    if (browser) return;\n    const connection = this.client.voice.connections.get(this.guild.id);\n    if (connection && connection.channel.id === this.id) connection.disconnect();\n  }\n}\n\nmodule.exports = VoiceChannel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}