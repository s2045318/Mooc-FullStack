{"ast":null,"code":"'use strict';\n\nconst Base = require('./Base');\nconst Role = require('./Role');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst {\n  Error\n} = require('../errors');\nconst GuildMemberRoleManager = require('../managers/GuildMemberRoleManager');\nconst Permissions = require('../util/Permissions');\nlet Structures;\n\n/**\n * Represents a member of a guild on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\nclass GuildMember extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild member\n   * @param {Guild} guild The guild the member is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that this member is part of\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The timestamp the member joined the guild at\n     * @type {?number}\n     */\n    this.joinedTimestamp = null;\n\n    /**\n     * The ID of the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = null;\n\n    /**\n     * The ID of the channel for the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageChannelID = null;\n\n    /**\n     * The timestamp of when the member used their Nitro boost on the guild, if it was used\n     * @type {?number}\n     */\n    this.premiumSinceTimestamp = null;\n\n    /**\n     * Whether the member has been removed from the guild\n     * @type {boolean}\n     */\n    this.deleted = false;\n\n    /**\n     * The nickname of this member, if they have one\n     * @type {?string}\n     */\n    this.nickname = null;\n    this._roles = [];\n    if (data) this._patch(data);\n  }\n  _patch(data) {\n    if ('user' in data) {\n      /**\n       * The user that this guild member instance represents\n       * @type {User}\n       */\n      this.user = this.client.users.add(data.user, true);\n    }\n    if ('nick' in data) this.nickname = data.nick;\n    if ('joined_at' in data) this.joinedTimestamp = new Date(data.joined_at).getTime();\n    if ('premium_since' in data) this.premiumSinceTimestamp = new Date(data.premium_since).getTime();\n    if ('roles' in data) this._roles = data.roles;\n  }\n  _clone() {\n    const clone = super._clone();\n    clone._roles = this._roles.slice();\n    return clone;\n  }\n\n  /**\n   * Whether this GuildMember is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return !this.joinedTimestamp;\n  }\n\n  /**\n   * A manager for the roles belonging to this member\n   * @type {GuildMemberRoleManager}\n   * @readonly\n   */\n  get roles() {\n    return new GuildMemberRoleManager(this);\n  }\n\n  /**\n   * The Message object of the last message sent by the member in their guild, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    const channel = this.guild.channels.cache.get(this.lastMessageChannelID);\n    return channel && channel.messages.cache.get(this.lastMessageID) || null;\n  }\n\n  /**\n   * The voice state of this member\n   * @type {VoiceState}\n   * @readonly\n   */\n  get voice() {\n    if (!Structures) Structures = require('../util/Structures');\n    const VoiceState = Structures.get('VoiceState');\n    return this.guild.voiceStates.cache.get(this.id) || new VoiceState(this.guild, {\n      user_id: this.id\n    });\n  }\n\n  /**\n   * The time this member joined the guild\n   * @type {?Date}\n   * @readonly\n   */\n  get joinedAt() {\n    return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;\n  }\n\n  /**\n   * The time of when the member used their Nitro boost on the guild, if it was used\n   * @type {?Date}\n   * @readonly\n   */\n  get premiumSince() {\n    return this.premiumSinceTimestamp ? new Date(this.premiumSinceTimestamp) : null;\n  }\n\n  /**\n   * The presence of this guild member\n   * @type {Presence}\n   * @readonly\n   */\n  get presence() {\n    if (!Structures) Structures = require('../util/Structures');\n    const Presence = Structures.get('Presence');\n    return this.guild.presences.cache.get(this.id) || new Presence(this.client, {\n      user: {\n        id: this.id\n      },\n      guild: this.guild\n    });\n  }\n\n  /**\n   * The displayed color of this member in base 10\n   * @type {number}\n   * @readonly\n   */\n  get displayColor() {\n    const role = this.roles.color;\n    return role && role.color || 0;\n  }\n\n  /**\n   * The displayed color of this member in hexadecimal\n   * @type {string}\n   * @readonly\n   */\n  get displayHexColor() {\n    const role = this.roles.color;\n    return role && role.hexColor || '#000000';\n  }\n\n  /**\n   * The ID of this member\n   * @type {Snowflake}\n   * @readonly\n   */\n  get id() {\n    return this.user.id;\n  }\n\n  /**\n   * The nickname of this member, or their username if they don't have one\n   * @type {?string}\n   * @readonly\n   */\n  get displayName() {\n    return this.nickname || this.user.username;\n  }\n\n  /**\n   * The overall set of permissions for this member, taking only roles into account\n   * @type {Readonly<Permissions>}\n   * @readonly\n   */\n  get permissions() {\n    if (this.user.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n    return new Permissions(this.roles.cache.map(role => role.permissions)).freeze();\n  }\n\n  /**\n   * Whether the client user is above this user in the hierarchy, according to role position and guild ownership.\n   * This is a prerequisite for many moderative actions.\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.user.id === this.guild.ownerID) return false;\n    if (this.user.id === this.client.user.id) return false;\n    if (this.client.user.id === this.guild.ownerID) return true;\n    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n    return this.guild.me.roles.highest.comparePositionTo(this.roles.highest) > 0;\n  }\n\n  /**\n   * Whether this member is kickable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get kickable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.KICK_MEMBERS);\n  }\n\n  /**\n   * Whether this member is bannable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get bannable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.BAN_MEMBERS);\n  }\n\n  /**\n   * Returns `channel.permissionsFor(guildMember)`. Returns permissions for a member in a guild channel,\n   * taking into account roles and permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.memberPermissions(this);\n  }\n\n  /**\n   * Checks if any of this member's roles have a permission.\n   * @param {PermissionResolvable} permission Permission(s) to check for\n   * @param {Object} [options] Options\n   * @param {boolean} [options.checkAdmin=true] Whether to allow the administrator permission to override\n   * @param {boolean} [options.checkOwner=true] Whether to allow being the guild's owner to override\n   * @returns {boolean}\n   */\n  hasPermission(permission) {\n    let {\n      checkAdmin = true,\n      checkOwner = true\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (checkOwner && this.user.id === this.guild.ownerID) return true;\n    const permissions = new Permissions(this.roles.cache.map(role => role.permissions));\n    return permissions.has(permission, checkAdmin);\n  }\n\n  /**\n   * The data for editing a guild member.\n   * @typedef {Object} GuildMemberEditData\n   * @property {string} [nick] The nickname to set for the member\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role IDs to apply\n   * @property {boolean} [mute] Whether or not the member should be muted\n   * @property {boolean} [deaf] Whether or not the member should be deafened\n   * @property {ChannelResolvable|null} [channel] Channel to move member to (if they are connected to voice), or `null`\n   * if you want to kick them from voice\n   */\n\n  /**\n   * Edits this member.\n   * @param {GuildMemberEditData} data The data to edit the member with\n   * @param {string} [reason] Reason for editing this user\n   * @returns {Promise<GuildMember>}\n   */\n  async edit(data, reason) {\n    if (data.channel) {\n      data.channel = this.guild.channels.resolve(data.channel);\n      if (!data.channel || data.channel.type !== 'voice') {\n        throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');\n      }\n      data.channel_id = data.channel.id;\n      data.channel = undefined;\n    } else if (data.channel === null) {\n      data.channel_id = null;\n      data.channel = undefined;\n    }\n    if (data.roles) data.roles = data.roles.map(role => role instanceof Role ? role.id : role);\n    let endpoint = this.client.api.guilds(this.guild.id);\n    if (this.user.id === this.client.user.id) {\n      const keys = Object.keys(data);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = endpoint.members('@me').nick;else endpoint = endpoint.members(this.id);\n    } else {\n      endpoint = endpoint.members(this.id);\n    }\n    await endpoint.patch({\n      data,\n      reason\n    });\n    const clone = this._clone();\n    data.user = this.user;\n    clone._patch(data);\n    return clone;\n  }\n\n  /**\n   * Sets the nickname for this member.\n   * @param {string} nick The nickname for the guild member\n   * @param {string} [reason] Reason for setting the nickname\n   * @returns {Promise<GuildMember>}\n   */\n  setNickname(nick, reason) {\n    return this.edit({\n      nick\n    }, reason);\n  }\n\n  /**\n   * Creates a DM channel between the client and this member.\n   * @returns {Promise<DMChannel>}\n   */\n  createDM() {\n    return this.user.createDM();\n  }\n\n  /**\n   * Deletes any DMs with this member.\n   * @returns {Promise<DMChannel>}\n   */\n  deleteDM() {\n    return this.user.deleteDM();\n  }\n\n  /**\n   * Kicks this member from the guild.\n   * @param {string} [reason] Reason for kicking user\n   * @returns {Promise<GuildMember>}\n   */\n  kick(reason) {\n    return this.client.api.guilds(this.guild.id).members(this.user.id).delete({\n      reason\n    }).then(() => this);\n  }\n\n  /**\n   * Bans this guild member.\n   * @param {Object} [options] Options for the ban\n   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7\n   * @param {string} [options.reason] Reason for banning\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // ban a guild member\n   * guildMember.ban({ days: 7, reason: 'They deserved it' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  ban(options) {\n    return this.guild.members.ban(this, options);\n  }\n\n  /**\n   * Fetches this GuildMember.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<GuildMember>}\n   */\n  fetch() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this.guild.members.fetch({\n      user: this.id,\n      cache: true,\n      force\n    });\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the user's mention instead of the GuildMember object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${member}!`);\n   */\n  toString() {\n    return `<@${this.nickname ? '!' : ''}${this.user.id}>`;\n  }\n  toJSON() {\n    return super.toJSON({\n      guild: 'guildID',\n      user: 'userID',\n      displayName: true,\n      speaking: false,\n      lastMessage: false,\n      lastMessageID: false,\n      roles: true\n    });\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  send() {}\n}\nTextBasedChannel.applyToClass(GuildMember);\nmodule.exports = GuildMember;","map":{"version":3,"names":["Base","require","Role","TextBasedChannel","Error","GuildMemberRoleManager","Permissions","Structures","GuildMember","constructor","client","data","guild","joinedTimestamp","lastMessageID","lastMessageChannelID","premiumSinceTimestamp","deleted","nickname","_roles","_patch","user","users","add","nick","Date","joined_at","getTime","premium_since","roles","_clone","clone","slice","partial","lastMessage","channel","channels","cache","get","messages","voice","VoiceState","voiceStates","id","user_id","joinedAt","premiumSince","presence","Presence","presences","displayColor","role","color","displayHexColor","hexColor","displayName","username","permissions","ownerID","ALL","freeze","map","manageable","me","highest","comparePositionTo","kickable","has","FLAGS","KICK_MEMBERS","bannable","BAN_MEMBERS","permissionsIn","resolve","memberPermissions","hasPermission","permission","checkAdmin","checkOwner","edit","reason","type","channel_id","undefined","endpoint","api","guilds","keys","Object","length","members","patch","setNickname","createDM","deleteDM","kick","delete","then","ban","options","fetch","force","toString","toJSON","speaking","send","applyToClass","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/GuildMember.js"],"sourcesContent":["'use strict';\n\nconst Base = require('./Base');\nconst Role = require('./Role');\nconst TextBasedChannel = require('./interfaces/TextBasedChannel');\nconst { Error } = require('../errors');\nconst GuildMemberRoleManager = require('../managers/GuildMemberRoleManager');\nconst Permissions = require('../util/Permissions');\nlet Structures;\n\n/**\n * Represents a member of a guild on Discord.\n * @implements {TextBasedChannel}\n * @extends {Base}\n */\nclass GuildMember extends Base {\n  /**\n   * @param {Client} client The instantiating client\n   * @param {Object} data The data for the guild member\n   * @param {Guild} guild The guild the member is part of\n   */\n  constructor(client, data, guild) {\n    super(client);\n\n    /**\n     * The guild that this member is part of\n     * @type {Guild}\n     */\n    this.guild = guild;\n\n    /**\n     * The timestamp the member joined the guild at\n     * @type {?number}\n     */\n    this.joinedTimestamp = null;\n\n    /**\n     * The ID of the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = null;\n\n    /**\n     * The ID of the channel for the last message sent by the member in their guild, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageChannelID = null;\n\n    /**\n     * The timestamp of when the member used their Nitro boost on the guild, if it was used\n     * @type {?number}\n     */\n    this.premiumSinceTimestamp = null;\n\n    /**\n     * Whether the member has been removed from the guild\n     * @type {boolean}\n     */\n    this.deleted = false;\n\n    /**\n     * The nickname of this member, if they have one\n     * @type {?string}\n     */\n    this.nickname = null;\n\n    this._roles = [];\n    if (data) this._patch(data);\n  }\n\n  _patch(data) {\n    if ('user' in data) {\n      /**\n       * The user that this guild member instance represents\n       * @type {User}\n       */\n      this.user = this.client.users.add(data.user, true);\n    }\n\n    if ('nick' in data) this.nickname = data.nick;\n    if ('joined_at' in data) this.joinedTimestamp = new Date(data.joined_at).getTime();\n    if ('premium_since' in data) this.premiumSinceTimestamp = new Date(data.premium_since).getTime();\n    if ('roles' in data) this._roles = data.roles;\n  }\n\n  _clone() {\n    const clone = super._clone();\n    clone._roles = this._roles.slice();\n    return clone;\n  }\n\n  /**\n   * Whether this GuildMember is a partial\n   * @type {boolean}\n   * @readonly\n   */\n  get partial() {\n    return !this.joinedTimestamp;\n  }\n\n  /**\n   * A manager for the roles belonging to this member\n   * @type {GuildMemberRoleManager}\n   * @readonly\n   */\n  get roles() {\n    return new GuildMemberRoleManager(this);\n  }\n\n  /**\n   * The Message object of the last message sent by the member in their guild, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    const channel = this.guild.channels.cache.get(this.lastMessageChannelID);\n    return (channel && channel.messages.cache.get(this.lastMessageID)) || null;\n  }\n\n  /**\n   * The voice state of this member\n   * @type {VoiceState}\n   * @readonly\n   */\n  get voice() {\n    if (!Structures) Structures = require('../util/Structures');\n    const VoiceState = Structures.get('VoiceState');\n    return this.guild.voiceStates.cache.get(this.id) || new VoiceState(this.guild, { user_id: this.id });\n  }\n\n  /**\n   * The time this member joined the guild\n   * @type {?Date}\n   * @readonly\n   */\n  get joinedAt() {\n    return this.joinedTimestamp ? new Date(this.joinedTimestamp) : null;\n  }\n\n  /**\n   * The time of when the member used their Nitro boost on the guild, if it was used\n   * @type {?Date}\n   * @readonly\n   */\n  get premiumSince() {\n    return this.premiumSinceTimestamp ? new Date(this.premiumSinceTimestamp) : null;\n  }\n\n  /**\n   * The presence of this guild member\n   * @type {Presence}\n   * @readonly\n   */\n  get presence() {\n    if (!Structures) Structures = require('../util/Structures');\n    const Presence = Structures.get('Presence');\n    return (\n      this.guild.presences.cache.get(this.id) ||\n      new Presence(this.client, {\n        user: {\n          id: this.id,\n        },\n        guild: this.guild,\n      })\n    );\n  }\n\n  /**\n   * The displayed color of this member in base 10\n   * @type {number}\n   * @readonly\n   */\n  get displayColor() {\n    const role = this.roles.color;\n    return (role && role.color) || 0;\n  }\n\n  /**\n   * The displayed color of this member in hexadecimal\n   * @type {string}\n   * @readonly\n   */\n  get displayHexColor() {\n    const role = this.roles.color;\n    return (role && role.hexColor) || '#000000';\n  }\n\n  /**\n   * The ID of this member\n   * @type {Snowflake}\n   * @readonly\n   */\n  get id() {\n    return this.user.id;\n  }\n\n  /**\n   * The nickname of this member, or their username if they don't have one\n   * @type {?string}\n   * @readonly\n   */\n  get displayName() {\n    return this.nickname || this.user.username;\n  }\n\n  /**\n   * The overall set of permissions for this member, taking only roles into account\n   * @type {Readonly<Permissions>}\n   * @readonly\n   */\n  get permissions() {\n    if (this.user.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n    return new Permissions(this.roles.cache.map(role => role.permissions)).freeze();\n  }\n\n  /**\n   * Whether the client user is above this user in the hierarchy, according to role position and guild ownership.\n   * This is a prerequisite for many moderative actions.\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.user.id === this.guild.ownerID) return false;\n    if (this.user.id === this.client.user.id) return false;\n    if (this.client.user.id === this.guild.ownerID) return true;\n    if (!this.guild.me) throw new Error('GUILD_UNCACHED_ME');\n    return this.guild.me.roles.highest.comparePositionTo(this.roles.highest) > 0;\n  }\n\n  /**\n   * Whether this member is kickable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get kickable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.KICK_MEMBERS);\n  }\n\n  /**\n   * Whether this member is bannable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get bannable() {\n    return this.manageable && this.guild.me.permissions.has(Permissions.FLAGS.BAN_MEMBERS);\n  }\n\n  /**\n   * Returns `channel.permissionsFor(guildMember)`. Returns permissions for a member in a guild channel,\n   * taking into account roles and permission overwrites.\n   * @param {ChannelResolvable} channel The guild channel to use as context\n   * @returns {Readonly<Permissions>}\n   */\n  permissionsIn(channel) {\n    channel = this.guild.channels.resolve(channel);\n    if (!channel) throw new Error('GUILD_CHANNEL_RESOLVE');\n    return channel.memberPermissions(this);\n  }\n\n  /**\n   * Checks if any of this member's roles have a permission.\n   * @param {PermissionResolvable} permission Permission(s) to check for\n   * @param {Object} [options] Options\n   * @param {boolean} [options.checkAdmin=true] Whether to allow the administrator permission to override\n   * @param {boolean} [options.checkOwner=true] Whether to allow being the guild's owner to override\n   * @returns {boolean}\n   */\n  hasPermission(permission, { checkAdmin = true, checkOwner = true } = {}) {\n    if (checkOwner && this.user.id === this.guild.ownerID) return true;\n    const permissions = new Permissions(this.roles.cache.map(role => role.permissions));\n    return permissions.has(permission, checkAdmin);\n  }\n\n  /**\n   * The data for editing a guild member.\n   * @typedef {Object} GuildMemberEditData\n   * @property {string} [nick] The nickname to set for the member\n   * @property {Collection<Snowflake, Role>|RoleResolvable[]} [roles] The roles or role IDs to apply\n   * @property {boolean} [mute] Whether or not the member should be muted\n   * @property {boolean} [deaf] Whether or not the member should be deafened\n   * @property {ChannelResolvable|null} [channel] Channel to move member to (if they are connected to voice), or `null`\n   * if you want to kick them from voice\n   */\n\n  /**\n   * Edits this member.\n   * @param {GuildMemberEditData} data The data to edit the member with\n   * @param {string} [reason] Reason for editing this user\n   * @returns {Promise<GuildMember>}\n   */\n  async edit(data, reason) {\n    if (data.channel) {\n      data.channel = this.guild.channels.resolve(data.channel);\n      if (!data.channel || data.channel.type !== 'voice') {\n        throw new Error('GUILD_VOICE_CHANNEL_RESOLVE');\n      }\n      data.channel_id = data.channel.id;\n      data.channel = undefined;\n    } else if (data.channel === null) {\n      data.channel_id = null;\n      data.channel = undefined;\n    }\n    if (data.roles) data.roles = data.roles.map(role => (role instanceof Role ? role.id : role));\n    let endpoint = this.client.api.guilds(this.guild.id);\n    if (this.user.id === this.client.user.id) {\n      const keys = Object.keys(data);\n      if (keys.length === 1 && keys[0] === 'nick') endpoint = endpoint.members('@me').nick;\n      else endpoint = endpoint.members(this.id);\n    } else {\n      endpoint = endpoint.members(this.id);\n    }\n    await endpoint.patch({ data, reason });\n\n    const clone = this._clone();\n    data.user = this.user;\n    clone._patch(data);\n    return clone;\n  }\n\n  /**\n   * Sets the nickname for this member.\n   * @param {string} nick The nickname for the guild member\n   * @param {string} [reason] Reason for setting the nickname\n   * @returns {Promise<GuildMember>}\n   */\n  setNickname(nick, reason) {\n    return this.edit({ nick }, reason);\n  }\n\n  /**\n   * Creates a DM channel between the client and this member.\n   * @returns {Promise<DMChannel>}\n   */\n  createDM() {\n    return this.user.createDM();\n  }\n\n  /**\n   * Deletes any DMs with this member.\n   * @returns {Promise<DMChannel>}\n   */\n  deleteDM() {\n    return this.user.deleteDM();\n  }\n\n  /**\n   * Kicks this member from the guild.\n   * @param {string} [reason] Reason for kicking user\n   * @returns {Promise<GuildMember>}\n   */\n  kick(reason) {\n    return this.client.api\n      .guilds(this.guild.id)\n      .members(this.user.id)\n      .delete({ reason })\n      .then(() => this);\n  }\n\n  /**\n   * Bans this guild member.\n   * @param {Object} [options] Options for the ban\n   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7\n   * @param {string} [options.reason] Reason for banning\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // ban a guild member\n   * guildMember.ban({ days: 7, reason: 'They deserved it' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  ban(options) {\n    return this.guild.members.ban(this, options);\n  }\n\n  /**\n   * Fetches this GuildMember.\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<GuildMember>}\n   */\n  fetch(force = false) {\n    return this.guild.members.fetch({ user: this.id, cache: true, force });\n  }\n\n  /**\n   * When concatenated with a string, this automatically returns the user's mention instead of the GuildMember object.\n   * @returns {string}\n   * @example\n   * // Logs: Hello from <@123456789012345678>!\n   * console.log(`Hello from ${member}!`);\n   */\n  toString() {\n    return `<@${this.nickname ? '!' : ''}${this.user.id}>`;\n  }\n\n  toJSON() {\n    return super.toJSON({\n      guild: 'guildID',\n      user: 'userID',\n      displayName: true,\n      speaking: false,\n      lastMessage: false,\n      lastMessageID: false,\n      roles: true,\n    });\n  }\n\n  // These are here only for documentation purposes - they are implemented by TextBasedChannel\n  /* eslint-disable no-empty-function */\n  send() {}\n}\n\nTextBasedChannel.applyToClass(GuildMember);\n\nmodule.exports = GuildMember;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}