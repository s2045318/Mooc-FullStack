{"ast":null,"code":"'use strict';\n\nconst {\n  RangeError\n} = require('../errors');\n\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\nclass BitField {\n  /**\n   * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n   */\n  constructor(bits) {\n    /**\n     * Bitfield of the packed bits\n     * @type {number}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== 0;\n  }\n\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  has(bit) {\n    if (Array.isArray(bit)) return bit.every(p => this.has(p));\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  missing(bits) {\n    for (var _len = arguments.length, hasParams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      hasParams[_key - 1] = arguments[_key];\n    }\n    if (!Array.isArray(bits)) bits = new this.constructor(bits).toArray(false);\n    return bits.filter(p => !this.has(p, ...hasParams));\n  }\n\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>} These bits\n   */\n  freeze() {\n    return Object.freeze(this);\n  }\n\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  add() {\n    let total = 0;\n    for (var _len2 = arguments.length, bits = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      bits[_key2] = arguments[_key2];\n    }\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  remove() {\n    let total = 0;\n    for (var _len3 = arguments.length, bits = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      bits[_key3] = arguments[_key3];\n    }\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n  serialize() {\n    const serialized = {};\n    for (var _len4 = arguments.length, hasParams = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      hasParams[_key4] = arguments[_key4];\n    }\n    for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);\n    return serialized;\n  }\n\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  toArray() {\n    for (var _len5 = arguments.length, hasParams = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      hasParams[_key5] = arguments[_key5];\n    }\n    return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));\n  }\n  toJSON() {\n    return this.bitfield;\n  }\n  valueOf() {\n    return this.bitfield;\n  }\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A string (see {@link BitField.FLAGS})\n   * * A bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {string|number|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit=0] - bit(s) to resolve\n   * @returns {number}\n   */\n  static resolve() {\n    let bit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (typeof bit === 'number' && bit >= 0) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, 0);\n    if (typeof bit === 'string' && typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];\n    const error = new RangeError('BITFIELD_INVALID');\n    error.bit = bit;\n    throw error;\n  }\n}\n\n/**\n * Numeric bitfield flags.\n * <info>Defined in extension classes</info>\n * @type {Object}\n * @abstract\n */\nBitField.FLAGS = {};\nmodule.exports = BitField;","map":{"version":3,"names":["RangeError","require","BitField","constructor","bits","bitfield","resolve","any","bit","equals","has","Array","isArray","every","p","missing","hasParams","toArray","filter","freeze","Object","add","total","isFrozen","remove","serialize","serialized","flag","entries","FLAGS","keys","toJSON","valueOf","Symbol","iterator","map","reduce","prev","error","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/util/BitField.js"],"sourcesContent":["'use strict';\n\nconst { RangeError } = require('../errors');\n\n/**\n * Data structure that makes it easy to interact with a bitfield.\n */\nclass BitField {\n  /**\n   * @param {BitFieldResolvable} [bits=0] Bit(s) to read from\n   */\n  constructor(bits) {\n    /**\n     * Bitfield of the packed bits\n     * @type {number}\n     */\n    this.bitfield = this.constructor.resolve(bits);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or any of multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  any(bit) {\n    return (this.bitfield & this.constructor.resolve(bit)) !== 0;\n  }\n\n  /**\n   * Checks if this bitfield equals another\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  equals(bit) {\n    return this.bitfield === this.constructor.resolve(bit);\n  }\n\n  /**\n   * Checks whether the bitfield has a bit, or multiple bits.\n   * @param {BitFieldResolvable} bit Bit(s) to check for\n   * @returns {boolean}\n   */\n  has(bit) {\n    if (Array.isArray(bit)) return bit.every(p => this.has(p));\n    bit = this.constructor.resolve(bit);\n    return (this.bitfield & bit) === bit;\n  }\n\n  /**\n   * Gets all given bits that are missing from the bitfield.\n   * @param {BitFieldResolvable} bits Bit(s) to check for\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  missing(bits, ...hasParams) {\n    if (!Array.isArray(bits)) bits = new this.constructor(bits).toArray(false);\n    return bits.filter(p => !this.has(p, ...hasParams));\n  }\n\n  /**\n   * Freezes these bits, making them immutable.\n   * @returns {Readonly<BitField>} These bits\n   */\n  freeze() {\n    return Object.freeze(this);\n  }\n\n  /**\n   * Adds bits to these ones.\n   * @param {...BitFieldResolvable} [bits] Bits to add\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  add(...bits) {\n    let total = 0;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);\n    this.bitfield |= total;\n    return this;\n  }\n\n  /**\n   * Removes bits from these.\n   * @param {...BitFieldResolvable} [bits] Bits to remove\n   * @returns {BitField} These bits or new BitField if the instance is frozen.\n   */\n  remove(...bits) {\n    let total = 0;\n    for (const bit of bits) {\n      total |= this.constructor.resolve(bit);\n    }\n    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);\n    this.bitfield &= ~total;\n    return this;\n  }\n\n  /**\n   * Gets an object mapping field names to a {@link boolean} indicating whether the\n   * bit is available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {Object}\n   */\n  serialize(...hasParams) {\n    const serialized = {};\n    for (const [flag, bit] of Object.entries(this.constructor.FLAGS)) serialized[flag] = this.has(bit, ...hasParams);\n    return serialized;\n  }\n\n  /**\n   * Gets an {@link Array} of bitfield names based on the bits available.\n   * @param {...*} hasParams Additional parameters for the has method, if any\n   * @returns {string[]}\n   */\n  toArray(...hasParams) {\n    return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));\n  }\n\n  toJSON() {\n    return this.bitfield;\n  }\n\n  valueOf() {\n    return this.bitfield;\n  }\n\n  *[Symbol.iterator]() {\n    yield* this.toArray();\n  }\n\n  /**\n   * Data that can be resolved to give a bitfield. This can be:\n   * * A string (see {@link BitField.FLAGS})\n   * * A bit number\n   * * An instance of BitField\n   * * An Array of BitFieldResolvable\n   * @typedef {string|number|BitField|BitFieldResolvable[]} BitFieldResolvable\n   */\n\n  /**\n   * Resolves bitfields to their numeric form.\n   * @param {BitFieldResolvable} [bit=0] - bit(s) to resolve\n   * @returns {number}\n   */\n  static resolve(bit = 0) {\n    if (typeof bit === 'number' && bit >= 0) return bit;\n    if (bit instanceof BitField) return bit.bitfield;\n    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, 0);\n    if (typeof bit === 'string' && typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];\n    const error = new RangeError('BITFIELD_INVALID');\n    error.bit = bit;\n    throw error;\n  }\n}\n\n/**\n * Numeric bitfield flags.\n * <info>Defined in extension classes</info>\n * @type {Object}\n * @abstract\n */\nBitField.FLAGS = {};\n\nmodule.exports = BitField;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}