{"ast":null,"code":"'use strict';\n\nconst {\n  TypeError\n} = require('../errors');\nconst Collection = require('../util/Collection');\n\n/**\n * Manages API methods for roles of a GuildMember and stores their cache.\n */\nclass GuildMemberRoleManager {\n  constructor(member) {\n    /**\n     * The GuildMember this manager belongs to\n     * @type {GuildMember}\n     */\n    this.member = member;\n    /**\n     * The Guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = member.guild;\n    Object.defineProperty(this, 'client', {\n      value: member.client\n    });\n  }\n\n  /**\n   * The filtered collection of roles of the member\n   * @type {Collection<Snowflake, Role>}\n   * @private\n   * @readonly\n   */\n  get _roles() {\n    const everyone = this.guild.roles.everyone;\n    return this.guild.roles.cache.filter(role => this.member._roles.includes(role.id)).set(everyone.id, everyone);\n  }\n\n  /**\n   * The roles of this member\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n  get cache() {\n    return this._roles;\n  }\n\n  /**\n   * The role of the member used to hoist them in a separate category in the users list\n   * @type {?Role}\n   * @readonly\n   */\n  get hoist() {\n    const hoistedRoles = this._roles.filter(role => role.hoist);\n    if (!hoistedRoles.size) return null;\n    return hoistedRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n\n  /**\n   * The role of the member used to set their color\n   * @type {?Role}\n   * @readonly\n   */\n  get color() {\n    const coloredRoles = this._roles.filter(role => role.color);\n    if (!coloredRoles.size) return null;\n    return coloredRoles.reduce((prev, role) => !prev || role.comparePositionTo(prev) > 0 ? role : prev);\n  }\n\n  /**\n   * The role of the member with the highest position\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this._roles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this._roles.first());\n  }\n\n  /**\n   * Adds a role (or multiple roles) to the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add\n   * @param {string} [reason] Reason for adding the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n  async add(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));\n      if (roleOrRoles.includes(null)) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n      const newRoles = [...new Set(roleOrRoles.concat(...this._roles.values()))];\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolve(roleOrRoles);\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');\n      }\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].put({\n        reason\n      });\n      const clone = this.member._clone();\n      clone._roles = [...this._roles.keys(), roleOrRoles.id];\n      return clone;\n    }\n  }\n\n  /**\n   * Removes a role (or multiple roles) from the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove\n   * @param {string} [reason] Reason for removing the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n  async remove(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));\n      if (roleOrRoles.includes(null)) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n      const newRoles = this._roles.filter(role => !roleOrRoles.includes(role));\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolve(roleOrRoles);\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].delete({\n        reason\n      });\n      const clone = this.member._clone();\n      const newRoles = this._roles.filter(role => role.id !== roleOrRoles.id);\n      clone._roles = [...newRoles.keys()];\n      return clone;\n    }\n  }\n\n  /**\n   * Sets the roles applied to the member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to apply\n   * @param {string} [reason] Reason for applying the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Set the member's roles to a single role\n   * guildMember.roles.set(['391156570408615936'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all the roles from a member\n   * guildMember.roles.set([])\n   *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))\n   *   .catch(console.error);\n   */\n  set(roles, reason) {\n    return this.member.edit({\n      roles\n    }, reason);\n  }\n  clone() {\n    const clone = new this.constructor(this.member);\n    clone.member._roles = [...this._roles.keyArray()];\n    return clone;\n  }\n}\nmodule.exports = GuildMemberRoleManager;","map":{"version":3,"names":["TypeError","require","Collection","GuildMemberRoleManager","constructor","member","guild","Object","defineProperty","value","client","_roles","everyone","roles","cache","filter","role","includes","id","set","hoist","hoistedRoles","size","reduce","prev","comparePositionTo","color","coloredRoles","highest","first","add","roleOrRoles","reason","Array","isArray","map","r","resolve","newRoles","Set","concat","values","api","guilds","members","put","clone","_clone","keys","remove","delete","edit","keyArray","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/managers/GuildMemberRoleManager.js"],"sourcesContent":["'use strict';\n\nconst { TypeError } = require('../errors');\nconst Collection = require('../util/Collection');\n\n/**\n * Manages API methods for roles of a GuildMember and stores their cache.\n */\nclass GuildMemberRoleManager {\n  constructor(member) {\n    /**\n     * The GuildMember this manager belongs to\n     * @type {GuildMember}\n     */\n    this.member = member;\n    /**\n     * The Guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = member.guild;\n    Object.defineProperty(this, 'client', { value: member.client });\n  }\n\n  /**\n   * The filtered collection of roles of the member\n   * @type {Collection<Snowflake, Role>}\n   * @private\n   * @readonly\n   */\n  get _roles() {\n    const everyone = this.guild.roles.everyone;\n    return this.guild.roles.cache.filter(role => this.member._roles.includes(role.id)).set(everyone.id, everyone);\n  }\n\n  /**\n   * The roles of this member\n   * @type {Collection<Snowflake, Role>}\n   * @readonly\n   */\n  get cache() {\n    return this._roles;\n  }\n\n  /**\n   * The role of the member used to hoist them in a separate category in the users list\n   * @type {?Role}\n   * @readonly\n   */\n  get hoist() {\n    const hoistedRoles = this._roles.filter(role => role.hoist);\n    if (!hoistedRoles.size) return null;\n    return hoistedRoles.reduce((prev, role) => (!prev || role.comparePositionTo(prev) > 0 ? role : prev));\n  }\n\n  /**\n   * The role of the member used to set their color\n   * @type {?Role}\n   * @readonly\n   */\n  get color() {\n    const coloredRoles = this._roles.filter(role => role.color);\n    if (!coloredRoles.size) return null;\n    return coloredRoles.reduce((prev, role) => (!prev || role.comparePositionTo(prev) > 0 ? role : prev));\n  }\n\n  /**\n   * The role of the member with the highest position\n   * @type {Role}\n   * @readonly\n   */\n  get highest() {\n    return this._roles.reduce((prev, role) => (role.comparePositionTo(prev) > 0 ? role : prev), this._roles.first());\n  }\n\n  /**\n   * Adds a role (or multiple roles) to the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to add\n   * @param {string} [reason] Reason for adding the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n  async add(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));\n      if (roleOrRoles.includes(null)) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      const newRoles = [...new Set(roleOrRoles.concat(...this._roles.values()))];\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolve(roleOrRoles);\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Role, Snowflake or Array or Collection of Roles or Snowflakes');\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].put({ reason });\n\n      const clone = this.member._clone();\n      clone._roles = [...this._roles.keys(), roleOrRoles.id];\n      return clone;\n    }\n  }\n\n  /**\n   * Removes a role (or multiple roles) from the member.\n   * @param {RoleResolvable|RoleResolvable[]|Collection<Snowflake, Role>} roleOrRoles The role or roles to remove\n   * @param {string} [reason] Reason for removing the role(s)\n   * @returns {Promise<GuildMember>}\n   */\n  async remove(roleOrRoles, reason) {\n    if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {\n      roleOrRoles = roleOrRoles.map(r => this.guild.roles.resolve(r));\n      if (roleOrRoles.includes(null)) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      const newRoles = this._roles.filter(role => !roleOrRoles.includes(role));\n      return this.set(newRoles, reason);\n    } else {\n      roleOrRoles = this.guild.roles.resolve(roleOrRoles);\n      if (roleOrRoles === null) {\n        throw new TypeError('INVALID_TYPE', 'roles', 'Array or Collection of Roles or Snowflakes', true);\n      }\n\n      await this.client.api.guilds[this.guild.id].members[this.member.id].roles[roleOrRoles.id].delete({ reason });\n\n      const clone = this.member._clone();\n      const newRoles = this._roles.filter(role => role.id !== roleOrRoles.id);\n      clone._roles = [...newRoles.keys()];\n      return clone;\n    }\n  }\n\n  /**\n   * Sets the roles applied to the member.\n   * @param {Collection<Snowflake, Role>|RoleResolvable[]} roles The roles or role IDs to apply\n   * @param {string} [reason] Reason for applying the roles\n   * @returns {Promise<GuildMember>}\n   * @example\n   * // Set the member's roles to a single role\n   * guildMember.roles.set(['391156570408615936'])\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Remove all the roles from a member\n   * guildMember.roles.set([])\n   *   .then(member => console.log(`Member roles is now of ${member.roles.cache.size} size`))\n   *   .catch(console.error);\n   */\n  set(roles, reason) {\n    return this.member.edit({ roles }, reason);\n  }\n\n  clone() {\n    const clone = new this.constructor(this.member);\n    clone.member._roles = [...this._roles.keyArray()];\n    return clone;\n  }\n}\n\nmodule.exports = GuildMemberRoleManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}