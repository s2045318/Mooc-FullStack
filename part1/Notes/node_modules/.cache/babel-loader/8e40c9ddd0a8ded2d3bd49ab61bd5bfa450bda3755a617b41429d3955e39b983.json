{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst Guild = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst GuildMember = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst Role = require('../structures/Role');\nconst {\n  ChannelTypes,\n  Events,\n  VerificationLevels,\n  DefaultMessageNotifications,\n  ExplicitContentFilterLevels\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Permissions = require('../util/Permissions');\nconst {\n  resolveColor\n} = require('../util/Util');\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {BaseManager}\n */\nclass GuildManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, Guild);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {number} [id] The ID for this role, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable|number} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {number|Snowflake} id The Role or User ID for this overwrite\n   * @property {string} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {number} [id] The ID for this channel, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {number} [parentID] The parent ID for this channel\n   * @property {string} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {PartialOverwriteData} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a GuildResolvable to a Guild ID string.\n   * @method resolveID\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveID(guild) {\n    if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {\n      return super.resolveID(guild.guild.id);\n    }\n    return super.resolveID(guild);\n  }\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {string} name The name of the guild\n   * @param {Object} [options] Options for the creating\n   * @param {number} [options.afkChannelID] The ID of the AFK channel\n   * @param {number} [options.afkTimeout] The AFK timeout in seconds\n   * @param {PartialChannelData[]} [options.channels] The channels for this guild\n   * @param {DefaultMessageNotifications} [options.defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @param {ExplicitContentFilterLevel} [options.explicitContentFilter] The explicit content filter level for the guild\n   * @param {BufferResolvable|Base64Resolvable} [options.icon=null] The icon for the guild\n   * @param {string} [options.region] The region for the server, defaults to the closest one available\n   * @param {PartialRoleData[]} [options.roles] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @param {number} [options.systemChannelID] The ID of the system channel\n   * @param {VerificationLevel} [options.verificationLevel] The verification level for the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create(name) {\n    let {\n      afkChannelID,\n      afkTimeout,\n      channels = [],\n      defaultMessageNotifications,\n      explicitContentFilter,\n      icon = null,\n      region,\n      roles = [],\n      systemChannelID,\n      verificationLevel\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    icon = await DataResolver.resolveImage(icon);\n    if (typeof verificationLevel !== 'undefined' && typeof verificationLevel !== 'number') {\n      verificationLevel = VerificationLevels.indexOf(verificationLevel);\n    }\n    if (typeof defaultMessageNotifications !== 'undefined' && typeof defaultMessageNotifications !== 'number') {\n      defaultMessageNotifications = DefaultMessageNotifications.indexOf(defaultMessageNotifications);\n    }\n    if (typeof explicitContentFilter !== 'undefined' && typeof explicitContentFilter !== 'number') {\n      explicitContentFilter = ExplicitContentFilterLevels.indexOf(explicitContentFilter);\n    }\n    for (const channel of channels) {\n      if (channel.type) channel.type = ChannelTypes[channel.type.toUpperCase()];\n      channel.parent_id = channel.parentID;\n      delete channel.parentID;\n      if (!channel.permissionOverwrites) continue;\n      for (const overwrite of channel.permissionOverwrites) {\n        if (overwrite.allow) overwrite.allow = Permissions.resolve(overwrite.allow);\n        if (overwrite.deny) overwrite.deny = Permissions.resolve(overwrite.deny);\n      }\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n    for (const role of roles) {\n      if (role.color) role.color = resolveColor(role.color);\n      if (role.permissions) role.permissions = Permissions.resolve(role.permissions);\n    }\n    return new Promise((resolve, reject) => this.client.api.guilds.post({\n      data: {\n        name,\n        region,\n        icon,\n        verification_level: verificationLevel,\n        default_message_notifications: defaultMessageNotifications,\n        explicit_content_filter: explicitContentFilter,\n        roles,\n        channels,\n        afk_channel_id: afkChannelID,\n        afk_timeout: afkTimeout,\n        system_channel_id: systemChannelID\n      }\n    }).then(data => {\n      if (this.client.guilds.cache.has(data.id)) return resolve(this.client.guilds.cache.get(data.id));\n      const handleGuild = guild => {\n        if (guild.id === data.id) {\n          this.client.clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n          this.client.decrementMaxListeners();\n          resolve(guild);\n        }\n      };\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_CREATE, handleGuild);\n      const timeout = this.client.setTimeout(() => {\n        this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n        this.client.decrementMaxListeners();\n        resolve(this.client.guilds.add(data));\n      }, 10000);\n      return undefined;\n    }, reject));\n  }\n\n  /**\n   * Obtains a guild from Discord, or the guild cache if it's already available.\n   * @param {Snowflake} id ID of the guild\n   * @param {boolean} [cache=true] Whether to cache the new guild object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Guild>}\n   * @example\n   * // Fetch a guild by its id\n   * client.guilds.fetch('222078108977594368')\n   *   .then(guild => console.log(guild.name))\n   *   .catch(console.error);\n   */\n  async fetch(id) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n    const data = await this.client.api.guilds(id).get({\n      query: {\n        with_counts: true\n      }\n    });\n    return this.add(data, cache);\n  }\n}\nmodule.exports = GuildManager;","map":{"version":3,"names":["BaseManager","require","Guild","GuildChannel","GuildEmoji","GuildMember","Invite","Role","ChannelTypes","Events","VerificationLevels","DefaultMessageNotifications","ExplicitContentFilterLevels","DataResolver","Permissions","resolveColor","GuildManager","constructor","client","iterable","resolve","guild","resolveID","id","create","name","afkChannelID","afkTimeout","channels","defaultMessageNotifications","explicitContentFilter","icon","region","roles","systemChannelID","verificationLevel","resolveImage","indexOf","channel","type","toUpperCase","parent_id","parentID","permissionOverwrites","overwrite","allow","deny","permission_overwrites","role","color","permissions","Promise","reject","api","guilds","post","data","verification_level","default_message_notifications","explicit_content_filter","afk_channel_id","afk_timeout","system_channel_id","then","cache","has","get","handleGuild","clearTimeout","timeout","removeListener","GUILD_CREATE","decrementMaxListeners","incrementMaxListeners","on","setTimeout","add","undefined","fetch","force","existing","query","with_counts","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/managers/GuildManager.js"],"sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst Guild = require('../structures/Guild');\nconst GuildChannel = require('../structures/GuildChannel');\nconst GuildEmoji = require('../structures/GuildEmoji');\nconst GuildMember = require('../structures/GuildMember');\nconst Invite = require('../structures/Invite');\nconst Role = require('../structures/Role');\nconst {\n  ChannelTypes,\n  Events,\n  VerificationLevels,\n  DefaultMessageNotifications,\n  ExplicitContentFilterLevels,\n} = require('../util/Constants');\nconst DataResolver = require('../util/DataResolver');\nconst Permissions = require('../util/Permissions');\nconst { resolveColor } = require('../util/Util');\n\n/**\n * Manages API methods for Guilds and stores their cache.\n * @extends {BaseManager}\n */\nclass GuildManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, Guild);\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, Guild>}\n   * @name GuildManager#cache\n   */\n\n  /**\n   * Data that resolves to give a Guild object. This can be:\n   * * A Guild object\n   * * A GuildChannel object\n   * * A GuildEmoji object\n   * * A Role object\n   * * A Snowflake\n   * * An Invite object\n   * @typedef {Guild|GuildChannel|GuildMember|GuildEmoji|Role|Snowflake|Invite} GuildResolvable\n   */\n\n  /**\n   * Partial data for a Role.\n   * @typedef {Object} PartialRoleData\n   * @property {number} [id] The ID for this role, used to set channel overrides,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {string} [name] The name of the role\n   * @property {ColorResolvable} [color] The color of the role, either a hex string or a base 10 number\n   * @property {boolean} [hoist] Whether or not the role should be hoisted\n   * @property {number} [position] The position of the role\n   * @property {PermissionResolvable|number} [permissions] The permissions of the role\n   * @property {boolean} [mentionable] Whether or not the role should be mentionable\n   */\n\n  /**\n   * Partial overwrite data.\n   * @typedef {Object} PartialOverwriteData\n   * @property {number|Snowflake} id The Role or User ID for this overwrite\n   * @property {string} [type] The type of this overwrite\n   * @property {PermissionResolvable} [allow] The permissions to allow\n   * @property {PermissionResolvable} [deny] The permissions to deny\n   */\n\n  /**\n   * Partial data for a Channel.\n   * @typedef {Object} PartialChannelData\n   * @property {number} [id] The ID for this channel, used to set its parent,\n   * this is a placeholder and will be replaced by the API after consumption\n   * @property {number} [parentID] The parent ID for this channel\n   * @property {string} [type] The type of the channel\n   * @property {string} name The name of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the channel\n   * @property {PartialOverwriteData} [permissionOverwrites]\n   * Overwrites of the channel\n   * @property {number} [rateLimitPerUser] The rate limit per user of the channel in seconds\n   */\n\n  /**\n   * Resolves a GuildResolvable to a Guild object.\n   * @method resolve\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Guild}\n   */\n  resolve(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolve(guild.guild);\n    }\n    return super.resolve(guild);\n  }\n\n  /**\n   * Resolves a GuildResolvable to a Guild ID string.\n   * @method resolveID\n   * @memberof GuildManager\n   * @instance\n   * @param {GuildResolvable} guild The guild resolvable to identify\n   * @returns {?Snowflake}\n   */\n  resolveID(guild) {\n    if (\n      guild instanceof GuildChannel ||\n      guild instanceof GuildMember ||\n      guild instanceof GuildEmoji ||\n      guild instanceof Role ||\n      (guild instanceof Invite && guild.guild)\n    ) {\n      return super.resolveID(guild.guild.id);\n    }\n    return super.resolveID(guild);\n  }\n\n  /**\n   * Creates a guild.\n   * <warn>This is only available to bots in fewer than 10 guilds.</warn>\n   * @param {string} name The name of the guild\n   * @param {Object} [options] Options for the creating\n   * @param {number} [options.afkChannelID] The ID of the AFK channel\n   * @param {number} [options.afkTimeout] The AFK timeout in seconds\n   * @param {PartialChannelData[]} [options.channels] The channels for this guild\n   * @param {DefaultMessageNotifications} [options.defaultMessageNotifications] The default message notifications\n   * for the guild\n   * @param {ExplicitContentFilterLevel} [options.explicitContentFilter] The explicit content filter level for the guild\n   * @param {BufferResolvable|Base64Resolvable} [options.icon=null] The icon for the guild\n   * @param {string} [options.region] The region for the server, defaults to the closest one available\n   * @param {PartialRoleData[]} [options.roles] The roles for this guild,\n   * the first element of this array is used to change properties of the guild's everyone role.\n   * @param {number} [options.systemChannelID] The ID of the system channel\n   * @param {VerificationLevel} [options.verificationLevel] The verification level for the guild\n   * @returns {Promise<Guild>} The guild that was created\n   */\n  async create(\n    name,\n    {\n      afkChannelID,\n      afkTimeout,\n      channels = [],\n      defaultMessageNotifications,\n      explicitContentFilter,\n      icon = null,\n      region,\n      roles = [],\n      systemChannelID,\n      verificationLevel,\n    } = {},\n  ) {\n    icon = await DataResolver.resolveImage(icon);\n    if (typeof verificationLevel !== 'undefined' && typeof verificationLevel !== 'number') {\n      verificationLevel = VerificationLevels.indexOf(verificationLevel);\n    }\n    if (typeof defaultMessageNotifications !== 'undefined' && typeof defaultMessageNotifications !== 'number') {\n      defaultMessageNotifications = DefaultMessageNotifications.indexOf(defaultMessageNotifications);\n    }\n    if (typeof explicitContentFilter !== 'undefined' && typeof explicitContentFilter !== 'number') {\n      explicitContentFilter = ExplicitContentFilterLevels.indexOf(explicitContentFilter);\n    }\n    for (const channel of channels) {\n      if (channel.type) channel.type = ChannelTypes[channel.type.toUpperCase()];\n      channel.parent_id = channel.parentID;\n      delete channel.parentID;\n      if (!channel.permissionOverwrites) continue;\n      for (const overwrite of channel.permissionOverwrites) {\n        if (overwrite.allow) overwrite.allow = Permissions.resolve(overwrite.allow);\n        if (overwrite.deny) overwrite.deny = Permissions.resolve(overwrite.deny);\n      }\n      channel.permission_overwrites = channel.permissionOverwrites;\n      delete channel.permissionOverwrites;\n    }\n    for (const role of roles) {\n      if (role.color) role.color = resolveColor(role.color);\n      if (role.permissions) role.permissions = Permissions.resolve(role.permissions);\n    }\n    return new Promise((resolve, reject) =>\n      this.client.api.guilds\n        .post({\n          data: {\n            name,\n            region,\n            icon,\n            verification_level: verificationLevel,\n            default_message_notifications: defaultMessageNotifications,\n            explicit_content_filter: explicitContentFilter,\n            roles,\n            channels,\n            afk_channel_id: afkChannelID,\n            afk_timeout: afkTimeout,\n            system_channel_id: systemChannelID,\n          },\n        })\n        .then(data => {\n          if (this.client.guilds.cache.has(data.id)) return resolve(this.client.guilds.cache.get(data.id));\n\n          const handleGuild = guild => {\n            if (guild.id === data.id) {\n              this.client.clearTimeout(timeout);\n              this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n              this.client.decrementMaxListeners();\n              resolve(guild);\n            }\n          };\n          this.client.incrementMaxListeners();\n          this.client.on(Events.GUILD_CREATE, handleGuild);\n\n          const timeout = this.client.setTimeout(() => {\n            this.client.removeListener(Events.GUILD_CREATE, handleGuild);\n            this.client.decrementMaxListeners();\n            resolve(this.client.guilds.add(data));\n          }, 10000);\n          return undefined;\n        }, reject),\n    );\n  }\n\n  /**\n   * Obtains a guild from Discord, or the guild cache if it's already available.\n   * @param {Snowflake} id ID of the guild\n   * @param {boolean} [cache=true] Whether to cache the new guild object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Guild>}\n   * @example\n   * // Fetch a guild by its id\n   * client.guilds.fetch('222078108977594368')\n   *   .then(guild => console.log(guild.name))\n   *   .catch(console.error);\n   */\n  async fetch(id, cache = true, force = false) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing) return existing;\n    }\n\n    const data = await this.client.api.guilds(id).get({ query: { with_counts: true } });\n    return this.add(data, cache);\n  }\n}\n\nmodule.exports = GuildManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}