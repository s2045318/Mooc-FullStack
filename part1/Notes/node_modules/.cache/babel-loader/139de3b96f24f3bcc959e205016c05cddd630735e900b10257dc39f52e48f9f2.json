{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst WebSocket = require('../../WebSocket');\nconst {\n  browser,\n  Status,\n  Events,\n  ShardEvents,\n  OPCodes,\n  WSEvents\n} = require('../../util/Constants');\nconst STATUS_KEYS = Object.keys(Status);\nconst CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\nlet zlib;\nif (!browser) {\n  try {\n    zlib = require('zlib-sync');\n  } catch {} // eslint-disable-line no-empty\n}\n\n/**\n * Represents a Shard's WebSocket connection\n */\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The ID of the shard\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n    this.status = Status.IDLE;\n\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n    this.sequence = -1;\n\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n    this.closeSequence = 0;\n\n    /**\n     * The current session ID of the shard\n     * @type {?string}\n     * @private\n     */\n    this.sessionID = null;\n\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n    this.ping = -1;\n\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     * @private\n     */\n    this.lastPingTimestamp = -1;\n\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n    this.lastHeartbeatAcked = true;\n\n    /**\n     * Contains the rate limit queue and metadata\n     * @name WebSocketShard#ratelimit\n     * @type {Object}\n     * @private\n     */\n    Object.defineProperty(this, 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null\n      }\n    });\n\n    /**\n     * The WebSocket connection for the current shard\n     * @name WebSocketShard#connection\n     * @type {?WebSocket}\n     * @private\n     */\n    Object.defineProperty(this, 'connection', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @name WebSocketShard#inflate\n     * @type {?Inflate}\n     * @private\n     */\n    Object.defineProperty(this, 'inflate', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * The HELLO timeout\n     * @name WebSocketShard#helloTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'helloTimeout', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * If the manager attached its event handlers on the shard\n     * @name WebSocketShard#eventsAttached\n     * @type {boolean}\n     * @private\n     */\n    Object.defineProperty(this, 'eventsAttached', {\n      value: false,\n      writable: true\n    });\n\n    /**\n     * A set of guild IDs this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n    Object.defineProperty(this, 'expectedGuilds', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'readyTimeout', {\n      value: null,\n      writable: true\n    });\n\n    /**\n     * Time when the WebSocket connection was opened\n     * @name WebSocketShard#connectedAt\n     * @type {number}\n     * @private\n     */\n    Object.defineProperty(this, 'connectedAt', {\n      value: 0,\n      writable: true\n    });\n  }\n\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n  debug(message) {\n    this.manager.debug(message, this);\n  }\n\n  /**\n   * Connects the shard to the gateway.\n   * @private\n   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n   * or reject if we couldn't connect\n   */\n  connect() {\n    const {\n      gateway,\n      client\n    } = this.manager;\n    if (this.connection && this.connection.readyState === WebSocket.OPEN && this.status === Status.READY) {\n      return Promise.resolve();\n    }\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        this.removeListener(ShardEvents.CLOSE, onClose);\n        this.removeListener(ShardEvents.READY, onReady);\n        this.removeListener(ShardEvents.RESUMED, onResumed);\n        this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n        this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n      };\n      const onReady = () => {\n        cleanup();\n        resolve();\n      };\n      const onResumed = () => {\n        cleanup();\n        resolve();\n      };\n      const onClose = event => {\n        cleanup();\n        reject(event);\n      };\n      const onInvalidOrDestroyed = () => {\n        cleanup();\n        // eslint-disable-next-line prefer-promise-reject-errors\n        reject();\n      };\n      this.once(ShardEvents.READY, onReady);\n      this.once(ShardEvents.RESUMED, onResumed);\n      this.once(ShardEvents.CLOSE, onClose);\n      this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n      this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n      if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n        this.debug('An open connection was found, attempting an immediate identify.');\n        this.identify();\n        return;\n      }\n      if (this.connection) {\n        this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        this.destroy({\n          emit: false\n        });\n      }\n      const wsQuery = {\n        v: client.options.ws.version\n      };\n      if (zlib) {\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          flush: zlib.Z_SYNC_FLUSH,\n          to: WebSocket.encoding === 'json' ? 'string' : ''\n        });\n        wsQuery.compress = 'zlib-stream';\n      }\n      this.debug(`[CONNECT]\n    Gateway    : ${gateway}\n    Version    : ${client.options.ws.version}\n    Encoding   : ${WebSocket.encoding}\n    Compression: ${zlib ? 'zlib-stream' : 'none'}`);\n      this.status = this.status === Status.DISCONNECTED ? Status.RECONNECTING : Status.CONNECTING;\n      this.setHelloTimeout();\n      this.connectedAt = Date.now();\n      const ws = this.connection = WebSocket.create(gateway, wsQuery);\n      ws.onopen = this.onOpen.bind(this);\n      ws.onmessage = this.onMessage.bind(this);\n      ws.onerror = this.onError.bind(this);\n      ws.onclose = this.onClose.bind(this);\n    });\n  }\n\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @private\n   */\n  onOpen() {\n    this.debug(`[CONNECTED] ${this.connection.url} in ${Date.now() - this.connectedAt}ms`);\n    this.status = Status.NEARLY;\n  }\n\n  /**\n   * Called whenever a message is received.\n   * @param {MessageEvent} event Event received\n   * @private\n   */\n  onMessage(_ref) {\n    let {\n      data\n    } = _ref;\n    let raw;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n    if (zlib) {\n      const l = data.length;\n      const flush = l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n      if (!flush) return;\n      raw = this.inflate.result;\n    } else {\n      raw = data;\n    }\n    let packet;\n    try {\n      packet = WebSocket.unpack(raw);\n      this.manager.client.emit(Events.RAW, packet, this.id);\n      if (packet.op === OPCodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);\n    } catch (err) {\n      this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n      return;\n    }\n    this.onPacket(packet);\n  }\n\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {ErrorEvent} event The error that occurred\n   * @private\n   */\n  onError(event) {\n    const error = event && event.error ? event.error : event;\n    if (!error) return;\n\n    /**\n     * Emitted whenever a shard's WebSocket encounters a connection error.\n     * @event Client#shardError\n     * @param {Error} error The encountered error\n     * @param {number} shardID The shard that encountered this error\n     */\n    this.manager.client.emit(Events.SHARD_ERROR, error, this.id);\n  }\n\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * @external ErrorEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n   */\n\n  /**\n   * @external MessageEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   * @private\n   */\n  onClose(event) {\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n    this.sequence = -1;\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason || 'No reason received'}`);\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n    // If we still have a connection object, clean up its listeners\n    if (this.connection) this._cleanupConnection();\n    this.status = Status.DISCONNECTED;\n\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n    this.emit(ShardEvents.CLOSE, event);\n  }\n\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet The received packet\n   * @private\n   */\n  onPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n    switch (packet.t) {\n      case WSEvents.READY:\n        /**\n         * Emitted when the shard receives the READY payload and is now waiting for guilds\n         * @event WebSocketShard#ready\n         */\n        this.emit(ShardEvents.READY);\n        this.sessionID = packet.d.session_id;\n        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));\n        this.status = Status.WAITING_FOR_GUILDS;\n        this.debug(`[READY] Session ${this.sessionID}.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ReadyHeartbeat');\n        break;\n      case WSEvents.RESUMED:\n        {\n          /**\n           * Emitted when the shard resumes successfully\n           * @event WebSocketShard#resumed\n           */\n          this.emit(ShardEvents.RESUMED);\n          this.status = Status.READY;\n          const replayed = packet.s - this.closeSequence;\n          this.debug(`[RESUMED] Session ${this.sessionID} | Replayed ${replayed} events.`);\n          this.lastHeartbeatAcked = true;\n          this.sendHeartbeat('ResumeHeartbeat');\n          break;\n        }\n    }\n    if (packet.s > this.sequence) this.sequence = packet.s;\n    switch (packet.op) {\n      case OPCodes.HELLO:\n        this.setHelloTimeout(-1);\n        this.setHeartbeatTimer(packet.d.heartbeat_interval);\n        this.identify();\n        break;\n      case OPCodes.RECONNECT:\n        this.debug('[RECONNECT] Discord asked us to reconnect');\n        this.destroy({\n          closeCode: 4000\n        });\n        break;\n      case OPCodes.INVALID_SESSION:\n        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);\n        // If we can resume the session, do so immediately\n        if (packet.d) {\n          this.identifyResume();\n          return;\n        }\n        // Reset the sequence\n        this.sequence = -1;\n        // Reset the session ID as it's invalid\n        this.sessionID = null;\n        // Set the status to reconnecting\n        this.status = Status.RECONNECTING;\n        // Finally, emit the INVALID_SESSION event\n        this.emit(ShardEvents.INVALID_SESSION);\n        break;\n      case OPCodes.HEARTBEAT_ACK:\n        this.ackHeartbeat();\n        break;\n      case OPCodes.HEARTBEAT:\n        this.sendHeartbeat('HeartbeatRequest', true);\n        break;\n      default:\n        this.manager.handlePacket(packet, this);\n        if (this.status === Status.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {\n          this.expectedGuilds.delete(packet.d.id);\n          this.checkReady();\n        }\n    }\n  }\n\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      this.manager.client.clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    }\n    // Step 1. If we don't have any other guilds pending, we are ready\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.READY;\n\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n      this.emit(ShardEvents.ALL_READY);\n      return;\n    }\n    // Step 2. Create a 15s timeout that will mark the shard as ready if there are still unavailable guilds\n    this.readyTimeout = this.manager.client.setTimeout(() => {\n      this.debug(`Shard did not receive any more guild packets in 15 seconds.\n  Unavailable guild count: ${this.expectedGuilds.size}`);\n      this.readyTimeout = null;\n      this.status = Status.READY;\n      this.emit(ShardEvents.ALL_READY, this.expectedGuilds);\n    }, 15000);\n  }\n\n  /**\n   * Sets the HELLO packet timeout.\n   * @param {number} [time] If set to -1, it will clear the hello timeout timeout\n   * @private\n   */\n  setHelloTimeout(time) {\n    if (time === -1) {\n      if (this.helloTimeout) {\n        this.debug('Clearing the HELLO timeout.');\n        this.manager.client.clearTimeout(this.helloTimeout);\n        this.helloTimeout = null;\n      }\n      return;\n    }\n    this.debug('Setting a HELLO timeout for 20s.');\n    this.helloTimeout = this.manager.client.setTimeout(() => {\n      this.debug('Did not receive HELLO in time. Destroying and connecting again.');\n      this.destroy({\n        reset: true,\n        closeCode: 4009\n      });\n    }, 20000);\n  }\n\n  /**\n   * Sets the heartbeat timer for this shard.\n   * @param {number} time If -1, clears the interval, any other number sets an interval\n   * @private\n   */\n  setHeartbeatTimer(time) {\n    if (time === -1) {\n      if (this.heartbeatInterval) {\n        this.debug('Clearing the heartbeat interval.');\n        this.manager.client.clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n      return;\n    }\n    this.debug(`Setting a heartbeat interval for ${time}ms.`);\n    // Sanity checks\n    if (this.heartbeatInterval) this.manager.client.clearInterval(this.heartbeatInterval);\n    this.heartbeatInterval = this.manager.client.setInterval(() => this.sendHeartbeat(), time);\n  }\n\n  /**\n   * Sends a heartbeat to the WebSocket.\n   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n   * @private\n   */\n  sendHeartbeat() {\n    let tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'HeartbeatTimer';\n    let ignoreHeartbeatAck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [Status.WAITING_FOR_GUILDS, Status.IDENTIFYING, Status.RESUMING].includes(this.status);\n    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);\n    } else if (!this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${STATUS_KEYS[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`);\n      this.destroy({\n        closeCode: 4009,\n        reset: true\n      });\n      return;\n    }\n    this.debug(`[${tag}] Sending a heartbeat.`);\n    this.lastHeartbeatAcked = false;\n    this.lastPingTimestamp = Date.now();\n    this.send({\n      op: OPCodes.HEARTBEAT,\n      d: this.sequence\n    }, true);\n  }\n\n  /**\n   * Acknowledges a heartbeat.\n   * @private\n   */\n  ackHeartbeat() {\n    this.lastHeartbeatAcked = true;\n    const latency = Date.now() - this.lastPingTimestamp;\n    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);\n    this.ping = latency;\n  }\n\n  /**\n   * Identifies the client on the connection.\n   * @private\n   * @returns {void}\n   */\n  identify() {\n    return this.sessionID ? this.identifyResume() : this.identifyNew();\n  }\n\n  /**\n   * Identifies as a new connection on the gateway.\n   * @private\n   */\n  identifyNew() {\n    const {\n      client\n    } = this.manager;\n    if (!client.token) {\n      this.debug('[IDENTIFY] No token available to identify a new session.');\n      return;\n    }\n    this.status = Status.IDENTIFYING;\n\n    // Clone the identify payload and assign the token and shard info\n    const d = {\n      ...client.options.ws,\n      token: client.token,\n      shard: [this.id, Number(client.options.shardCount)]\n    };\n    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount}`);\n    this.send({\n      op: OPCodes.IDENTIFY,\n      d\n    }, true);\n  }\n\n  /**\n   * Resumes a session on the gateway.\n   * @private\n   */\n  identifyResume() {\n    if (!this.sessionID) {\n      this.debug('[RESUME] No session ID was present; identifying as a new session.');\n      this.identifyNew();\n      return;\n    }\n    this.status = Status.RESUMING;\n    this.debug(`[RESUME] Session ${this.sessionID}, sequence ${this.closeSequence}`);\n    const d = {\n      token: this.manager.client.token,\n      session_id: this.sessionID,\n      seq: this.closeSequence\n    };\n    this.send({\n      op: OPCodes.RESUME,\n      d\n    }, true);\n  }\n\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   */\n  send(data) {\n    let important = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n    this.processQueue();\n  }\n\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   * @private\n   */\n  _send(data) {\n    if (!this.connection || this.connection.readyState !== WebSocket.OPEN) {\n      this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);\n      this.destroy({\n        close: 4000\n      });\n      return;\n    }\n    this.connection.send(WebSocket.pack(data), err => {\n      if (err) this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n    });\n  }\n\n  /**\n   * Processes the current WebSocket queue.\n   * @returns {void}\n   * @private\n   */\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.timer = this.manager.client.setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time);\n    }\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n      this._send(item);\n      this.ratelimit.remaining--;\n    }\n  }\n\n  /**\n   * Destroys this shard and closes its WebSocket connection.\n   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n   * @private\n   */\n  destroy() {\n    let {\n      closeCode = 1000,\n      reset = false,\n      emit = true,\n      log = true\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (log) {\n      this.debug(`[DESTROY]\n    Close Code    : ${closeCode}\n    Reset         : ${reset}\n    Emit DESTROYED: ${emit}`);\n    }\n\n    // Step 0: Remove all timers\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n\n    // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n    if (this.connection) {\n      // If the connection is currently opened, we will (hopefully) receive close\n      if (this.connection.readyState === WebSocket.OPEN) {\n        this.connection.close(closeCode);\n      } else {\n        // Connection is not OPEN\n        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        // Remove listeners from the connection\n        this._cleanupConnection();\n        // Attempt to close the connection just in case\n        try {\n          this.connection.close(closeCode);\n        } catch {\n          // No-op\n        }\n        // Emit the destroyed event if needed\n        if (emit) this._emitDestroyed();\n      }\n    } else if (emit) {\n      // We requested a destroy, but we had no connection. Emit destroyed\n      this._emitDestroyed();\n    }\n\n    // Step 2: Null the connection object\n    this.connection = null;\n\n    // Step 3: Set the shard status to DISCONNECTED\n    this.status = Status.DISCONNECTED;\n\n    // Step 4: Cache the old sequence (use to attempt a resume)\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n\n    // Step 5: Reset the sequence and session ID if requested\n    if (reset) {\n      this.sequence = -1;\n      this.sessionID = null;\n    }\n\n    // Step 6: reset the ratelimit data\n    this.ratelimit.remaining = this.ratelimit.total;\n    this.ratelimit.queue.length = 0;\n    if (this.ratelimit.timer) {\n      this.manager.client.clearTimeout(this.ratelimit.timer);\n      this.ratelimit.timer = null;\n    }\n  }\n\n  /**\n   * Cleans up the WebSocket connection listeners.\n   * @private\n   */\n  _cleanupConnection() {\n    this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;\n  }\n\n  /**\n   * Emits the DESTROYED event on the shard\n   * @private\n   */\n  _emitDestroyed() {\n    /**\n     * Emitted when a shard is destroyed, but no WebSocket connection was present.\n     * @private\n     * @event WebSocketShard#destroyed\n     */\n    this.emit(ShardEvents.DESTROYED);\n  }\n}\nmodule.exports = WebSocketShard;","map":{"version":3,"names":["EventEmitter","require","WebSocket","browser","Status","Events","ShardEvents","OPCodes","WSEvents","STATUS_KEYS","Object","keys","CONNECTION_STATE","zlib","WebSocketShard","constructor","manager","id","status","IDLE","sequence","closeSequence","sessionID","ping","lastPingTimestamp","lastHeartbeatAcked","defineProperty","value","queue","total","remaining","time","timer","writable","debug","message","connect","gateway","client","connection","readyState","OPEN","READY","Promise","resolve","reject","cleanup","removeListener","CLOSE","onClose","onReady","RESUMED","onResumed","INVALID_SESSION","onInvalidOrDestroyed","DESTROYED","event","once","identify","destroy","emit","wsQuery","v","options","ws","version","inflate","Inflate","chunkSize","flush","Z_SYNC_FLUSH","to","encoding","compress","DISCONNECTED","RECONNECTING","CONNECTING","setHelloTimeout","connectedAt","Date","now","create","onopen","onOpen","bind","onmessage","onMessage","onerror","onError","onclose","url","NEARLY","data","raw","ArrayBuffer","Uint8Array","l","length","push","result","packet","unpack","RAW","op","DISPATCH","t","d","err","SHARD_ERROR","onPacket","error","code","wasClean","reason","setHeartbeatTimer","_cleanupConnection","session_id","expectedGuilds","Set","guilds","map","WAITING_FOR_GUILDS","sendHeartbeat","replayed","s","HELLO","heartbeat_interval","RECONNECT","closeCode","identifyResume","HEARTBEAT_ACK","ackHeartbeat","HEARTBEAT","handlePacket","GUILD_CREATE","delete","checkReady","readyTimeout","clearTimeout","size","ALL_READY","setTimeout","helloTimeout","reset","heartbeatInterval","clearInterval","setInterval","tag","ignoreHeartbeatAck","IDENTIFYING","RESUMING","includes","send","latency","identifyNew","token","shard","Number","shardCount","IDENTIFY","seq","RESUME","important","ratelimit","processQueue","_send","JSON","stringify","close","pack","item","shift","log","_emitDestroyed","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/client/websocket/WebSocketShard.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst WebSocket = require('../../WebSocket');\nconst { browser, Status, Events, ShardEvents, OPCodes, WSEvents } = require('../../util/Constants');\n\nconst STATUS_KEYS = Object.keys(Status);\nconst CONNECTION_STATE = Object.keys(WebSocket.WebSocket);\n\nlet zlib;\n\nif (!browser) {\n  try {\n    zlib = require('zlib-sync');\n  } catch {} // eslint-disable-line no-empty\n}\n\n/**\n * Represents a Shard's WebSocket connection\n */\nclass WebSocketShard extends EventEmitter {\n  constructor(manager, id) {\n    super();\n\n    /**\n     * The WebSocketManager of the shard\n     * @type {WebSocketManager}\n     */\n    this.manager = manager;\n\n    /**\n     * The ID of the shard\n     * @type {number}\n     */\n    this.id = id;\n\n    /**\n     * The current status of the shard\n     * @type {Status}\n     */\n    this.status = Status.IDLE;\n\n    /**\n     * The current sequence of the shard\n     * @type {number}\n     * @private\n     */\n    this.sequence = -1;\n\n    /**\n     * The sequence of the shard after close\n     * @type {number}\n     * @private\n     */\n    this.closeSequence = 0;\n\n    /**\n     * The current session ID of the shard\n     * @type {?string}\n     * @private\n     */\n    this.sessionID = null;\n\n    /**\n     * The previous heartbeat ping of the shard\n     * @type {number}\n     */\n    this.ping = -1;\n\n    /**\n     * The last time a ping was sent (a timestamp)\n     * @type {number}\n     * @private\n     */\n    this.lastPingTimestamp = -1;\n\n    /**\n     * If we received a heartbeat ack back. Used to identify zombie connections\n     * @type {boolean}\n     * @private\n     */\n    this.lastHeartbeatAcked = true;\n\n    /**\n     * Contains the rate limit queue and metadata\n     * @name WebSocketShard#ratelimit\n     * @type {Object}\n     * @private\n     */\n    Object.defineProperty(this, 'ratelimit', {\n      value: {\n        queue: [],\n        total: 120,\n        remaining: 120,\n        time: 60e3,\n        timer: null,\n      },\n    });\n\n    /**\n     * The WebSocket connection for the current shard\n     * @name WebSocketShard#connection\n     * @type {?WebSocket}\n     * @private\n     */\n    Object.defineProperty(this, 'connection', { value: null, writable: true });\n\n    /**\n     * @external Inflate\n     * @see {@link https://www.npmjs.com/package/zlib-sync}\n     */\n\n    /**\n     * The compression to use\n     * @name WebSocketShard#inflate\n     * @type {?Inflate}\n     * @private\n     */\n    Object.defineProperty(this, 'inflate', { value: null, writable: true });\n\n    /**\n     * The HELLO timeout\n     * @name WebSocketShard#helloTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'helloTimeout', { value: null, writable: true });\n\n    /**\n     * If the manager attached its event handlers on the shard\n     * @name WebSocketShard#eventsAttached\n     * @type {boolean}\n     * @private\n     */\n    Object.defineProperty(this, 'eventsAttached', { value: false, writable: true });\n\n    /**\n     * A set of guild IDs this shard expects to receive\n     * @name WebSocketShard#expectedGuilds\n     * @type {?Set<string>}\n     * @private\n     */\n    Object.defineProperty(this, 'expectedGuilds', { value: null, writable: true });\n\n    /**\n     * The ready timeout\n     * @name WebSocketShard#readyTimeout\n     * @type {?NodeJS.Timeout}\n     * @private\n     */\n    Object.defineProperty(this, 'readyTimeout', { value: null, writable: true });\n\n    /**\n     * Time when the WebSocket connection was opened\n     * @name WebSocketShard#connectedAt\n     * @type {number}\n     * @private\n     */\n    Object.defineProperty(this, 'connectedAt', { value: 0, writable: true });\n  }\n\n  /**\n   * Emits a debug event.\n   * @param {string} message The debug message\n   * @private\n   */\n  debug(message) {\n    this.manager.debug(message, this);\n  }\n\n  /**\n   * Connects the shard to the gateway.\n   * @private\n   * @returns {Promise<void>} A promise that will resolve if the shard turns ready successfully,\n   * or reject if we couldn't connect\n   */\n  connect() {\n    const { gateway, client } = this.manager;\n\n    if (this.connection && this.connection.readyState === WebSocket.OPEN && this.status === Status.READY) {\n      return Promise.resolve();\n    }\n\n    return new Promise((resolve, reject) => {\n      const cleanup = () => {\n        this.removeListener(ShardEvents.CLOSE, onClose);\n        this.removeListener(ShardEvents.READY, onReady);\n        this.removeListener(ShardEvents.RESUMED, onResumed);\n        this.removeListener(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n        this.removeListener(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n      };\n\n      const onReady = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onResumed = () => {\n        cleanup();\n        resolve();\n      };\n\n      const onClose = event => {\n        cleanup();\n        reject(event);\n      };\n\n      const onInvalidOrDestroyed = () => {\n        cleanup();\n        // eslint-disable-next-line prefer-promise-reject-errors\n        reject();\n      };\n\n      this.once(ShardEvents.READY, onReady);\n      this.once(ShardEvents.RESUMED, onResumed);\n      this.once(ShardEvents.CLOSE, onClose);\n      this.once(ShardEvents.INVALID_SESSION, onInvalidOrDestroyed);\n      this.once(ShardEvents.DESTROYED, onInvalidOrDestroyed);\n\n      if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n        this.debug('An open connection was found, attempting an immediate identify.');\n        this.identify();\n        return;\n      }\n\n      if (this.connection) {\n        this.debug(`A connection object was found. Cleaning up before continuing.\n    State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        this.destroy({ emit: false });\n      }\n\n      const wsQuery = { v: client.options.ws.version };\n\n      if (zlib) {\n        this.inflate = new zlib.Inflate({\n          chunkSize: 65535,\n          flush: zlib.Z_SYNC_FLUSH,\n          to: WebSocket.encoding === 'json' ? 'string' : '',\n        });\n        wsQuery.compress = 'zlib-stream';\n      }\n\n      this.debug(\n        `[CONNECT]\n    Gateway    : ${gateway}\n    Version    : ${client.options.ws.version}\n    Encoding   : ${WebSocket.encoding}\n    Compression: ${zlib ? 'zlib-stream' : 'none'}`,\n      );\n\n      this.status = this.status === Status.DISCONNECTED ? Status.RECONNECTING : Status.CONNECTING;\n      this.setHelloTimeout();\n\n      this.connectedAt = Date.now();\n\n      const ws = (this.connection = WebSocket.create(gateway, wsQuery));\n      ws.onopen = this.onOpen.bind(this);\n      ws.onmessage = this.onMessage.bind(this);\n      ws.onerror = this.onError.bind(this);\n      ws.onclose = this.onClose.bind(this);\n    });\n  }\n\n  /**\n   * Called whenever a connection is opened to the gateway.\n   * @private\n   */\n  onOpen() {\n    this.debug(`[CONNECTED] ${this.connection.url} in ${Date.now() - this.connectedAt}ms`);\n    this.status = Status.NEARLY;\n  }\n\n  /**\n   * Called whenever a message is received.\n   * @param {MessageEvent} event Event received\n   * @private\n   */\n  onMessage({ data }) {\n    let raw;\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n    if (zlib) {\n      const l = data.length;\n      const flush =\n        l >= 4 && data[l - 4] === 0x00 && data[l - 3] === 0x00 && data[l - 2] === 0xff && data[l - 1] === 0xff;\n\n      this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);\n      if (!flush) return;\n      raw = this.inflate.result;\n    } else {\n      raw = data;\n    }\n    let packet;\n    try {\n      packet = WebSocket.unpack(raw);\n      this.manager.client.emit(Events.RAW, packet, this.id);\n      if (packet.op === OPCodes.DISPATCH) this.manager.emit(packet.t, packet.d, this.id);\n    } catch (err) {\n      this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n      return;\n    }\n    this.onPacket(packet);\n  }\n\n  /**\n   * Called whenever an error occurs with the WebSocket.\n   * @param {ErrorEvent} event The error that occurred\n   * @private\n   */\n  onError(event) {\n    const error = event && event.error ? event.error : event;\n    if (!error) return;\n\n    /**\n     * Emitted whenever a shard's WebSocket encounters a connection error.\n     * @event Client#shardError\n     * @param {Error} error The encountered error\n     * @param {number} shardID The shard that encountered this error\n     */\n    this.manager.client.emit(Events.SHARD_ERROR, error, this.id);\n  }\n\n  /**\n   * @external CloseEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\n   */\n\n  /**\n   * @external ErrorEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent}\n   */\n\n  /**\n   * @external MessageEvent\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n   */\n\n  /**\n   * Called whenever a connection to the gateway is closed.\n   * @param {CloseEvent} event Close event that was received\n   * @private\n   */\n  onClose(event) {\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n    this.sequence = -1;\n\n    this.debug(`[CLOSE]\n    Event Code: ${event.code}\n    Clean     : ${event.wasClean}\n    Reason    : ${event.reason || 'No reason received'}`);\n\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n    // If we still have a connection object, clean up its listeners\n    if (this.connection) this._cleanupConnection();\n\n    this.status = Status.DISCONNECTED;\n\n    /**\n     * Emitted when a shard's WebSocket closes.\n     * @private\n     * @event WebSocketShard#close\n     * @param {CloseEvent} event The received event\n     */\n    this.emit(ShardEvents.CLOSE, event);\n  }\n\n  /**\n   * Called whenever a packet is received.\n   * @param {Object} packet The received packet\n   * @private\n   */\n  onPacket(packet) {\n    if (!packet) {\n      this.debug(`Received broken packet: '${packet}'.`);\n      return;\n    }\n\n    switch (packet.t) {\n      case WSEvents.READY:\n        /**\n         * Emitted when the shard receives the READY payload and is now waiting for guilds\n         * @event WebSocketShard#ready\n         */\n        this.emit(ShardEvents.READY);\n\n        this.sessionID = packet.d.session_id;\n        this.expectedGuilds = new Set(packet.d.guilds.map(d => d.id));\n        this.status = Status.WAITING_FOR_GUILDS;\n        this.debug(`[READY] Session ${this.sessionID}.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ReadyHeartbeat');\n        break;\n      case WSEvents.RESUMED: {\n        /**\n         * Emitted when the shard resumes successfully\n         * @event WebSocketShard#resumed\n         */\n        this.emit(ShardEvents.RESUMED);\n\n        this.status = Status.READY;\n        const replayed = packet.s - this.closeSequence;\n        this.debug(`[RESUMED] Session ${this.sessionID} | Replayed ${replayed} events.`);\n        this.lastHeartbeatAcked = true;\n        this.sendHeartbeat('ResumeHeartbeat');\n        break;\n      }\n    }\n\n    if (packet.s > this.sequence) this.sequence = packet.s;\n\n    switch (packet.op) {\n      case OPCodes.HELLO:\n        this.setHelloTimeout(-1);\n        this.setHeartbeatTimer(packet.d.heartbeat_interval);\n        this.identify();\n        break;\n      case OPCodes.RECONNECT:\n        this.debug('[RECONNECT] Discord asked us to reconnect');\n        this.destroy({ closeCode: 4000 });\n        break;\n      case OPCodes.INVALID_SESSION:\n        this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);\n        // If we can resume the session, do so immediately\n        if (packet.d) {\n          this.identifyResume();\n          return;\n        }\n        // Reset the sequence\n        this.sequence = -1;\n        // Reset the session ID as it's invalid\n        this.sessionID = null;\n        // Set the status to reconnecting\n        this.status = Status.RECONNECTING;\n        // Finally, emit the INVALID_SESSION event\n        this.emit(ShardEvents.INVALID_SESSION);\n        break;\n      case OPCodes.HEARTBEAT_ACK:\n        this.ackHeartbeat();\n        break;\n      case OPCodes.HEARTBEAT:\n        this.sendHeartbeat('HeartbeatRequest', true);\n        break;\n      default:\n        this.manager.handlePacket(packet, this);\n        if (this.status === Status.WAITING_FOR_GUILDS && packet.t === WSEvents.GUILD_CREATE) {\n          this.expectedGuilds.delete(packet.d.id);\n          this.checkReady();\n        }\n    }\n  }\n\n  /**\n   * Checks if the shard can be marked as ready\n   * @private\n   */\n  checkReady() {\n    // Step 0. Clear the ready timeout, if it exists\n    if (this.readyTimeout) {\n      this.manager.client.clearTimeout(this.readyTimeout);\n      this.readyTimeout = null;\n    }\n    // Step 1. If we don't have any other guilds pending, we are ready\n    if (!this.expectedGuilds.size) {\n      this.debug('Shard received all its guilds. Marking as fully ready.');\n      this.status = Status.READY;\n\n      /**\n       * Emitted when the shard is fully ready.\n       * This event is emitted if:\n       * * all guilds were received by this shard\n       * * the ready timeout expired, and some guilds are unavailable\n       * @event WebSocketShard#allReady\n       * @param {?Set<string>} unavailableGuilds Set of unavailable guilds, if any\n       */\n      this.emit(ShardEvents.ALL_READY);\n      return;\n    }\n    // Step 2. Create a 15s timeout that will mark the shard as ready if there are still unavailable guilds\n    this.readyTimeout = this.manager.client.setTimeout(() => {\n      this.debug(`Shard did not receive any more guild packets in 15 seconds.\n  Unavailable guild count: ${this.expectedGuilds.size}`);\n\n      this.readyTimeout = null;\n\n      this.status = Status.READY;\n\n      this.emit(ShardEvents.ALL_READY, this.expectedGuilds);\n    }, 15000);\n  }\n\n  /**\n   * Sets the HELLO packet timeout.\n   * @param {number} [time] If set to -1, it will clear the hello timeout timeout\n   * @private\n   */\n  setHelloTimeout(time) {\n    if (time === -1) {\n      if (this.helloTimeout) {\n        this.debug('Clearing the HELLO timeout.');\n        this.manager.client.clearTimeout(this.helloTimeout);\n        this.helloTimeout = null;\n      }\n      return;\n    }\n    this.debug('Setting a HELLO timeout for 20s.');\n    this.helloTimeout = this.manager.client.setTimeout(() => {\n      this.debug('Did not receive HELLO in time. Destroying and connecting again.');\n      this.destroy({ reset: true, closeCode: 4009 });\n    }, 20000);\n  }\n\n  /**\n   * Sets the heartbeat timer for this shard.\n   * @param {number} time If -1, clears the interval, any other number sets an interval\n   * @private\n   */\n  setHeartbeatTimer(time) {\n    if (time === -1) {\n      if (this.heartbeatInterval) {\n        this.debug('Clearing the heartbeat interval.');\n        this.manager.client.clearInterval(this.heartbeatInterval);\n        this.heartbeatInterval = null;\n      }\n      return;\n    }\n    this.debug(`Setting a heartbeat interval for ${time}ms.`);\n    // Sanity checks\n    if (this.heartbeatInterval) this.manager.client.clearInterval(this.heartbeatInterval);\n    this.heartbeatInterval = this.manager.client.setInterval(() => this.sendHeartbeat(), time);\n  }\n\n  /**\n   * Sends a heartbeat to the WebSocket.\n   * If this shard didn't receive a heartbeat last time, it will destroy it and reconnect\n   * @param {string} [tag='HeartbeatTimer'] What caused this heartbeat to be sent\n   * @param {boolean} [ignoreHeartbeatAck] If we should send the heartbeat forcefully.\n   * @private\n   */\n  sendHeartbeat(\n    tag = 'HeartbeatTimer',\n    ignoreHeartbeatAck = [Status.WAITING_FOR_GUILDS, Status.IDENTIFYING, Status.RESUMING].includes(this.status),\n  ) {\n    if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {\n      this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);\n    } else if (!this.lastHeartbeatAcked) {\n      this.debug(\n        `[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.\n    Status          : ${STATUS_KEYS[this.status]}\n    Sequence        : ${this.sequence}\n    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : 'No Connection??'}`,\n      );\n\n      this.destroy({ closeCode: 4009, reset: true });\n      return;\n    }\n\n    this.debug(`[${tag}] Sending a heartbeat.`);\n    this.lastHeartbeatAcked = false;\n    this.lastPingTimestamp = Date.now();\n    this.send({ op: OPCodes.HEARTBEAT, d: this.sequence }, true);\n  }\n\n  /**\n   * Acknowledges a heartbeat.\n   * @private\n   */\n  ackHeartbeat() {\n    this.lastHeartbeatAcked = true;\n    const latency = Date.now() - this.lastPingTimestamp;\n    this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);\n    this.ping = latency;\n  }\n\n  /**\n   * Identifies the client on the connection.\n   * @private\n   * @returns {void}\n   */\n  identify() {\n    return this.sessionID ? this.identifyResume() : this.identifyNew();\n  }\n\n  /**\n   * Identifies as a new connection on the gateway.\n   * @private\n   */\n  identifyNew() {\n    const { client } = this.manager;\n    if (!client.token) {\n      this.debug('[IDENTIFY] No token available to identify a new session.');\n      return;\n    }\n\n    this.status = Status.IDENTIFYING;\n\n    // Clone the identify payload and assign the token and shard info\n    const d = {\n      ...client.options.ws,\n      token: client.token,\n      shard: [this.id, Number(client.options.shardCount)],\n    };\n\n    this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount}`);\n    this.send({ op: OPCodes.IDENTIFY, d }, true);\n  }\n\n  /**\n   * Resumes a session on the gateway.\n   * @private\n   */\n  identifyResume() {\n    if (!this.sessionID) {\n      this.debug('[RESUME] No session ID was present; identifying as a new session.');\n      this.identifyNew();\n      return;\n    }\n\n    this.status = Status.RESUMING;\n\n    this.debug(`[RESUME] Session ${this.sessionID}, sequence ${this.closeSequence}`);\n\n    const d = {\n      token: this.manager.client.token,\n      session_id: this.sessionID,\n      seq: this.closeSequence,\n    };\n\n    this.send({ op: OPCodes.RESUME, d }, true);\n  }\n\n  /**\n   * Adds a packet to the queue to be sent to the gateway.\n   * <warn>If you use this method, make sure you understand that you need to provide\n   * a full [Payload](https://discord.com/developers/docs/topics/gateway#commands-and-events-gateway-commands).\n   * Do not use this method if you don't know what you're doing.</warn>\n   * @param {Object} data The full packet to send\n   * @param {boolean} [important=false] If this packet should be added first in queue\n   */\n  send(data, important = false) {\n    this.ratelimit.queue[important ? 'unshift' : 'push'](data);\n    this.processQueue();\n  }\n\n  /**\n   * Sends data, bypassing the queue.\n   * @param {Object} data Packet to send\n   * @returns {void}\n   * @private\n   */\n  _send(data) {\n    if (!this.connection || this.connection.readyState !== WebSocket.OPEN) {\n      this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);\n      this.destroy({ close: 4000 });\n      return;\n    }\n\n    this.connection.send(WebSocket.pack(data), err => {\n      if (err) this.manager.client.emit(Events.SHARD_ERROR, err, this.id);\n    });\n  }\n\n  /**\n   * Processes the current WebSocket queue.\n   * @returns {void}\n   * @private\n   */\n  processQueue() {\n    if (this.ratelimit.remaining === 0) return;\n    if (this.ratelimit.queue.length === 0) return;\n    if (this.ratelimit.remaining === this.ratelimit.total) {\n      this.ratelimit.timer = this.manager.client.setTimeout(() => {\n        this.ratelimit.remaining = this.ratelimit.total;\n        this.processQueue();\n      }, this.ratelimit.time);\n    }\n    while (this.ratelimit.remaining > 0) {\n      const item = this.ratelimit.queue.shift();\n      if (!item) return;\n      this._send(item);\n      this.ratelimit.remaining--;\n    }\n  }\n\n  /**\n   * Destroys this shard and closes its WebSocket connection.\n   * @param {Object} [options={ closeCode: 1000, reset: false, emit: true, log: true }] Options for destroying the shard\n   * @private\n   */\n  destroy({ closeCode = 1000, reset = false, emit = true, log = true } = {}) {\n    if (log) {\n      this.debug(`[DESTROY]\n    Close Code    : ${closeCode}\n    Reset         : ${reset}\n    Emit DESTROYED: ${emit}`);\n    }\n\n    // Step 0: Remove all timers\n    this.setHeartbeatTimer(-1);\n    this.setHelloTimeout(-1);\n\n    // Step 1: Close the WebSocket connection, if any, otherwise, emit DESTROYED\n    if (this.connection) {\n      // If the connection is currently opened, we will (hopefully) receive close\n      if (this.connection.readyState === WebSocket.OPEN) {\n        this.connection.close(closeCode);\n      } else {\n        // Connection is not OPEN\n        this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);\n        // Remove listeners from the connection\n        this._cleanupConnection();\n        // Attempt to close the connection just in case\n        try {\n          this.connection.close(closeCode);\n        } catch {\n          // No-op\n        }\n        // Emit the destroyed event if needed\n        if (emit) this._emitDestroyed();\n      }\n    } else if (emit) {\n      // We requested a destroy, but we had no connection. Emit destroyed\n      this._emitDestroyed();\n    }\n\n    // Step 2: Null the connection object\n    this.connection = null;\n\n    // Step 3: Set the shard status to DISCONNECTED\n    this.status = Status.DISCONNECTED;\n\n    // Step 4: Cache the old sequence (use to attempt a resume)\n    if (this.sequence !== -1) this.closeSequence = this.sequence;\n\n    // Step 5: Reset the sequence and session ID if requested\n    if (reset) {\n      this.sequence = -1;\n      this.sessionID = null;\n    }\n\n    // Step 6: reset the ratelimit data\n    this.ratelimit.remaining = this.ratelimit.total;\n    this.ratelimit.queue.length = 0;\n    if (this.ratelimit.timer) {\n      this.manager.client.clearTimeout(this.ratelimit.timer);\n      this.ratelimit.timer = null;\n    }\n  }\n\n  /**\n   * Cleans up the WebSocket connection listeners.\n   * @private\n   */\n  _cleanupConnection() {\n    this.connection.onopen = this.connection.onclose = this.connection.onerror = this.connection.onmessage = null;\n  }\n\n  /**\n   * Emits the DESTROYED event on the shard\n   * @private\n   */\n  _emitDestroyed() {\n    /**\n     * Emitted when a shard is destroyed, but no WebSocket connection was present.\n     * @private\n     * @event WebSocketShard#destroyed\n     */\n    this.emit(ShardEvents.DESTROYED);\n  }\n}\n\nmodule.exports = WebSocketShard;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}