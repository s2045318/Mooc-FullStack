{"ast":null,"code":"'use strict';\n\nconst Channel = require('./Channel');\nconst Invite = require('./Invite');\nconst PermissionOverwrites = require('./PermissionOverwrites');\nconst Role = require('./Role');\nconst {\n  Error,\n  TypeError\n} = require('../errors');\nconst Collection = require('../util/Collection');\nconst Permissions = require('../util/Permissions');\nconst Util = require('../util/Util');\n\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StoreChannel}\n * @extends {Channel}\n * @abstract\n */\nclass GuildChannel extends Channel {\n  /**\n   * @param {Guild} guild The guild the guild channel is part of\n   * @param {Object} data The data for the guild channel\n   */\n  constructor(guild, data) {\n    super(guild.client, data);\n\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n  _patch(data) {\n    super._patch(data);\n\n    /**\n     * The name of the guild channel\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The raw position of the channel from discord\n     * @type {number}\n     */\n    this.rawPosition = data.position;\n\n    /**\n     * The ID of the category parent of this channel\n     * @type {?Snowflake}\n     */\n    this.parentID = data.parent_id || null;\n\n    /**\n     * A map of permission overwrites in this channel for roles and users\n     * @type {Collection<Snowflake, PermissionOverwrites>}\n     */\n    this.permissionOverwrites = new Collection();\n    if (data.permission_overwrites) {\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));\n      }\n    }\n  }\n\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.cache.get(this.parentID) || null;\n  }\n\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n  get permissionsLocked() {\n    if (!this.parent) return null;\n    if (this.permissionOverwrites.size !== this.parent.permissionOverwrites.size) return false;\n    return this.permissionOverwrites.every((value, key) => {\n      const testVal = this.parent.permissionOverwrites.get(key);\n      return testVal !== undefined && testVal.deny.bitfield === value.deny.bitfield && testVal.allow.bitfield === value.allow.bitfield;\n    });\n  }\n\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedChannels(this);\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @returns {?Readonly<Permissions>}\n   */\n  permissionsFor(memberOrRole) {\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member);\n    const role = this.guild.roles.resolve(memberOrRole);\n    if (role) return this.rolePermissions(role);\n    return null;\n  }\n  overwritesFor(member) {\n    let verified = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let roles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n    roles = roles || member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n    for (const overwrite of this.permissionOverwrites.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites\n    };\n  }\n\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  memberPermissions(member) {\n    if (member.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n    const roles = member.roles.cache;\n    const permissions = new Permissions(roles.map(role => role.permissions));\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n    const overwrites = this.overwritesFor(member, true, roles);\n    return permissions.remove(overwrites.everyone ? overwrites.everyone.deny : 0).add(overwrites.everyone ? overwrites.everyone.allow : 0).remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : 0).add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : 0).remove(overwrites.member ? overwrites.member.deny : 0).add(overwrites.member ? overwrites.member.allow : 0).freeze();\n  }\n\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  rolePermissions(role) {\n    if (role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n    const everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.get(role.id);\n    return role.permissions.remove(everyoneOverwrites ? everyoneOverwrites.deny : 0).add(everyoneOverwrites ? everyoneOverwrites.allow : 0).remove(roleOverwrites ? roleOverwrites.deny : 0).add(roleOverwrites ? roleOverwrites.allow : 0).freeze();\n  }\n\n  /**\n   * Replaces the permission overwrites in this channel.\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites\n   * Permission overwrites the channel gets updated with\n   * @param {string} [reason] Reason for updating the channel overwrites\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * channel.overwritePermissions([\n   *   {\n   *      id: message.author.id,\n   *      deny: ['VIEW_CHANNEL'],\n   *   },\n   * ], 'Needed to change permissions');\n   */\n  overwritePermissions(overwrites, reason) {\n    if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {\n      return Promise.reject(new TypeError('INVALID_TYPE', 'overwrites', 'Array or Collection of Permission Overwrites', true));\n    }\n    return this.edit({\n      permissionOverwrites: overwrites,\n      reason\n    }).then(() => this);\n  }\n\n  /**\n   * Updates Overwrites for a user or role in this channel. (creates if non-existent)\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {string} [reason] Reason for creating/editing this overwrite\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Update or Create permission overwrites for a message author\n   * message.channel.updateOverwrite(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  updateOverwrite(userOrRole, options, reason) {\n    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));\n    const existing = this.permissionOverwrites.get(userOrRole.id);\n    if (existing) return existing.update(options, reason).then(() => this);\n    return this.createOverwrite(userOrRole, options, reason);\n  }\n\n  /**\n   * Overwrites the permissions for a user or role in this channel. (replaces if existent)\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {string} [reason] Reason for creating/editing this overwrite\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create or Replace permissions overwrites for a message author\n   * message.channel.createOverwrite(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  createOverwrite(userOrRole, options, reason) {\n    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));\n    const type = userOrRole instanceof Role ? 'role' : 'member';\n    const {\n      allow,\n      deny\n    } = PermissionOverwrites.resolveOverwriteOptions(options);\n    return this.client.api.channels(this.id).permissions[userOrRole.id].put({\n      data: {\n        id: userOrRole.id,\n        type,\n        allow: allow.bitfield,\n        deny: deny.bitfield\n      },\n      reason\n    }).then(() => this);\n  }\n\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));\n    const permissionOverwrites = this.parent.permissionOverwrites.map(overwrite => overwrite.toJSON());\n    return this.edit({\n      permissionOverwrites\n    });\n  }\n\n  /**\n   * A collection of members that can see this channel, mapped by their ID\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    const members = new Collection();\n    for (const member of this.guild.members.cache.values()) {\n      if (this.permissionsFor(member).has('VIEW_CHANNEL', false)) {\n        members.set(member.id, member);\n      }\n    }\n    return members;\n  }\n\n  /**\n   * The data for a guild channel.\n   * @typedef {Object} ChannelData\n   * @property {string} [name] The name of the channel\n   * @property {number} [position] The position of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?Snowflake} [parentID] The parent ID of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The ratelimit per user for the channel in seconds\n   */\n\n  /**\n   * Edits the channel.\n   * @param {ChannelData} data The new data for the channel\n   * @param {string} [reason] Reason for editing this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    if (typeof data.position !== 'undefined') {\n      await Util.setPosition(this, data.position, false, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason).then(updatedChannels => {\n        this.client.actions.GuildChannelsPositionUpdate.handle({\n          guild_id: this.guild.id,\n          channels: updatedChannels\n        });\n      });\n    }\n    let permission_overwrites;\n    if (data.permissionOverwrites) {\n      permission_overwrites = data.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n    if (data.lockPermissions) {\n      if (data.parentID) {\n        const newParent = this.guild.channels.resolve(data.parentID);\n        if (newParent && newParent.type === 'category') {\n          permission_overwrites = newParent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n        }\n      } else if (this.parent) {\n        permission_overwrites = this.parent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n      }\n    }\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name || this.name).trim(),\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate || this.bitrate,\n        user_limit: typeof data.userLimit !== 'undefined' ? data.userLimit : this.userLimit,\n        parent_id: data.parentID,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        permission_overwrites\n      },\n      reason\n    });\n    const clone = this._clone();\n    clone._patch(newData);\n    return clone;\n  }\n\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({\n      name\n    }, reason);\n  }\n\n  /**\n   * Sets the category parent of this channel.\n   * @param {?CategoryChannel|Snowflake} channel Parent channel\n   * @param {Object} [options={}] Options to pass\n   * @param {boolean} [options.lockPermissions=true] Lock the permissions to what the parent's permissions are\n   * @param {string} [options.reason] Reason for modifying the parent of this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  setParent(channel) {\n    let {\n      lockPermissions = true,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.edit({\n      // eslint-disable-next-line no-prototype-builtins\n      parentID: channel !== null ? channel.hasOwnProperty('id') ? channel.id : channel : null,\n      lockPermissions\n    }, reason);\n  }\n\n  /**\n   * Sets a new topic for the guild channel.\n   * @param {?string} topic The new topic for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's topic\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel topic\n   * channel.setTopic('needs more rate limiting')\n   *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))\n   *   .catch(console.error);\n   */\n  setTopic(topic, reason) {\n    return this.edit({\n      topic\n    }, reason);\n  }\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {Object} [options] Options for setting position\n   * @param {boolean} [options.relative=false] Change the position relative to its current value\n   * @param {string} [options.reason] Reason for changing the position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position) {\n    let {\n      relative,\n      reason\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Util.setPosition(this, position, relative, this.guild._sortedChannels(this), this.client.api.guilds(this.guild.id).channels, reason).then(updatedChannels => {\n      this.client.actions.GuildChannelsPositionUpdate.handle({\n        guild_id: this.guild.id,\n        channels: updatedChannels\n      });\n      return this;\n    });\n  }\n\n  /**\n   * Creates an invite to this guild channel.\n   * @param {Object} [options={}] Options for the invite\n   * @param {boolean} [options.temporary=false] Whether members that joined via the invite should be automatically\n   * kicked after 24 hours if they have not yet received a role\n   * @param {number} [options.maxAge=86400] How long the invite should last (in seconds, 0 for forever)\n   * @param {number} [options.maxUses=0] Maximum number of uses\n   * @param {boolean} [options.unique=false] Create a unique invite, or use an existing one with similar settings\n   * @param {string} [options.reason] Reason for creating this\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a channel\n   * channel.createInvite()\n   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n   *   .catch(console.error);\n   */\n  createInvite() {\n    let {\n      temporary = false,\n      maxAge = 86400,\n      maxUses = 0,\n      unique,\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.client.api.channels(this.id).invites.post({\n      data: {\n        temporary,\n        max_age: maxAge,\n        max_uses: maxUses,\n        unique\n      },\n      reason\n    }).then(invite => new Invite(this.client, invite));\n  }\n\n  /**\n   * Fetches a collection of invites to this guild channel.\n   * Resolves with a collection mapping invites by their codes.\n   * @returns {Promise<Collection<string, Invite>>}\n   */\n  async fetchInvites() {\n    const inviteItems = await this.client.api.channels(this.id).invites.get();\n    const invites = new Collection();\n    for (const inviteItem of inviteItems) {\n      const invite = new Invite(this.client, inviteItem);\n      invites.set(invite.code, invite);\n    }\n    return invites;\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Clones this channel.\n   * @param {Object} [options] The options\n   * @param {string} [options.name=this.name] Name of the new channel\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [options.permissionOverwrites=this.permissionOverwrites]\n   * Permission overwrites of the new channel\n   * @param {string} [options.type=this.type] Type of the new channel\n   * @param {string} [options.topic=this.topic] Topic of the new channel (only text)\n   * @param {boolean} [options.nsfw=this.nsfw] Whether the new channel is nsfw (only text)\n   * @param {number} [options.bitrate=this.bitrate] Bitrate of the new channel in bits (only voice)\n   * @param {number} [options.userLimit=this.userLimit] Maximum amount of users allowed in the new channel (only voice)\n   * @param {number} [options.rateLimitPerUser=this.rateLimitPerUser] Ratelimit per user for the new channel (only text)\n   * @param {ChannelResolvable} [options.parent=this.parent] Parent of the new channel\n   * @param {string} [options.reason] Reason for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n  clone() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    Util.mergeDefault({\n      name: this.name,\n      permissionOverwrites: this.permissionOverwrites,\n      topic: this.topic,\n      type: this.type,\n      nsfw: this.nsfw,\n      parent: this.parent,\n      bitrate: this.bitrate,\n      userLimit: this.userLimit,\n      rateLimitPerUser: this.rateLimitPerUser,\n      reason: null\n    }, options);\n    return this.guild.channels.create(options.name, options);\n  }\n  /* eslint-enable max-len */\n\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites and ID as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n  equals(channel) {\n    let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.equals(channel.permissionOverwrites);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n    return equal;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerID) return true;\n    if (this.type === 'voice') {\n      if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) {\n        return false;\n      }\n    } else if (!this.viewable) {\n      return false;\n    }\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerID) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  delete(reason) {\n    return this.client.api.channels(this.id).delete({\n      reason\n    }).then(() => this);\n  }\n}\nmodule.exports = GuildChannel;","map":{"version":3,"names":["Channel","require","Invite","PermissionOverwrites","Role","Error","TypeError","Collection","Permissions","Util","GuildChannel","constructor","guild","data","client","_patch","name","rawPosition","position","parentID","parent_id","permissionOverwrites","permission_overwrites","overwrite","set","id","parent","channels","cache","get","permissionsLocked","size","every","value","key","testVal","undefined","deny","bitfield","allow","sorted","_sortedChannels","array","indexOf","permissionsFor","memberOrRole","member","members","resolve","memberPermissions","role","roles","rolePermissions","overwritesFor","verified","roleOverwrites","memberOverwrites","everyoneOverwrites","values","has","push","everyone","ownerID","ALL","freeze","permissions","map","FLAGS","ADMINISTRATOR","overwrites","remove","add","length","overwritePermissions","reason","Array","isArray","Promise","reject","edit","then","updateOverwrite","userOrRole","options","users","existing","update","createOverwrite","type","resolveOverwriteOptions","api","put","lockPermissions","toJSON","setPosition","guilds","updatedChannels","actions","GuildChannelsPositionUpdate","handle","guild_id","o","newParent","newData","patch","trim","topic","nsfw","bitrate","user_limit","userLimit","lock_permissions","rate_limit_per_user","rateLimitPerUser","clone","_clone","setName","setParent","channel","hasOwnProperty","setTopic","relative","createInvite","temporary","maxAge","maxUses","unique","invites","post","max_age","max_uses","invite","fetchInvites","inviteItems","inviteItem","code","mergeDefault","create","equals","equal","deletable","user","MANAGE_CHANNELS","manageable","CONNECT","viewable","VIEW_CHANNEL","delete","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/GuildChannel.js"],"sourcesContent":["'use strict';\n\nconst Channel = require('./Channel');\nconst Invite = require('./Invite');\nconst PermissionOverwrites = require('./PermissionOverwrites');\nconst Role = require('./Role');\nconst { Error, TypeError } = require('../errors');\nconst Collection = require('../util/Collection');\nconst Permissions = require('../util/Permissions');\nconst Util = require('../util/Util');\n\n/**\n * Represents a guild channel from any of the following:\n * - {@link TextChannel}\n * - {@link VoiceChannel}\n * - {@link CategoryChannel}\n * - {@link NewsChannel}\n * - {@link StoreChannel}\n * @extends {Channel}\n * @abstract\n */\nclass GuildChannel extends Channel {\n  /**\n   * @param {Guild} guild The guild the guild channel is part of\n   * @param {Object} data The data for the guild channel\n   */\n  constructor(guild, data) {\n    super(guild.client, data);\n\n    /**\n     * The guild the channel is in\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  _patch(data) {\n    super._patch(data);\n\n    /**\n     * The name of the guild channel\n     * @type {string}\n     */\n    this.name = data.name;\n\n    /**\n     * The raw position of the channel from discord\n     * @type {number}\n     */\n    this.rawPosition = data.position;\n\n    /**\n     * The ID of the category parent of this channel\n     * @type {?Snowflake}\n     */\n    this.parentID = data.parent_id || null;\n\n    /**\n     * A map of permission overwrites in this channel for roles and users\n     * @type {Collection<Snowflake, PermissionOverwrites>}\n     */\n    this.permissionOverwrites = new Collection();\n    if (data.permission_overwrites) {\n      for (const overwrite of data.permission_overwrites) {\n        this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));\n      }\n    }\n  }\n\n  /**\n   * The category parent of this channel\n   * @type {?CategoryChannel}\n   * @readonly\n   */\n  get parent() {\n    return this.guild.channels.cache.get(this.parentID) || null;\n  }\n\n  /**\n   * If the permissionOverwrites match the parent channel, null if no parent\n   * @type {?boolean}\n   * @readonly\n   */\n  get permissionsLocked() {\n    if (!this.parent) return null;\n    if (this.permissionOverwrites.size !== this.parent.permissionOverwrites.size) return false;\n    return this.permissionOverwrites.every((value, key) => {\n      const testVal = this.parent.permissionOverwrites.get(key);\n      return (\n        testVal !== undefined &&\n        testVal.deny.bitfield === value.deny.bitfield &&\n        testVal.allow.bitfield === value.allow.bitfield\n      );\n    });\n  }\n\n  /**\n   * The position of the channel\n   * @type {number}\n   * @readonly\n   */\n  get position() {\n    const sorted = this.guild._sortedChannels(this);\n    return sorted.array().indexOf(sorted.get(this.id));\n  }\n\n  /**\n   * Gets the overall set of permissions for a member or role in this channel, taking into account channel overwrites.\n   * @param {GuildMemberResolvable|RoleResolvable} memberOrRole The member or role to obtain the overall permissions for\n   * @returns {?Readonly<Permissions>}\n   */\n  permissionsFor(memberOrRole) {\n    const member = this.guild.members.resolve(memberOrRole);\n    if (member) return this.memberPermissions(member);\n    const role = this.guild.roles.resolve(memberOrRole);\n    if (role) return this.rolePermissions(role);\n    return null;\n  }\n\n  overwritesFor(member, verified = false, roles = null) {\n    if (!verified) member = this.guild.members.resolve(member);\n    if (!member) return [];\n\n    roles = roles || member.roles.cache;\n    const roleOverwrites = [];\n    let memberOverwrites;\n    let everyoneOverwrites;\n\n    for (const overwrite of this.permissionOverwrites.values()) {\n      if (overwrite.id === this.guild.id) {\n        everyoneOverwrites = overwrite;\n      } else if (roles.has(overwrite.id)) {\n        roleOverwrites.push(overwrite);\n      } else if (overwrite.id === member.id) {\n        memberOverwrites = overwrite;\n      }\n    }\n\n    return {\n      everyone: everyoneOverwrites,\n      roles: roleOverwrites,\n      member: memberOverwrites,\n    };\n  }\n\n  /**\n   * Gets the overall set of permissions for a member in this channel, taking into account channel overwrites.\n   * @param {GuildMember} member The member to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  memberPermissions(member) {\n    if (member.id === this.guild.ownerID) return new Permissions(Permissions.ALL).freeze();\n\n    const roles = member.roles.cache;\n    const permissions = new Permissions(roles.map(role => role.permissions));\n\n    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n\n    const overwrites = this.overwritesFor(member, true, roles);\n\n    return permissions\n      .remove(overwrites.everyone ? overwrites.everyone.deny : 0)\n      .add(overwrites.everyone ? overwrites.everyone.allow : 0)\n      .remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : 0)\n      .add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : 0)\n      .remove(overwrites.member ? overwrites.member.deny : 0)\n      .add(overwrites.member ? overwrites.member.allow : 0)\n      .freeze();\n  }\n\n  /**\n   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.\n   * @param {Role} role The role to obtain the overall permissions for\n   * @returns {Readonly<Permissions>}\n   * @private\n   */\n  rolePermissions(role) {\n    if (role.permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();\n\n    const everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);\n    const roleOverwrites = this.permissionOverwrites.get(role.id);\n\n    return role.permissions\n      .remove(everyoneOverwrites ? everyoneOverwrites.deny : 0)\n      .add(everyoneOverwrites ? everyoneOverwrites.allow : 0)\n      .remove(roleOverwrites ? roleOverwrites.deny : 0)\n      .add(roleOverwrites ? roleOverwrites.allow : 0)\n      .freeze();\n  }\n\n  /**\n   * Replaces the permission overwrites in this channel.\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} overwrites\n   * Permission overwrites the channel gets updated with\n   * @param {string} [reason] Reason for updating the channel overwrites\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * channel.overwritePermissions([\n   *   {\n   *      id: message.author.id,\n   *      deny: ['VIEW_CHANNEL'],\n   *   },\n   * ], 'Needed to change permissions');\n   */\n  overwritePermissions(overwrites, reason) {\n    if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {\n      return Promise.reject(\n        new TypeError('INVALID_TYPE', 'overwrites', 'Array or Collection of Permission Overwrites', true),\n      );\n    }\n    return this.edit({ permissionOverwrites: overwrites, reason }).then(() => this);\n  }\n\n  /**\n   * Updates Overwrites for a user or role in this channel. (creates if non-existent)\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {string} [reason] Reason for creating/editing this overwrite\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Update or Create permission overwrites for a message author\n   * message.channel.updateOverwrite(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  updateOverwrite(userOrRole, options, reason) {\n    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));\n\n    const existing = this.permissionOverwrites.get(userOrRole.id);\n    if (existing) return existing.update(options, reason).then(() => this);\n    return this.createOverwrite(userOrRole, options, reason);\n  }\n\n  /**\n   * Overwrites the permissions for a user or role in this channel. (replaces if existent)\n   * @param {RoleResolvable|UserResolvable} userOrRole The user or role to update\n   * @param {PermissionOverwriteOptions} options The options for the update\n   * @param {string} [reason] Reason for creating/editing this overwrite\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Create or Replace permissions overwrites for a message author\n   * message.channel.createOverwrite(message.author, {\n   *   SEND_MESSAGES: false\n   * })\n   *   .then(channel => console.log(channel.permissionOverwrites.get(message.author.id)))\n   *   .catch(console.error);\n   */\n  createOverwrite(userOrRole, options, reason) {\n    userOrRole = this.guild.roles.resolve(userOrRole) || this.client.users.resolve(userOrRole);\n    if (!userOrRole) return Promise.reject(new TypeError('INVALID_TYPE', 'parameter', 'User nor a Role'));\n\n    const type = userOrRole instanceof Role ? 'role' : 'member';\n    const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options);\n\n    return this.client.api\n      .channels(this.id)\n      .permissions[userOrRole.id].put({\n        data: { id: userOrRole.id, type, allow: allow.bitfield, deny: deny.bitfield },\n        reason,\n      })\n      .then(() => this);\n  }\n\n  /**\n   * Locks in the permission overwrites from the parent channel.\n   * @returns {Promise<GuildChannel>}\n   */\n  lockPermissions() {\n    if (!this.parent) return Promise.reject(new Error('GUILD_CHANNEL_ORPHAN'));\n    const permissionOverwrites = this.parent.permissionOverwrites.map(overwrite => overwrite.toJSON());\n    return this.edit({ permissionOverwrites });\n  }\n\n  /**\n   * A collection of members that can see this channel, mapped by their ID\n   * @type {Collection<Snowflake, GuildMember>}\n   * @readonly\n   */\n  get members() {\n    const members = new Collection();\n    for (const member of this.guild.members.cache.values()) {\n      if (this.permissionsFor(member).has('VIEW_CHANNEL', false)) {\n        members.set(member.id, member);\n      }\n    }\n    return members;\n  }\n\n  /**\n   * The data for a guild channel.\n   * @typedef {Object} ChannelData\n   * @property {string} [name] The name of the channel\n   * @property {number} [position] The position of the channel\n   * @property {string} [topic] The topic of the text channel\n   * @property {boolean} [nsfw] Whether the channel is NSFW\n   * @property {number} [bitrate] The bitrate of the voice channel\n   * @property {number} [userLimit] The user limit of the voice channel\n   * @property {?Snowflake} [parentID] The parent ID of the channel\n   * @property {boolean} [lockPermissions]\n   * Lock the permissions of the channel to what the parent's permissions are\n   * @property {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [permissionOverwrites]\n   * Permission overwrites for the channel\n   * @property {number} [rateLimitPerUser] The ratelimit per user for the channel in seconds\n   */\n\n  /**\n   * Edits the channel.\n   * @param {ChannelData} data The new data for the channel\n   * @param {string} [reason] Reason for editing this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Edit a channel\n   * channel.edit({ name: 'new-channel' })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async edit(data, reason) {\n    if (typeof data.position !== 'undefined') {\n      await Util.setPosition(\n        this,\n        data.position,\n        false,\n        this.guild._sortedChannels(this),\n        this.client.api.guilds(this.guild.id).channels,\n        reason,\n      ).then(updatedChannels => {\n        this.client.actions.GuildChannelsPositionUpdate.handle({\n          guild_id: this.guild.id,\n          channels: updatedChannels,\n        });\n      });\n    }\n\n    let permission_overwrites;\n\n    if (data.permissionOverwrites) {\n      permission_overwrites = data.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n    }\n\n    if (data.lockPermissions) {\n      if (data.parentID) {\n        const newParent = this.guild.channels.resolve(data.parentID);\n        if (newParent && newParent.type === 'category') {\n          permission_overwrites = newParent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n        }\n      } else if (this.parent) {\n        permission_overwrites = this.parent.permissionOverwrites.map(o => PermissionOverwrites.resolve(o, this.guild));\n      }\n    }\n\n    const newData = await this.client.api.channels(this.id).patch({\n      data: {\n        name: (data.name || this.name).trim(),\n        topic: data.topic,\n        nsfw: data.nsfw,\n        bitrate: data.bitrate || this.bitrate,\n        user_limit: typeof data.userLimit !== 'undefined' ? data.userLimit : this.userLimit,\n        parent_id: data.parentID,\n        lock_permissions: data.lockPermissions,\n        rate_limit_per_user: data.rateLimitPerUser,\n        permission_overwrites,\n      },\n      reason,\n    });\n\n    const clone = this._clone();\n    clone._patch(newData);\n    return clone;\n  }\n\n  /**\n   * Sets a new name for the guild channel.\n   * @param {string} name The new name for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's name\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel name\n   * channel.setName('not_general')\n   *   .then(newChannel => console.log(`Channel's new name is ${newChannel.name}`))\n   *   .catch(console.error);\n   */\n  setName(name, reason) {\n    return this.edit({ name }, reason);\n  }\n\n  /**\n   * Sets the category parent of this channel.\n   * @param {?CategoryChannel|Snowflake} channel Parent channel\n   * @param {Object} [options={}] Options to pass\n   * @param {boolean} [options.lockPermissions=true] Lock the permissions to what the parent's permissions are\n   * @param {string} [options.reason] Reason for modifying the parent of this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Add a parent to a channel\n   * message.channel.setParent('355908108431917066', { lockPermissions: false })\n   *   .then(channel => console.log(`New parent of ${message.channel.name}: ${channel.name}`))\n   *   .catch(console.error);\n   */\n  setParent(channel, { lockPermissions = true, reason } = {}) {\n    return this.edit(\n      {\n        // eslint-disable-next-line no-prototype-builtins\n        parentID: channel !== null ? (channel.hasOwnProperty('id') ? channel.id : channel) : null,\n        lockPermissions,\n      },\n      reason,\n    );\n  }\n\n  /**\n   * Sets a new topic for the guild channel.\n   * @param {?string} topic The new topic for the guild channel\n   * @param {string} [reason] Reason for changing the guild channel's topic\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel topic\n   * channel.setTopic('needs more rate limiting')\n   *   .then(newChannel => console.log(`Channel's new topic is ${newChannel.topic}`))\n   *   .catch(console.error);\n   */\n  setTopic(topic, reason) {\n    return this.edit({ topic }, reason);\n  }\n\n  /**\n   * Sets a new position for the guild channel.\n   * @param {number} position The new position for the guild channel\n   * @param {Object} [options] Options for setting position\n   * @param {boolean} [options.relative=false] Change the position relative to its current value\n   * @param {string} [options.reason] Reason for changing the position\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Set a new channel position\n   * channel.setPosition(2)\n   *   .then(newChannel => console.log(`Channel's new position is ${newChannel.position}`))\n   *   .catch(console.error);\n   */\n  setPosition(position, { relative, reason } = {}) {\n    return Util.setPosition(\n      this,\n      position,\n      relative,\n      this.guild._sortedChannels(this),\n      this.client.api.guilds(this.guild.id).channels,\n      reason,\n    ).then(updatedChannels => {\n      this.client.actions.GuildChannelsPositionUpdate.handle({\n        guild_id: this.guild.id,\n        channels: updatedChannels,\n      });\n      return this;\n    });\n  }\n\n  /**\n   * Creates an invite to this guild channel.\n   * @param {Object} [options={}] Options for the invite\n   * @param {boolean} [options.temporary=false] Whether members that joined via the invite should be automatically\n   * kicked after 24 hours if they have not yet received a role\n   * @param {number} [options.maxAge=86400] How long the invite should last (in seconds, 0 for forever)\n   * @param {number} [options.maxUses=0] Maximum number of uses\n   * @param {boolean} [options.unique=false] Create a unique invite, or use an existing one with similar settings\n   * @param {string} [options.reason] Reason for creating this\n   * @returns {Promise<Invite>}\n   * @example\n   * // Create an invite to a channel\n   * channel.createInvite()\n   *   .then(invite => console.log(`Created an invite with a code of ${invite.code}`))\n   *   .catch(console.error);\n   */\n  createInvite({ temporary = false, maxAge = 86400, maxUses = 0, unique, reason } = {}) {\n    return this.client.api\n      .channels(this.id)\n      .invites.post({\n        data: {\n          temporary,\n          max_age: maxAge,\n          max_uses: maxUses,\n          unique,\n        },\n        reason,\n      })\n      .then(invite => new Invite(this.client, invite));\n  }\n\n  /**\n   * Fetches a collection of invites to this guild channel.\n   * Resolves with a collection mapping invites by their codes.\n   * @returns {Promise<Collection<string, Invite>>}\n   */\n  async fetchInvites() {\n    const inviteItems = await this.client.api.channels(this.id).invites.get();\n    const invites = new Collection();\n    for (const inviteItem of inviteItems) {\n      const invite = new Invite(this.client, inviteItem);\n      invites.set(invite.code, invite);\n    }\n    return invites;\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Clones this channel.\n   * @param {Object} [options] The options\n   * @param {string} [options.name=this.name] Name of the new channel\n   * @param {OverwriteResolvable[]|Collection<Snowflake, OverwriteResolvable>} [options.permissionOverwrites=this.permissionOverwrites]\n   * Permission overwrites of the new channel\n   * @param {string} [options.type=this.type] Type of the new channel\n   * @param {string} [options.topic=this.topic] Topic of the new channel (only text)\n   * @param {boolean} [options.nsfw=this.nsfw] Whether the new channel is nsfw (only text)\n   * @param {number} [options.bitrate=this.bitrate] Bitrate of the new channel in bits (only voice)\n   * @param {number} [options.userLimit=this.userLimit] Maximum amount of users allowed in the new channel (only voice)\n   * @param {number} [options.rateLimitPerUser=this.rateLimitPerUser] Ratelimit per user for the new channel (only text)\n   * @param {ChannelResolvable} [options.parent=this.parent] Parent of the new channel\n   * @param {string} [options.reason] Reason for cloning this channel\n   * @returns {Promise<GuildChannel>}\n   */\n  clone(options = {}) {\n    Util.mergeDefault(\n      {\n        name: this.name,\n        permissionOverwrites: this.permissionOverwrites,\n        topic: this.topic,\n        type: this.type,\n        nsfw: this.nsfw,\n        parent: this.parent,\n        bitrate: this.bitrate,\n        userLimit: this.userLimit,\n        rateLimitPerUser: this.rateLimitPerUser,\n        reason: null,\n      },\n      options,\n    );\n    return this.guild.channels.create(options.name, options);\n  }\n  /* eslint-enable max-len */\n\n  /**\n   * Checks if this channel has the same type, topic, position, name, overwrites and ID as another channel.\n   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.\n   * @param {GuildChannel} channel Channel to compare with\n   * @returns {boolean}\n   */\n  equals(channel) {\n    let equal =\n      channel &&\n      this.id === channel.id &&\n      this.type === channel.type &&\n      this.topic === channel.topic &&\n      this.position === channel.position &&\n      this.name === channel.name;\n\n    if (equal) {\n      if (this.permissionOverwrites && channel.permissionOverwrites) {\n        equal = this.permissionOverwrites.equals(channel.permissionOverwrites);\n      } else {\n        equal = !this.permissionOverwrites && !channel.permissionOverwrites;\n      }\n    }\n\n    return equal;\n  }\n\n  /**\n   * Whether the channel is deletable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get deletable() {\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n\n  /**\n   * Whether the channel is manageable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get manageable() {\n    if (this.client.user.id === this.guild.ownerID) return true;\n    if (this.type === 'voice') {\n      if (!this.permissionsFor(this.client.user).has(Permissions.FLAGS.CONNECT, false)) {\n        return false;\n      }\n    } else if (!this.viewable) {\n      return false;\n    }\n    return this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS, false);\n  }\n\n  /**\n   * Whether the channel is viewable by the client user\n   * @type {boolean}\n   * @readonly\n   */\n  get viewable() {\n    if (this.client.user.id === this.guild.ownerID) return true;\n    const permissions = this.permissionsFor(this.client.user);\n    if (!permissions) return false;\n    return permissions.has(Permissions.FLAGS.VIEW_CHANNEL, false);\n  }\n\n  /**\n   * Deletes this channel.\n   * @param {string} [reason] Reason for deleting this channel\n   * @returns {Promise<GuildChannel>}\n   * @example\n   * // Delete the channel\n   * channel.delete('making room for new channels')\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  delete(reason) {\n    return this.client.api\n      .channels(this.id)\n      .delete({ reason })\n      .then(() => this);\n  }\n}\n\nmodule.exports = GuildChannel;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}