{"ast":null,"code":"'use strict';\n\nconst AsyncQueue = require('./AsyncQueue');\nconst DiscordAPIError = require('./DiscordAPIError');\nconst HTTPError = require('./HTTPError');\nconst {\n  Events: {\n    RATE_LIMIT\n  },\n  browser\n} = require('../util/Constants');\nconst Util = require('../util/Util');\nfunction parseResponse(res) {\n  if (res.headers.get('content-type').startsWith('application/json')) return res.json();\n  if (browser) return res.blob();\n  return res.buffer();\n}\nfunction getAPIOffset(serverDate) {\n  return new Date(serverDate).getTime() - Date.now();\n}\nfunction calculateReset(reset, serverDate) {\n  return new Date(Number(reset) * 1000).getTime() - getAPIOffset(serverDate);\n}\nclass RequestHandler {\n  constructor(manager) {\n    this.manager = manager;\n    this.queue = new AsyncQueue();\n    this.reset = -1;\n    this.remaining = -1;\n    this.limit = -1;\n    this.retryAfter = -1;\n  }\n  async push(request) {\n    await this.queue.wait();\n    try {\n      return await this.execute(request);\n    } finally {\n      this.queue.shift();\n    }\n  }\n  get limited() {\n    return Boolean(this.manager.globalTimeout) || this.remaining <= 0 && Date.now() < this.reset;\n  }\n  get _inactive() {\n    return this.queue.remaining === 0 && !this.limited;\n  }\n  async execute(request) {\n    // After calculations and requests have been done, pre-emptively stop further requests\n    if (this.limited) {\n      const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n      if (this.manager.client.listenerCount(RATE_LIMIT)) {\n        /**\n         * Emitted when the client hits a rate limit while making a request\n         * @event Client#rateLimit\n         * @param {Object} rateLimitInfo Object containing the rate limit info\n         * @param {number} rateLimitInfo.timeout Timeout in ms\n         * @param {number} rateLimitInfo.limit Number of requests that can be made to this endpoint\n         * @param {string} rateLimitInfo.method HTTP method used for request that triggered this event\n         * @param {string} rateLimitInfo.path Path used for request that triggered this event\n         * @param {string} rateLimitInfo.route Route used for request that triggered this event\n         */\n        this.manager.client.emit(RATE_LIMIT, {\n          timeout,\n          limit: this.limit,\n          method: request.method,\n          path: request.path,\n          route: request.route\n        });\n      }\n      if (this.manager.globalTimeout) {\n        await this.manager.globalTimeout;\n      } else {\n        // Wait for the timeout to expire in order to avoid an actual 429\n        await Util.delayFor(timeout);\n      }\n    }\n\n    // Perform the request\n    let res;\n    try {\n      res = await request.make();\n    } catch (error) {\n      // Retry the specified number of times for request abortions\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(error.message, error.constructor.name, error.status, request.method, request.path);\n      }\n      request.retries++;\n      return this.execute(request);\n    }\n    if (res && res.headers) {\n      const serverDate = res.headers.get('date');\n      const limit = res.headers.get('x-ratelimit-limit');\n      const remaining = res.headers.get('x-ratelimit-remaining');\n      const reset = res.headers.get('x-ratelimit-reset');\n      const retryAfter = res.headers.get('retry-after');\n      this.limit = limit ? Number(limit) : Infinity;\n      this.remaining = remaining ? Number(remaining) : 1;\n      this.reset = reset ? calculateReset(reset, serverDate) : Date.now();\n      this.retryAfter = retryAfter ? Number(retryAfter) : -1;\n\n      // https://github.com/discordapp/discord-api-docs/issues/182\n      if (request.route.includes('reactions')) {\n        this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;\n      }\n\n      // Handle global ratelimit\n      if (res.headers.get('x-ratelimit-global')) {\n        // Set the manager's global timeout as the promise for other requests to \"wait\"\n        this.manager.globalTimeout = Util.delayFor(this.retryAfter);\n\n        // Wait for the global timeout to resolve before continuing\n        await this.manager.globalTimeout;\n\n        // Clean up global timeout\n        this.manager.globalTimeout = null;\n      }\n    }\n\n    // Handle 2xx and 3xx responses\n    if (res.ok) {\n      // Nothing wrong with the request, proceed with the next one\n      return parseResponse(res);\n    }\n\n    // Handle 4xx responses\n    if (res.status >= 400 && res.status < 500) {\n      // Handle ratelimited requests\n      if (res.status === 429) {\n        // A ratelimit was hit - this should never happen\n        this.manager.client.emit('debug', `429 hit on route ${request.route}`);\n        await Util.delayFor(this.retryAfter);\n        return this.execute(request);\n      }\n\n      // Handle possible malformed requests\n      let data;\n      try {\n        data = await parseResponse(res);\n      } catch (err) {\n        throw new HTTPError(err.message, err.constructor.name, err.status, request.method, request.path);\n      }\n      throw new DiscordAPIError(request.path, data, request.method, res.status);\n    }\n\n    // Handle 5xx responses\n    if (res.status >= 500 && res.status < 600) {\n      // Retry the specified number of times for possible serverside issues\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(res.statusText, res.constructor.name, res.status, request.method, request.path);\n      }\n      request.retries++;\n      return this.execute(request);\n    }\n\n    // Fallback in the rare case a status code outside the range 200..=599 is returned\n    return null;\n  }\n}\nmodule.exports = RequestHandler;","map":{"version":3,"names":["AsyncQueue","require","DiscordAPIError","HTTPError","Events","RATE_LIMIT","browser","Util","parseResponse","res","headers","get","startsWith","json","blob","buffer","getAPIOffset","serverDate","Date","getTime","now","calculateReset","reset","Number","RequestHandler","constructor","manager","queue","remaining","limit","retryAfter","push","request","wait","execute","shift","limited","Boolean","globalTimeout","_inactive","timeout","client","options","restTimeOffset","listenerCount","emit","method","path","route","delayFor","make","error","retries","retryLimit","message","name","status","Infinity","includes","ok","data","err","statusText","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/rest/RequestHandler.js"],"sourcesContent":["'use strict';\n\nconst AsyncQueue = require('./AsyncQueue');\nconst DiscordAPIError = require('./DiscordAPIError');\nconst HTTPError = require('./HTTPError');\nconst {\n  Events: { RATE_LIMIT },\n  browser,\n} = require('../util/Constants');\nconst Util = require('../util/Util');\n\nfunction parseResponse(res) {\n  if (res.headers.get('content-type').startsWith('application/json')) return res.json();\n  if (browser) return res.blob();\n  return res.buffer();\n}\n\nfunction getAPIOffset(serverDate) {\n  return new Date(serverDate).getTime() - Date.now();\n}\n\nfunction calculateReset(reset, serverDate) {\n  return new Date(Number(reset) * 1000).getTime() - getAPIOffset(serverDate);\n}\n\nclass RequestHandler {\n  constructor(manager) {\n    this.manager = manager;\n    this.queue = new AsyncQueue();\n    this.reset = -1;\n    this.remaining = -1;\n    this.limit = -1;\n    this.retryAfter = -1;\n  }\n\n  async push(request) {\n    await this.queue.wait();\n    try {\n      return await this.execute(request);\n    } finally {\n      this.queue.shift();\n    }\n  }\n\n  get limited() {\n    return Boolean(this.manager.globalTimeout) || (this.remaining <= 0 && Date.now() < this.reset);\n  }\n\n  get _inactive() {\n    return this.queue.remaining === 0 && !this.limited;\n  }\n\n  async execute(request) {\n    // After calculations and requests have been done, pre-emptively stop further requests\n    if (this.limited) {\n      const timeout = this.reset + this.manager.client.options.restTimeOffset - Date.now();\n\n      if (this.manager.client.listenerCount(RATE_LIMIT)) {\n        /**\n         * Emitted when the client hits a rate limit while making a request\n         * @event Client#rateLimit\n         * @param {Object} rateLimitInfo Object containing the rate limit info\n         * @param {number} rateLimitInfo.timeout Timeout in ms\n         * @param {number} rateLimitInfo.limit Number of requests that can be made to this endpoint\n         * @param {string} rateLimitInfo.method HTTP method used for request that triggered this event\n         * @param {string} rateLimitInfo.path Path used for request that triggered this event\n         * @param {string} rateLimitInfo.route Route used for request that triggered this event\n         */\n        this.manager.client.emit(RATE_LIMIT, {\n          timeout,\n          limit: this.limit,\n          method: request.method,\n          path: request.path,\n          route: request.route,\n        });\n      }\n\n      if (this.manager.globalTimeout) {\n        await this.manager.globalTimeout;\n      } else {\n        // Wait for the timeout to expire in order to avoid an actual 429\n        await Util.delayFor(timeout);\n      }\n    }\n\n    // Perform the request\n    let res;\n    try {\n      res = await request.make();\n    } catch (error) {\n      // Retry the specified number of times for request abortions\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(error.message, error.constructor.name, error.status, request.method, request.path);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    }\n\n    if (res && res.headers) {\n      const serverDate = res.headers.get('date');\n      const limit = res.headers.get('x-ratelimit-limit');\n      const remaining = res.headers.get('x-ratelimit-remaining');\n      const reset = res.headers.get('x-ratelimit-reset');\n      const retryAfter = res.headers.get('retry-after');\n\n      this.limit = limit ? Number(limit) : Infinity;\n      this.remaining = remaining ? Number(remaining) : 1;\n      this.reset = reset ? calculateReset(reset, serverDate) : Date.now();\n      this.retryAfter = retryAfter ? Number(retryAfter) : -1;\n\n      // https://github.com/discordapp/discord-api-docs/issues/182\n      if (request.route.includes('reactions')) {\n        this.reset = new Date(serverDate).getTime() - getAPIOffset(serverDate) + 250;\n      }\n\n      // Handle global ratelimit\n      if (res.headers.get('x-ratelimit-global')) {\n        // Set the manager's global timeout as the promise for other requests to \"wait\"\n        this.manager.globalTimeout = Util.delayFor(this.retryAfter);\n\n        // Wait for the global timeout to resolve before continuing\n        await this.manager.globalTimeout;\n\n        // Clean up global timeout\n        this.manager.globalTimeout = null;\n      }\n    }\n\n    // Handle 2xx and 3xx responses\n    if (res.ok) {\n      // Nothing wrong with the request, proceed with the next one\n      return parseResponse(res);\n    }\n\n    // Handle 4xx responses\n    if (res.status >= 400 && res.status < 500) {\n      // Handle ratelimited requests\n      if (res.status === 429) {\n        // A ratelimit was hit - this should never happen\n        this.manager.client.emit('debug', `429 hit on route ${request.route}`);\n        await Util.delayFor(this.retryAfter);\n        return this.execute(request);\n      }\n\n      // Handle possible malformed requests\n      let data;\n      try {\n        data = await parseResponse(res);\n      } catch (err) {\n        throw new HTTPError(err.message, err.constructor.name, err.status, request.method, request.path);\n      }\n\n      throw new DiscordAPIError(request.path, data, request.method, res.status);\n    }\n\n    // Handle 5xx responses\n    if (res.status >= 500 && res.status < 600) {\n      // Retry the specified number of times for possible serverside issues\n      if (request.retries === this.manager.client.options.retryLimit) {\n        throw new HTTPError(res.statusText, res.constructor.name, res.status, request.method, request.path);\n      }\n\n      request.retries++;\n      return this.execute(request);\n    }\n\n    // Fallback in the rare case a status code outside the range 200..=599 is returned\n    return null;\n  }\n}\n\nmodule.exports = RequestHandler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}