{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\nconst Collection = require('../../util/Collection');\nconst Util = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client, filter) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', {\n      value: client\n    });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     */\n    this.filter = filter;\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n    if (options.time) this._timeout = this.client.setTimeout(() => this.stop('time'), options.time);\n    if (options.idle) this._idletimeout = this.client.setTimeout(() => this.stop('idle'), options.idle);\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#collect\n   */\n  async handleCollect() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const collect = this.collect(...args);\n    if (collect && (await this.filter(...args, this.collected))) {\n      this.collected.set(collect, args[0]);\n\n      /**\n       * Emitted whenever an element is collected.\n       * @event Collector#collect\n       * @param {...*} args The arguments emitted by the listener\n       */\n      this.emit('collect', ...args);\n      if (this._idletimeout) {\n        this.client.clearTimeout(this._idletimeout);\n        this._idletimeout = this.client.setTimeout(() => this.stop('idle'), this.options.idle);\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#dispose\n   */\n  handleDispose() {\n    if (!this.options.dispose) return;\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    const dispose = this.dispose(...args);\n    if (!dispose || !this.filter(...args) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'user';\n    if (this.ended) return;\n    if (this._timeout) {\n      this.client.clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      this.client.clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Resets the collectors timeout and idle timer.\n   * @param {Object} [options] Options\n   * @param {number} [options.time] How long to run the collector for in milliseconds\n   * @param {number} [options.idle] How long to stop the collector after inactivity in milliseconds\n   */\n  resetTimer() {\n    let {\n      time,\n      idle\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this._timeout) {\n      this.client.clearTimeout(this._timeout);\n      this._timeout = this.client.setTimeout(() => this.stop('time'), time || this.options.time);\n    }\n    if (this._idletimeout) {\n      this.client.clearTimeout(this._idletimeout);\n      this._idletimeout = this.client.setTimeout(() => this.stop('idle'), idle || this.options.idle);\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   */\n  checkEnd() {\n    const reason = this.endReason();\n    if (reason) this.stop(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = item => queue.push(item);\n    this.on('collect', onCollect);\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n  toJSON() {\n    return Util.flatten(this);\n  }\n\n  /* eslint-disable no-empty-function, valid-jsdoc */\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?{key, value}} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n\n  /**\n   * The reason this collector has ended or will end with.\n   * @returns {?string} Reason to end the collector, if any\n   * @abstract\n   */\n  endReason() {}\n  /* eslint-enable no-empty-function, valid-jsdoc */\n}\n\nmodule.exports = Collector;","map":{"version":3,"names":["EventEmitter","require","Collection","Util","Collector","constructor","client","filter","options","Object","defineProperty","value","collected","ended","_timeout","_idletimeout","handleCollect","bind","handleDispose","time","setTimeout","stop","idle","args","collect","set","emit","clearTimeout","checkEnd","dispose","has","delete","next","Promise","resolve","reject","cleanup","removeListener","onCollect","onEnd","item","on","reason","resetTimer","endReason","Symbol","asyncIterator","queue","push","length","shift","tick","toJSON","flatten","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/interfaces/Collector.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst Collection = require('../../util/Collection');\nconst Util = require('../../util/Util');\n\n/**\n * Filter to be applied to the collector.\n * @typedef {Function} CollectorFilter\n * @param {...*} args Any arguments received by the listener\n * @param {Collection} collection The items collected by this collector\n * @returns {boolean|Promise<boolean>}\n */\n\n/**\n * Options to be applied to the collector.\n * @typedef {Object} CollectorOptions\n * @property {number} [time] How long to run the collector for in milliseconds\n * @property {number} [idle] How long to stop the collector after inactivity in milliseconds\n * @property {boolean} [dispose=false] Whether to dispose data when it's deleted\n */\n\n/**\n * Abstract class for defining a new Collector.\n * @abstract\n */\nclass Collector extends EventEmitter {\n  constructor(client, filter, options = {}) {\n    super();\n\n    /**\n     * The client that instantiated this Collector\n     * @name Collector#client\n     * @type {Client}\n     * @readonly\n     */\n    Object.defineProperty(this, 'client', { value: client });\n\n    /**\n     * The filter applied to this collector\n     * @type {CollectorFilter}\n     */\n    this.filter = filter;\n\n    /**\n     * The options of this collector\n     * @type {CollectorOptions}\n     */\n    this.options = options;\n\n    /**\n     * The items collected by this collector\n     * @type {Collection}\n     */\n    this.collected = new Collection();\n\n    /**\n     * Whether this collector has finished collecting\n     * @type {boolean}\n     */\n    this.ended = false;\n\n    /**\n     * Timeout for cleanup\n     * @type {?Timeout}\n     * @private\n     */\n    this._timeout = null;\n\n    /**\n     * Timeout for cleanup due to inactivity\n     * @type {?Timeout}\n     * @private\n     */\n    this._idletimeout = null;\n\n    this.handleCollect = this.handleCollect.bind(this);\n    this.handleDispose = this.handleDispose.bind(this);\n\n    if (options.time) this._timeout = this.client.setTimeout(() => this.stop('time'), options.time);\n    if (options.idle) this._idletimeout = this.client.setTimeout(() => this.stop('idle'), options.idle);\n  }\n\n  /**\n   * Call this to handle an event as a collectable element. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#collect\n   */\n  async handleCollect(...args) {\n    const collect = this.collect(...args);\n\n    if (collect && (await this.filter(...args, this.collected))) {\n      this.collected.set(collect, args[0]);\n\n      /**\n       * Emitted whenever an element is collected.\n       * @event Collector#collect\n       * @param {...*} args The arguments emitted by the listener\n       */\n      this.emit('collect', ...args);\n\n      if (this._idletimeout) {\n        this.client.clearTimeout(this._idletimeout);\n        this._idletimeout = this.client.setTimeout(() => this.stop('idle'), this.options.idle);\n      }\n    }\n    this.checkEnd();\n  }\n\n  /**\n   * Call this to remove an element from the collection. Accepts any event data as parameters.\n   * @param {...*} args The arguments emitted by the listener\n   * @emits Collector#dispose\n   */\n  handleDispose(...args) {\n    if (!this.options.dispose) return;\n\n    const dispose = this.dispose(...args);\n    if (!dispose || !this.filter(...args) || !this.collected.has(dispose)) return;\n    this.collected.delete(dispose);\n\n    /**\n     * Emitted whenever an element is disposed of.\n     * @event Collector#dispose\n     * @param {...*} args The arguments emitted by the listener\n     */\n    this.emit('dispose', ...args);\n    this.checkEnd();\n  }\n\n  /**\n   * Returns a promise that resolves with the next collected element;\n   * rejects with collected elements if the collector finishes without receiving a next element\n   * @type {Promise}\n   * @readonly\n   */\n  get next() {\n    return new Promise((resolve, reject) => {\n      if (this.ended) {\n        reject(this.collected);\n        return;\n      }\n\n      const cleanup = () => {\n        this.removeListener('collect', onCollect);\n        this.removeListener('end', onEnd);\n      };\n\n      const onCollect = item => {\n        cleanup();\n        resolve(item);\n      };\n\n      const onEnd = () => {\n        cleanup();\n        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors\n      };\n\n      this.on('collect', onCollect);\n      this.on('end', onEnd);\n    });\n  }\n\n  /**\n   * Stops this collector and emits the `end` event.\n   * @param {string} [reason='user'] The reason this collector is ending\n   * @emits Collector#end\n   */\n  stop(reason = 'user') {\n    if (this.ended) return;\n\n    if (this._timeout) {\n      this.client.clearTimeout(this._timeout);\n      this._timeout = null;\n    }\n    if (this._idletimeout) {\n      this.client.clearTimeout(this._idletimeout);\n      this._idletimeout = null;\n    }\n    this.ended = true;\n\n    /**\n     * Emitted when the collector is finished collecting.\n     * @event Collector#end\n     * @param {Collection} collected The elements collected by the collector\n     * @param {string} reason The reason the collector ended\n     */\n    this.emit('end', this.collected, reason);\n  }\n\n  /**\n   * Resets the collectors timeout and idle timer.\n   * @param {Object} [options] Options\n   * @param {number} [options.time] How long to run the collector for in milliseconds\n   * @param {number} [options.idle] How long to stop the collector after inactivity in milliseconds\n   */\n  resetTimer({ time, idle } = {}) {\n    if (this._timeout) {\n      this.client.clearTimeout(this._timeout);\n      this._timeout = this.client.setTimeout(() => this.stop('time'), time || this.options.time);\n    }\n    if (this._idletimeout) {\n      this.client.clearTimeout(this._idletimeout);\n      this._idletimeout = this.client.setTimeout(() => this.stop('idle'), idle || this.options.idle);\n    }\n  }\n\n  /**\n   * Checks whether the collector should end, and if so, ends it.\n   */\n  checkEnd() {\n    const reason = this.endReason();\n    if (reason) this.stop(reason);\n  }\n\n  /**\n   * Allows collectors to be consumed with for-await-of loops\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of}\n   */\n  async *[Symbol.asyncIterator]() {\n    const queue = [];\n    const onCollect = item => queue.push(item);\n    this.on('collect', onCollect);\n\n    try {\n      while (queue.length || !this.ended) {\n        if (queue.length) {\n          yield queue.shift();\n        } else {\n          // eslint-disable-next-line no-await-in-loop\n          await new Promise(resolve => {\n            const tick = () => {\n              this.removeListener('collect', tick);\n              this.removeListener('end', tick);\n              return resolve();\n            };\n            this.on('collect', tick);\n            this.on('end', tick);\n          });\n        }\n      }\n    } finally {\n      this.removeListener('collect', onCollect);\n    }\n  }\n\n  toJSON() {\n    return Util.flatten(this);\n  }\n\n  /* eslint-disable no-empty-function, valid-jsdoc */\n  /**\n   * Handles incoming events from the `handleCollect` function. Returns null if the event should not\n   * be collected, or returns an object describing the data that should be stored.\n   * @see Collector#handleCollect\n   * @param {...*} args Any args the event listener emits\n   * @returns {?{key, value}} Data to insert into collection, if any\n   * @abstract\n   */\n  collect() {}\n\n  /**\n   * Handles incoming events from the `handleDispose`. Returns null if the event should not\n   * be disposed, or returns the key that should be removed.\n   * @see Collector#handleDispose\n   * @param {...*} args Any args the event listener emits\n   * @returns {?*} Key to remove from the collection, if any\n   * @abstract\n   */\n  dispose() {}\n\n  /**\n   * The reason this collector has ended or will end with.\n   * @returns {?string} Reason to end the collector, if any\n   * @abstract\n   */\n  endReason() {}\n  /* eslint-enable no-empty-function, valid-jsdoc */\n}\n\nmodule.exports = Collector;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}