{"ast":null,"code":"'use strict';\n\n/* eslint-disable import/order */\nconst MessageCollector = require('../MessageCollector');\nconst APIMessage = require('../APIMessage');\nconst Snowflake = require('../../util/Snowflake');\nconst Collection = require('../../util/Collection');\nconst {\n  RangeError,\n  TypeError\n} = require('../../errors');\n\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\nclass TextBasedChannel {\n  constructor() {\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = null;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = null;\n  }\n\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    return this.messages.cache.get(this.lastMessageID) || null;\n  }\n\n  /**\n   * The date when the last pinned message was pinned, if there was one\n   * @type {?Date}\n   * @readonly\n   */\n  get lastPinAt() {\n    return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;\n  }\n\n  /**\n   * Options provided when sending or editing a message.\n   * @typedef {Object} MessageOptions\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {string} [content=''] The content for the message\n   * @property {MessageEmbed|Object} [embed] An embed for the message\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n   * everyone/here mentions should be sanitized to prevent unexpected mentions\n   * @property {FileOptions[]|BufferResolvable[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message\n   * @property {UserResolvable} [reply] User to reply to (prefixes the message with a mention, except in DMs)\n   */\n\n  /**\n   * Options provided to control parsing of mentions by Discord\n   * @typedef {Object} MessageMentionOptions\n   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n   */\n\n  /**\n   * Types of mentions to enable in MessageMentionOptions.\n   * - `roles`\n   * - `users`\n   * - `everyone`\n   * @typedef {string} MessageMentionTypes\n   */\n\n  /**\n   * The type of mentions to disable.\n   * - `none`\n   * - `all`\n   * - `everyone`\n   * @typedef {string} DisableMentionType\n   */\n\n  /**\n   * @typedef {Object} FileOptions\n   * @property {BufferResolvable} attachment File to attach\n   * @property {string} [name='file.jpg'] Filename of the attachment\n   */\n\n  /**\n   * Options for splitting a message.\n   * @typedef {Object} SplitOptions\n   * @property {number} [maxLength=2000] Maximum character length per message piece\n   * @property {string} [char='\\n'] Character to split the message with\n   * @property {string} [prepend=''] Text to prepend to every piece except the first\n   * @property {string} [append=''] Text to append to every piece except the last\n   */\n\n  /**\n   * Sends a message to this channel.\n   * @param {StringResolvable|APIMessage} [content=''] The content to send\n   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Send a basic message\n   * channel.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * channel.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * channel.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * channel.send('This is an embed', {\n   *   embed: {\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    },\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(content, options) {\n    const User = require('../User');\n    const GuildMember = require('../GuildMember');\n    if (this instanceof User || this instanceof GuildMember) {\n      return this.createDM().then(dm => dm.send(content, options));\n    }\n    let apiMessage;\n    if (content instanceof APIMessage) {\n      apiMessage = content.resolveData();\n    } else {\n      apiMessage = APIMessage.create(this, content, options).resolveData();\n      if (Array.isArray(apiMessage.data.content)) {\n        return Promise.all(apiMessage.split().map(this.send.bind(this)));\n      }\n    }\n    const {\n      data,\n      files\n    } = await apiMessage.resolveFiles();\n    return this.client.api.channels[this.id].messages.post({\n      data,\n      files\n    }).then(d => this.client.actions.MessageCreate.handle(d).message);\n  }\n\n  /**\n   * Starts a typing indicator in the channel.\n   * @param {number} [count=1] The number of times startTyping should be considered to have been called\n   * @returns {Promise} Resolves once the bot stops typing gracefully, or rejects when an error occurs\n   * @example\n   * // Start typing in a channel, or increase the typing count by one\n   * channel.startTyping();\n   * @example\n   * // Start typing in a channel with a typing count of five, or set it to five\n   * channel.startTyping(5);\n   */\n  startTyping(count) {\n    if (typeof count !== 'undefined' && count < 1) throw new RangeError('TYPING_COUNT');\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n      entry.count = count || entry.count + 1;\n      return entry.promise;\n    }\n    const entry = {};\n    entry.promise = new Promise((resolve, reject) => {\n      const endpoint = this.client.api.channels[this.id].typing;\n      Object.assign(entry, {\n        count: count || 1,\n        interval: this.client.setInterval(() => {\n          endpoint.post().catch(error => {\n            this.client.clearInterval(entry.interval);\n            this.client.user._typing.delete(this.id);\n            reject(error);\n          });\n        }, 9000),\n        resolve\n      });\n      endpoint.post().catch(error => {\n        this.client.clearInterval(entry.interval);\n        this.client.user._typing.delete(this.id);\n        reject(error);\n      });\n      this.client.user._typing.set(this.id, entry);\n    });\n    return entry.promise;\n  }\n\n  /**\n   * Stops the typing indicator in the channel.\n   * The indicator will only stop if this is called as many times as startTyping().\n   * <info>It can take a few seconds for the client user to stop typing.</info>\n   * @param {boolean} [force=false] Whether or not to reset the call count and force the indicator to stop\n   * @example\n   * // Reduce the typing count by one and stop typing if it reached 0\n   * channel.stopTyping();\n   * @example\n   * // Force typing to fully stop regardless of typing count\n   * channel.stopTyping(true);\n   */\n  stopTyping() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n      entry.count--;\n      if (entry.count <= 0 || force) {\n        this.client.clearInterval(entry.interval);\n        this.client.user._typing.delete(this.id);\n        entry.resolve();\n      }\n    }\n  }\n\n  /**\n   * Whether or not the typing indicator is being shown in the channel\n   * @type {boolean}\n   * @readonly\n   */\n  get typing() {\n    return this.client.user._typing.has(this.id);\n  }\n\n  /**\n   * Number of times `startTyping` has been called\n   * @type {number}\n   * @readonly\n   */\n  get typingCount() {\n    if (this.client.user._typing.has(this.id)) return this.client.user._typing.get(this.id).count;\n    return 0;\n  }\n\n  /**\n   * Creates a Message Collector.\n   * @param {CollectorFilter} filter The filter to create the collector with\n   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n   * @returns {MessageCollector}\n   * @example\n   * // Create a message collector\n   * const filter = m => m.content.includes('discord');\n   * const collector = channel.createMessageCollector(filter, { time: 15000 });\n   * collector.on('collect', m => console.log(`Collected ${m.content}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageCollector(filter) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new MessageCollector(this, filter, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of messages that pass the specified filter.\n   * @param {CollectorFilter} filter The filter function to use\n   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Await !vote messages\n   * const filter = m => m.content.startsWith('!vote');\n   * // Errors: ['time'] treats ending because of the time limit as an error\n   * channel.awaitMessages(filter, { max: 4, time: 60000, errors: ['time'] })\n   *   .then(collected => console.log(collected.size))\n   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n   */\n  awaitMessages(filter) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageCollector(filter, options);\n      collector.once('end', (collection, reason) => {\n        if (options.errors && options.errors.includes(reason)) {\n          reject(collection);\n        } else {\n          resolve(collection);\n        }\n      });\n    });\n  }\n\n  /**\n   * Bulk deletes given messages that are newer than two weeks.\n   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages\n   * Messages or number of messages to delete\n   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n   * @returns {Promise<Collection<Snowflake, Message>>} Deleted messages\n   * @example\n   * // Bulk delete messages\n   * channel.bulkDelete(5)\n   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  async bulkDelete(messages) {\n    let filterOld = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (Array.isArray(messages) || messages instanceof Collection) {\n      let messageIDs = messages instanceof Collection ? messages.keyArray() : messages.map(m => m.id || m);\n      if (filterOld) {\n        messageIDs = messageIDs.filter(id => Date.now() - Snowflake.deconstruct(id).date.getTime() < 1209600000);\n      }\n      if (messageIDs.length === 0) return new Collection();\n      if (messageIDs.length === 1) {\n        await this.client.api.channels(this.id).messages(messageIDs[0]).delete();\n        const message = this.client.actions.MessageDelete.getMessage({\n          message_id: messageIDs[0]\n        }, this);\n        return message ? new Collection([[message.id, message]]) : new Collection();\n      }\n      await this.client.api.channels[this.id].messages['bulk-delete'].post({\n        data: {\n          messages: messageIDs\n        }\n      });\n      return messageIDs.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({\n        message_id: id\n      }, this)), new Collection());\n    }\n    if (!isNaN(messages)) {\n      const msgs = await this.messages.fetch({\n        limit: messages\n      });\n      return this.bulkDelete(msgs, filterOld);\n    }\n    throw new TypeError('MESSAGE_BULK_DELETE_TYPE');\n  }\n  static applyToClass(structure) {\n    let full = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let ignore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    const props = ['send'];\n    if (full) {\n      props.push('lastMessage', 'lastPinAt', 'bulkDelete', 'startTyping', 'stopTyping', 'typing', 'typingCount', 'createMessageCollector', 'awaitMessages');\n    }\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));\n    }\n  }\n}\nmodule.exports = TextBasedChannel;\n\n// Fixes Circular\nconst MessageManager = require('../../managers/MessageManager');","map":{"version":3,"names":["MessageCollector","require","APIMessage","Snowflake","Collection","RangeError","TypeError","TextBasedChannel","constructor","messages","MessageManager","lastMessageID","lastPinTimestamp","lastMessage","cache","get","lastPinAt","Date","send","content","options","User","GuildMember","createDM","then","dm","apiMessage","resolveData","create","Array","isArray","data","Promise","all","split","map","bind","files","resolveFiles","client","api","channels","id","post","d","actions","MessageCreate","handle","message","startTyping","count","user","_typing","has","entry","promise","resolve","reject","endpoint","typing","Object","assign","interval","setInterval","catch","error","clearInterval","delete","set","stopTyping","force","typingCount","createMessageCollector","filter","awaitMessages","collector","once","collection","reason","errors","includes","bulkDelete","filterOld","messageIDs","keyArray","m","now","deconstruct","date","getTime","length","MessageDelete","getMessage","message_id","reduce","col","MessageDeleteBulk","isNaN","msgs","fetch","limit","applyToClass","structure","full","ignore","props","push","prop","defineProperty","prototype","getOwnPropertyDescriptor","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js"],"sourcesContent":["'use strict';\n\n/* eslint-disable import/order */\nconst MessageCollector = require('../MessageCollector');\nconst APIMessage = require('../APIMessage');\nconst Snowflake = require('../../util/Snowflake');\nconst Collection = require('../../util/Collection');\nconst { RangeError, TypeError } = require('../../errors');\n\n/**\n * Interface for classes that have text-channel-like features.\n * @interface\n */\nclass TextBasedChannel {\n  constructor() {\n    /**\n     * A manager of the messages sent to this channel\n     * @type {MessageManager}\n     */\n    this.messages = new MessageManager(this);\n\n    /**\n     * The ID of the last message in the channel, if one was sent\n     * @type {?Snowflake}\n     */\n    this.lastMessageID = null;\n\n    /**\n     * The timestamp when the last pinned message was pinned, if there was one\n     * @type {?number}\n     */\n    this.lastPinTimestamp = null;\n  }\n\n  /**\n   * The Message object of the last message in the channel, if one was sent\n   * @type {?Message}\n   * @readonly\n   */\n  get lastMessage() {\n    return this.messages.cache.get(this.lastMessageID) || null;\n  }\n\n  /**\n   * The date when the last pinned message was pinned, if there was one\n   * @type {?Date}\n   * @readonly\n   */\n  get lastPinAt() {\n    return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;\n  }\n\n  /**\n   * Options provided when sending or editing a message.\n   * @typedef {Object} MessageOptions\n   * @property {boolean} [tts=false] Whether or not the message should be spoken aloud\n   * @property {string} [nonce=''] The nonce for the message\n   * @property {string} [content=''] The content for the message\n   * @property {MessageEmbed|Object} [embed] An embed for the message\n   * (see [here](https://discord.com/developers/docs/resources/channel#embed-object) for more details)\n   * @property {MessageMentionOptions} [allowedMentions] Which mentions should be parsed from the message content\n   * @property {DisableMentionType} [disableMentions=this.client.options.disableMentions] Whether or not all mentions or\n   * everyone/here mentions should be sanitized to prevent unexpected mentions\n   * @property {FileOptions[]|BufferResolvable[]} [files] Files to send with the message\n   * @property {string|boolean} [code] Language for optional codeblock formatting to apply\n   * @property {boolean|SplitOptions} [split=false] Whether or not the message should be split into multiple messages if\n   * it exceeds the character limit. If an object is provided, these are the options for splitting the message\n   * @property {UserResolvable} [reply] User to reply to (prefixes the message with a mention, except in DMs)\n   */\n\n  /**\n   * Options provided to control parsing of mentions by Discord\n   * @typedef {Object} MessageMentionOptions\n   * @property {MessageMentionTypes[]} [parse] Types of mentions to be parsed\n   * @property {Snowflake[]} [users] Snowflakes of Users to be parsed as mentions\n   * @property {Snowflake[]} [roles] Snowflakes of Roles to be parsed as mentions\n   */\n\n  /**\n   * Types of mentions to enable in MessageMentionOptions.\n   * - `roles`\n   * - `users`\n   * - `everyone`\n   * @typedef {string} MessageMentionTypes\n   */\n\n  /**\n   * The type of mentions to disable.\n   * - `none`\n   * - `all`\n   * - `everyone`\n   * @typedef {string} DisableMentionType\n   */\n\n  /**\n   * @typedef {Object} FileOptions\n   * @property {BufferResolvable} attachment File to attach\n   * @property {string} [name='file.jpg'] Filename of the attachment\n   */\n\n  /**\n   * Options for splitting a message.\n   * @typedef {Object} SplitOptions\n   * @property {number} [maxLength=2000] Maximum character length per message piece\n   * @property {string} [char='\\n'] Character to split the message with\n   * @property {string} [prepend=''] Text to prepend to every piece except the first\n   * @property {string} [append=''] Text to append to every piece except the last\n   */\n\n  /**\n   * Sends a message to this channel.\n   * @param {StringResolvable|APIMessage} [content=''] The content to send\n   * @param {MessageOptions|MessageAdditions} [options={}] The options to provide\n   * @returns {Promise<Message|Message[]>}\n   * @example\n   * // Send a basic message\n   * channel.send('hello!')\n   *   .then(message => console.log(`Sent message: ${message.content}`))\n   *   .catch(console.error);\n   * @example\n   * // Send a remote file\n   * channel.send({\n   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send a local file\n   * channel.send({\n   *   files: [{\n   *     attachment: 'entire/path/to/file.jpg',\n   *     name: 'file.jpg'\n   *   }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Send an embed with a local image inside\n   * channel.send('This is an embed', {\n   *   embed: {\n   *     thumbnail: {\n   *          url: 'attachment://file.jpg'\n   *       }\n   *    },\n   *    files: [{\n   *       attachment: 'entire/path/to/file.jpg',\n   *       name: 'file.jpg'\n   *    }]\n   * })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  async send(content, options) {\n    const User = require('../User');\n    const GuildMember = require('../GuildMember');\n\n    if (this instanceof User || this instanceof GuildMember) {\n      return this.createDM().then(dm => dm.send(content, options));\n    }\n\n    let apiMessage;\n\n    if (content instanceof APIMessage) {\n      apiMessage = content.resolveData();\n    } else {\n      apiMessage = APIMessage.create(this, content, options).resolveData();\n      if (Array.isArray(apiMessage.data.content)) {\n        return Promise.all(apiMessage.split().map(this.send.bind(this)));\n      }\n    }\n\n    const { data, files } = await apiMessage.resolveFiles();\n    return this.client.api.channels[this.id].messages\n      .post({ data, files })\n      .then(d => this.client.actions.MessageCreate.handle(d).message);\n  }\n\n  /**\n   * Starts a typing indicator in the channel.\n   * @param {number} [count=1] The number of times startTyping should be considered to have been called\n   * @returns {Promise} Resolves once the bot stops typing gracefully, or rejects when an error occurs\n   * @example\n   * // Start typing in a channel, or increase the typing count by one\n   * channel.startTyping();\n   * @example\n   * // Start typing in a channel with a typing count of five, or set it to five\n   * channel.startTyping(5);\n   */\n  startTyping(count) {\n    if (typeof count !== 'undefined' && count < 1) throw new RangeError('TYPING_COUNT');\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n      entry.count = count || entry.count + 1;\n      return entry.promise;\n    }\n\n    const entry = {};\n    entry.promise = new Promise((resolve, reject) => {\n      const endpoint = this.client.api.channels[this.id].typing;\n      Object.assign(entry, {\n        count: count || 1,\n        interval: this.client.setInterval(() => {\n          endpoint.post().catch(error => {\n            this.client.clearInterval(entry.interval);\n            this.client.user._typing.delete(this.id);\n            reject(error);\n          });\n        }, 9000),\n        resolve,\n      });\n      endpoint.post().catch(error => {\n        this.client.clearInterval(entry.interval);\n        this.client.user._typing.delete(this.id);\n        reject(error);\n      });\n      this.client.user._typing.set(this.id, entry);\n    });\n    return entry.promise;\n  }\n\n  /**\n   * Stops the typing indicator in the channel.\n   * The indicator will only stop if this is called as many times as startTyping().\n   * <info>It can take a few seconds for the client user to stop typing.</info>\n   * @param {boolean} [force=false] Whether or not to reset the call count and force the indicator to stop\n   * @example\n   * // Reduce the typing count by one and stop typing if it reached 0\n   * channel.stopTyping();\n   * @example\n   * // Force typing to fully stop regardless of typing count\n   * channel.stopTyping(true);\n   */\n  stopTyping(force = false) {\n    if (this.client.user._typing.has(this.id)) {\n      const entry = this.client.user._typing.get(this.id);\n      entry.count--;\n      if (entry.count <= 0 || force) {\n        this.client.clearInterval(entry.interval);\n        this.client.user._typing.delete(this.id);\n        entry.resolve();\n      }\n    }\n  }\n\n  /**\n   * Whether or not the typing indicator is being shown in the channel\n   * @type {boolean}\n   * @readonly\n   */\n  get typing() {\n    return this.client.user._typing.has(this.id);\n  }\n\n  /**\n   * Number of times `startTyping` has been called\n   * @type {number}\n   * @readonly\n   */\n  get typingCount() {\n    if (this.client.user._typing.has(this.id)) return this.client.user._typing.get(this.id).count;\n    return 0;\n  }\n\n  /**\n   * Creates a Message Collector.\n   * @param {CollectorFilter} filter The filter to create the collector with\n   * @param {MessageCollectorOptions} [options={}] The options to pass to the collector\n   * @returns {MessageCollector}\n   * @example\n   * // Create a message collector\n   * const filter = m => m.content.includes('discord');\n   * const collector = channel.createMessageCollector(filter, { time: 15000 });\n   * collector.on('collect', m => console.log(`Collected ${m.content}`));\n   * collector.on('end', collected => console.log(`Collected ${collected.size} items`));\n   */\n  createMessageCollector(filter, options = {}) {\n    return new MessageCollector(this, filter, options);\n  }\n\n  /**\n   * An object containing the same properties as CollectorOptions, but a few more:\n   * @typedef {MessageCollectorOptions} AwaitMessagesOptions\n   * @property {string[]} [errors] Stop/end reasons that cause the promise to reject\n   */\n\n  /**\n   * Similar to createMessageCollector but in promise form.\n   * Resolves with a collection of messages that pass the specified filter.\n   * @param {CollectorFilter} filter The filter function to use\n   * @param {AwaitMessagesOptions} [options={}] Optional options to pass to the internal collector\n   * @returns {Promise<Collection<Snowflake, Message>>}\n   * @example\n   * // Await !vote messages\n   * const filter = m => m.content.startsWith('!vote');\n   * // Errors: ['time'] treats ending because of the time limit as an error\n   * channel.awaitMessages(filter, { max: 4, time: 60000, errors: ['time'] })\n   *   .then(collected => console.log(collected.size))\n   *   .catch(collected => console.log(`After a minute, only ${collected.size} out of 4 voted.`));\n   */\n  awaitMessages(filter, options = {}) {\n    return new Promise((resolve, reject) => {\n      const collector = this.createMessageCollector(filter, options);\n      collector.once('end', (collection, reason) => {\n        if (options.errors && options.errors.includes(reason)) {\n          reject(collection);\n        } else {\n          resolve(collection);\n        }\n      });\n    });\n  }\n\n  /**\n   * Bulk deletes given messages that are newer than two weeks.\n   * @param {Collection<Snowflake, Message>|MessageResolvable[]|number} messages\n   * Messages or number of messages to delete\n   * @param {boolean} [filterOld=false] Filter messages to remove those which are older than two weeks automatically\n   * @returns {Promise<Collection<Snowflake, Message>>} Deleted messages\n   * @example\n   * // Bulk delete messages\n   * channel.bulkDelete(5)\n   *   .then(messages => console.log(`Bulk deleted ${messages.size} messages`))\n   *   .catch(console.error);\n   */\n  async bulkDelete(messages, filterOld = false) {\n    if (Array.isArray(messages) || messages instanceof Collection) {\n      let messageIDs = messages instanceof Collection ? messages.keyArray() : messages.map(m => m.id || m);\n      if (filterOld) {\n        messageIDs = messageIDs.filter(id => Date.now() - Snowflake.deconstruct(id).date.getTime() < 1209600000);\n      }\n      if (messageIDs.length === 0) return new Collection();\n      if (messageIDs.length === 1) {\n        await this.client.api.channels(this.id).messages(messageIDs[0]).delete();\n        const message = this.client.actions.MessageDelete.getMessage(\n          {\n            message_id: messageIDs[0],\n          },\n          this,\n        );\n        return message ? new Collection([[message.id, message]]) : new Collection();\n      }\n      await this.client.api.channels[this.id].messages['bulk-delete'].post({ data: { messages: messageIDs } });\n      return messageIDs.reduce(\n        (col, id) =>\n          col.set(\n            id,\n            this.client.actions.MessageDeleteBulk.getMessage(\n              {\n                message_id: id,\n              },\n              this,\n            ),\n          ),\n        new Collection(),\n      );\n    }\n    if (!isNaN(messages)) {\n      const msgs = await this.messages.fetch({ limit: messages });\n      return this.bulkDelete(msgs, filterOld);\n    }\n    throw new TypeError('MESSAGE_BULK_DELETE_TYPE');\n  }\n\n  static applyToClass(structure, full = false, ignore = []) {\n    const props = ['send'];\n    if (full) {\n      props.push(\n        'lastMessage',\n        'lastPinAt',\n        'bulkDelete',\n        'startTyping',\n        'stopTyping',\n        'typing',\n        'typingCount',\n        'createMessageCollector',\n        'awaitMessages',\n      );\n    }\n    for (const prop of props) {\n      if (ignore.includes(prop)) continue;\n      Object.defineProperty(\n        structure.prototype,\n        prop,\n        Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop),\n      );\n    }\n  }\n}\n\nmodule.exports = TextBasedChannel;\n\n// Fixes Circular\nconst MessageManager = require('../../managers/MessageManager');\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA,MAAMA,gBAAgB,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AACvD,MAAMC,UAAU,GAAGD,OAAO,CAAC,eAAe,CAAC;AAC3C,MAAME,SAAS,GAAGF,OAAO,CAAC,sBAAsB,CAAC;AACjD,MAAMG,UAAU,GAAGH,OAAO,CAAC,uBAAuB,CAAC;AACnD,MAAM;EAAEI,UAAU;EAAEC;AAAU,CAAC,GAAGL,OAAO,CAAC,cAAc,CAAC;;AAEzD;AACA;AACA;AACA;AACA,MAAMM,gBAAgB,CAAC;EACrBC,WAAW,GAAG;IACZ;AACJ;AACA;AACA;IACI,IAAI,CAACC,QAAQ,GAAG,IAAIC,cAAc,CAAC,IAAI,CAAC;;IAExC;AACJ;AACA;AACA;IACI,IAAI,CAACC,aAAa,GAAG,IAAI;;IAEzB;AACJ;AACA;AACA;IACI,IAAI,CAACC,gBAAgB,GAAG,IAAI;EAC9B;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIC,WAAW,GAAG;IAChB,OAAO,IAAI,CAACJ,QAAQ,CAACK,KAAK,CAACC,GAAG,CAAC,IAAI,CAACJ,aAAa,CAAC,IAAI,IAAI;EAC5D;;EAEA;AACF;AACA;AACA;AACA;EACE,IAAIK,SAAS,GAAG;IACd,OAAO,IAAI,CAACJ,gBAAgB,GAAG,IAAIK,IAAI,CAAC,IAAI,CAACL,gBAAgB,CAAC,GAAG,IAAI;EACvE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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"},"metadata":{},"sourceType":"script","externalDependencies":[]}