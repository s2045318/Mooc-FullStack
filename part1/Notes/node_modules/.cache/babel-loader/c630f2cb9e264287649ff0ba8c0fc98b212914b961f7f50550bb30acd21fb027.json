{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst Channel = require('../structures/Channel');\nconst {\n  Events\n} = require('../util/Constants');\n\n/**\n * A manager of channels belonging to a client\n * @extends {BaseManager}\n */\nclass ChannelManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, Channel);\n  }\n\n  /**\n   * The cache of Channels\n   * @type {Collection<Snowflake, Channel>}\n   * @name ChannelManager#cache\n   */\n\n  add(data, guild) {\n    let cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const existing = this.cache.get(data.id);\n    if (existing) {\n      if (existing._patch && cache) existing._patch(data);\n      if (guild) guild.channels.add(existing);\n      return existing;\n    }\n    const channel = Channel.create(this.client, data, guild);\n    if (!channel) {\n      this.client.emit(Events.DEBUG, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);\n      return null;\n    }\n    if (cache) this.cache.set(channel.id, channel);\n    return channel;\n  }\n  remove(id) {\n    const channel = this.cache.get(id);\n    if (channel.guild) channel.guild.channels.cache.delete(id);\n    this.cache.delete(id);\n  }\n\n  /**\n   * Data that can be resolved to give a Channel object. This can be:\n   * * A Channel object\n   * * A Snowflake\n   * @typedef {Channel|Snowflake} ChannelResolvable\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Channel}\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a channel ID string.\n   * @method resolveID\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Obtains a channel from Discord, or the channel cache if it's already available.\n   * @param {Snowflake} id ID of the channel\n   * @param {boolean} [cache=true] Whether to cache the new channel object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Channel>}\n   * @example\n   * // Fetch a channel by its id\n   * client.channels.fetch('222109930545610754')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  async fetch(id) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n    const data = await this.client.api.channels(id).get();\n    return this.add(data, null, cache);\n  }\n}\nmodule.exports = ChannelManager;","map":{"version":3,"names":["BaseManager","require","Channel","Events","ChannelManager","constructor","client","iterable","add","data","guild","cache","existing","get","id","_patch","channels","channel","create","emit","DEBUG","type","set","remove","delete","fetch","force","partial","api","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/managers/ChannelManager.js"],"sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst Channel = require('../structures/Channel');\nconst { Events } = require('../util/Constants');\n\n/**\n * A manager of channels belonging to a client\n * @extends {BaseManager}\n */\nclass ChannelManager extends BaseManager {\n  constructor(client, iterable) {\n    super(client, iterable, Channel);\n  }\n\n  /**\n   * The cache of Channels\n   * @type {Collection<Snowflake, Channel>}\n   * @name ChannelManager#cache\n   */\n\n  add(data, guild, cache = true) {\n    const existing = this.cache.get(data.id);\n    if (existing) {\n      if (existing._patch && cache) existing._patch(data);\n      if (guild) guild.channels.add(existing);\n      return existing;\n    }\n\n    const channel = Channel.create(this.client, data, guild);\n\n    if (!channel) {\n      this.client.emit(Events.DEBUG, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);\n      return null;\n    }\n\n    if (cache) this.cache.set(channel.id, channel);\n\n    return channel;\n  }\n\n  remove(id) {\n    const channel = this.cache.get(id);\n    if (channel.guild) channel.guild.channels.cache.delete(id);\n    this.cache.delete(id);\n  }\n\n  /**\n   * Data that can be resolved to give a Channel object. This can be:\n   * * A Channel object\n   * * A Snowflake\n   * @typedef {Channel|Snowflake} ChannelResolvable\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a Channel object.\n   * @method resolve\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Channel}\n   */\n\n  /**\n   * Resolves a ChannelResolvable to a channel ID string.\n   * @method resolveID\n   * @memberof ChannelManager\n   * @instance\n   * @param {ChannelResolvable} channel The channel resolvable to resolve\n   * @returns {?Snowflake}\n   */\n\n  /**\n   * Obtains a channel from Discord, or the channel cache if it's already available.\n   * @param {Snowflake} id ID of the channel\n   * @param {boolean} [cache=true] Whether to cache the new channel object if it isn't already\n   * @param {boolean} [force=false] Whether to skip the cache check and request the API\n   * @returns {Promise<Channel>}\n   * @example\n   * // Fetch a channel by its id\n   * client.channels.fetch('222109930545610754')\n   *   .then(channel => console.log(channel.name))\n   *   .catch(console.error);\n   */\n  async fetch(id, cache = true, force = false) {\n    if (!force) {\n      const existing = this.cache.get(id);\n      if (existing && !existing.partial) return existing;\n    }\n\n    const data = await this.client.api.channels(id).get();\n    return this.add(data, null, cache);\n  }\n}\n\nmodule.exports = ChannelManager;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,WAAW,GAAGC,OAAO,CAAC,eAAe,CAAC;AAC5C,MAAMC,OAAO,GAAGD,OAAO,CAAC,uBAAuB,CAAC;AAChD,MAAM;EAAEE;AAAO,CAAC,GAAGF,OAAO,CAAC,mBAAmB,CAAC;;AAE/C;AACA;AACA;AACA;AACA,MAAMG,cAAc,SAASJ,WAAW,CAAC;EACvCK,WAAW,CAACC,MAAM,EAAEC,QAAQ,EAAE;IAC5B,KAAK,CAACD,MAAM,EAAEC,QAAQ,EAAEL,OAAO,CAAC;EAClC;;EAEA;AACF;AACA;AACA;AACA;;EAEEM,GAAG,CAACC,IAAI,EAAEC,KAAK,EAAgB;IAAA,IAAdC,KAAK,uEAAG,IAAI;IAC3B,MAAMC,QAAQ,GAAG,IAAI,CAACD,KAAK,CAACE,GAAG,CAACJ,IAAI,CAACK,EAAE,CAAC;IACxC,IAAIF,QAAQ,EAAE;MACZ,IAAIA,QAAQ,CAACG,MAAM,IAAIJ,KAAK,EAAEC,QAAQ,CAACG,MAAM,CAACN,IAAI,CAAC;MACnD,IAAIC,KAAK,EAAEA,KAAK,CAACM,QAAQ,CAACR,GAAG,CAACI,QAAQ,CAAC;MACvC,OAAOA,QAAQ;IACjB;IAEA,MAAMK,OAAO,GAAGf,OAAO,CAACgB,MAAM,CAAC,IAAI,CAACZ,MAAM,EAAEG,IAAI,EAAEC,KAAK,CAAC;IAExD,IAAI,CAACO,OAAO,EAAE;MACZ,IAAI,CAACX,MAAM,CAACa,IAAI,CAAChB,MAAM,CAACiB,KAAK,EAAG,qDAAoDX,IAAI,CAACK,EAAG,IAAGL,IAAI,CAACY,IAAK,EAAC,CAAC;MAC3G,OAAO,IAAI;IACb;IAEA,IAAIV,KAAK,EAAE,IAAI,CAACA,KAAK,CAACW,GAAG,CAACL,OAAO,CAACH,EAAE,EAAEG,OAAO,CAAC;IAE9C,OAAOA,OAAO;EAChB;EAEAM,MAAM,CAACT,EAAE,EAAE;IACT,MAAMG,OAAO,GAAG,IAAI,CAACN,KAAK,CAACE,GAAG,CAACC,EAAE,CAAC;IAClC,IAAIG,OAAO,CAACP,KAAK,EAAEO,OAAO,CAACP,KAAK,CAACM,QAAQ,CAACL,KAAK,CAACa,MAAM,CAACV,EAAE,CAAC;IAC1D,IAAI,CAACH,KAAK,CAACa,MAAM,CAACV,EAAE,CAAC;EACvB;;EAEA;AACF;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMW,KAAK,CAACX,EAAE,EAA+B;IAAA,IAA7BH,KAAK,uEAAG,IAAI;IAAA,IAAEe,KAAK,uEAAG,KAAK;IACzC,IAAI,CAACA,KAAK,EAAE;MACV,MAAMd,QAAQ,GAAG,IAAI,CAACD,KAAK,CAACE,GAAG,CAACC,EAAE,CAAC;MACnC,IAAIF,QAAQ,IAAI,CAACA,QAAQ,CAACe,OAAO,EAAE,OAAOf,QAAQ;IACpD;IAEA,MAAMH,IAAI,GAAG,MAAM,IAAI,CAACH,MAAM,CAACsB,GAAG,CAACZ,QAAQ,CAACF,EAAE,CAAC,CAACD,GAAG,EAAE;IACrD,OAAO,IAAI,CAACL,GAAG,CAACC,IAAI,EAAE,IAAI,EAAEE,KAAK,CAAC;EACpC;AACF;AAEAkB,MAAM,CAACC,OAAO,GAAG1B,cAAc"},"metadata":{},"sourceType":"script","externalDependencies":[]}