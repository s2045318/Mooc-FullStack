{"ast":null,"code":"'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst {\n  Error,\n  TypeError,\n  RangeError\n} = require('../errors');\nconst GuildMember = require('../structures/GuildMember');\nconst Collection = require('../util/Collection');\nconst {\n  Events,\n  OPCodes\n} = require('../util/Constants');\nconst SnowflakeUtil = require('../util/Snowflake');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {BaseManager}\n */\nclass GuildMemberManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, GuildMember);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n  add(data) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return super.add(data, cache, {\n      id: data.user.id,\n      extras: [this.guild]\n    });\n  }\n\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a GuildMemberResolvable to a GuildMember object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveID(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a GuildMemberResolvable to a member ID string.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveID(member) {\n    const memberResolvable = super.resolveID(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveID(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {Object} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch\n   * @property {?string} query Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether or not to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Fetches member(s) from Discord, even if they're offline.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.\n   * If undefined, fetches all members.\n   * If a query, it limits the results to users with similar usernames.\n   * @returns {Promise<GuildMember>|Promise<Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const user = this.client.users.resolveID(options);\n    if (user) return this._fetchSingle({\n      user,\n      cache: true\n    });\n    if (options.user) {\n      if (Array.isArray(options.user)) {\n        options.user = options.user.map(u => this.client.users.resolveID(u));\n        return this._fetchMany(options);\n      } else {\n        options.user = this.client.users.resolveID(options.user);\n      }\n      if (!options.limit && !options.withPresences) return this._fetchSingle(options);\n    }\n    return this._fetchMany(options);\n  }\n\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * <info>It's recommended to set options.count to `false` for large guilds.</info>\n   * @param {Object} [options] Prune options\n   * @param {number} [options.days=7] Number of days of inactivity required to kick\n   * @param {boolean} [options.dry=false] Get number of users that will be kicked, without actually kicking them\n   * @param {boolean} [options.count=true] Whether or not to return the number of users that have been kicked.\n   * @param {RoleResolvable[]} [options.roles=[]] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @param {string} [options.reason] Reason for this prune\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n  prune() {\n    let {\n      days = 7,\n      dry = false,\n      count: compute_prune_count = true,\n      roles = [],\n      reason\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (typeof days !== 'number') throw new TypeError('PRUNE_DAYS_TYPE');\n    const query = {\n      days\n    };\n    const resolvedRoles = [];\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveID(role);\n      if (!resolvedRole) {\n        return Promise.reject(new TypeError('INVALID_TYPE', 'roles', 'Array of Roles or Snowflakes', true));\n      }\n      resolvedRoles.push(resolvedRole);\n    }\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n    const endpoint = this.client.api.guilds(this.guild.id).prune;\n    if (dry) {\n      return endpoint.get({\n        query,\n        reason\n      }).then(data => data.pruned);\n    }\n    return endpoint.post({\n      data: {\n        ...query,\n        compute_prune_count\n      },\n      reason\n    }).then(data => data.pruned);\n  }\n\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {Object} [options] Options for the ban\n   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7\n   * @param {string} [options.reason] Reason for banning\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user ID will be the result.\n   * @example\n   * // Ban a user by ID (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(user => console.log(`Banned ${user.username || user.id || user} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  ban(user) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      days: 0\n    };\n    if (options.days) options.delete_message_days = options.days;\n    const id = this.client.users.resolveID(user);\n    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID', true));\n    return this.client.api.guilds(this.guild.id).bans[id].put({\n      data: options\n    }).then(() => {\n      if (user instanceof GuildMember) return user;\n      const _user = this.client.users.resolve(id);\n      if (_user) {\n        const member = this.resolve(_user);\n        return member || _user;\n      }\n      return id;\n    });\n  }\n\n  /**\n   * Unbans a user from the guild.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<User>}\n   * @example\n   * // Unban a user by ID (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  unban(user, reason) {\n    const id = this.client.users.resolveID(user);\n    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID'));\n    return this.client.api.guilds(this.guild.id).bans[id].delete({\n      reason\n    }).then(() => this.client.users.resolve(user));\n  }\n  _fetchSingle(_ref) {\n    let {\n      user,\n      cache,\n      force = false\n    } = _ref;\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return Promise.resolve(existing);\n    }\n    return this.client.api.guilds(this.guild.id).members(user).get().then(data => this.add(data, cache));\n  }\n  _fetchMany() {\n    let {\n      limit = 0,\n      withPresences: presences = false,\n      user: user_ids,\n      query,\n      time = 120e3,\n      nonce = SnowflakeUtil.generate(),\n      force = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Promise((resolve, reject) => {\n      if (this.guild.memberCount === this.cache.size && !query && !limit && !presences && !user_ids && !force) {\n        resolve(this.cache);\n        return;\n      }\n      if (!query && !user_ids) query = '';\n      if (nonce.length > 32) throw new RangeError('MEMBER_FETCH_NONCE_LENGTH');\n      this.guild.shard.send({\n        op: OPCodes.REQUEST_GUILD_MEMBERS,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids,\n          query,\n          nonce,\n          limit\n        }\n      });\n      const fetchedMembers = new Collection();\n      const option = query || limit || presences || user_ids;\n      let i = 0;\n      const handler = (members, _, chunk) => {\n        timeout.refresh();\n        if (chunk.nonce !== nonce) return;\n        i++;\n        for (const member of members.values()) {\n          if (option) fetchedMembers.set(member.id, member);\n        }\n        if (this.guild.memberCount <= this.cache.size || option && members.size < 1000 || limit && fetchedMembers.size >= limit || i === chunk.count) {\n          this.client.clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n          this.client.decrementMaxListeners();\n          let fetched = option ? fetchedMembers : this.cache;\n          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();\n          resolve(fetched);\n        }\n      };\n      const timeout = this.client.setTimeout(() => {\n        this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n        this.client.decrementMaxListeners();\n        reject(new Error('GUILD_MEMBERS_TIMEOUT'));\n      }, time);\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_MEMBERS_CHUNK, handler);\n    });\n  }\n}\nmodule.exports = GuildMemberManager;","map":{"version":3,"names":["BaseManager","require","Error","TypeError","RangeError","GuildMember","Collection","Events","OPCodes","SnowflakeUtil","GuildMemberManager","constructor","guild","iterable","client","add","data","cache","id","user","extras","resolve","member","memberResolvable","userResolvable","users","resolveID","has","fetch","options","_fetchMany","_fetchSingle","Array","isArray","map","u","limit","withPresences","prune","days","dry","count","compute_prune_count","roles","reason","query","resolvedRoles","role","resolvedRole","Promise","reject","push","length","include_roles","join","endpoint","api","guilds","get","then","pruned","post","ban","delete_message_days","bans","put","_user","unban","delete","force","existing","partial","members","presences","user_ids","time","nonce","generate","memberCount","size","shard","send","op","REQUEST_GUILD_MEMBERS","d","guild_id","fetchedMembers","option","i","handler","_","chunk","timeout","refresh","values","set","clearTimeout","removeListener","GUILD_MEMBERS_CHUNK","decrementMaxListeners","fetched","first","setTimeout","incrementMaxListeners","on","module","exports"],"sources":["/Users/jessegill/node_modules/discord.js/src/managers/GuildMemberManager.js"],"sourcesContent":["'use strict';\n\nconst BaseManager = require('./BaseManager');\nconst { Error, TypeError, RangeError } = require('../errors');\nconst GuildMember = require('../structures/GuildMember');\nconst Collection = require('../util/Collection');\nconst { Events, OPCodes } = require('../util/Constants');\nconst SnowflakeUtil = require('../util/Snowflake');\n\n/**\n * Manages API methods for GuildMembers and stores their cache.\n * @extends {BaseManager}\n */\nclass GuildMemberManager extends BaseManager {\n  constructor(guild, iterable) {\n    super(guild.client, iterable, GuildMember);\n    /**\n     * The guild this manager belongs to\n     * @type {Guild}\n     */\n    this.guild = guild;\n  }\n\n  /**\n   * The cache of this Manager\n   * @type {Collection<Snowflake, GuildMember>}\n   * @name GuildMemberManager#cache\n   */\n\n  add(data, cache = true) {\n    return super.add(data, cache, { id: data.user.id, extras: [this.guild] });\n  }\n\n  /**\n   * Data that resolves to give a GuildMember object. This can be:\n   * * A GuildMember object\n   * * A User resolvable\n   * @typedef {GuildMember|UserResolvable} GuildMemberResolvable\n   */\n\n  /**\n   * Resolves a GuildMemberResolvable to a GuildMember object.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?GuildMember}\n   */\n  resolve(member) {\n    const memberResolvable = super.resolve(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveID(member);\n    if (userResolvable) return super.resolve(userResolvable);\n    return null;\n  }\n\n  /**\n   * Resolves a GuildMemberResolvable to a member ID string.\n   * @param {GuildMemberResolvable} member The user that is part of the guild\n   * @returns {?Snowflake}\n   */\n  resolveID(member) {\n    const memberResolvable = super.resolveID(member);\n    if (memberResolvable) return memberResolvable;\n    const userResolvable = this.client.users.resolveID(member);\n    return this.cache.has(userResolvable) ? userResolvable : null;\n  }\n\n  /**\n   * Options used to fetch a single member from a guild.\n   * @typedef {Object} FetchMemberOptions\n   * @property {UserResolvable} user The user to fetch\n   * @property {boolean} [cache=true] Whether or not to cache the fetched member\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Options used to fetch multiple members from a guild.\n   * @typedef {Object} FetchMembersOptions\n   * @property {UserResolvable|UserResolvable[]} user The user(s) to fetch\n   * @property {?string} query Limit fetch to members with similar usernames\n   * @property {number} [limit=0] Maximum number of members to request\n   * @property {boolean} [withPresences=false] Whether or not to include the presences\n   * @property {number} [time=120e3] Timeout for receipt of members\n   * @property {?string} nonce Nonce for this request (32 characters max - default to base 16 now timestamp)\n   * @property {boolean} [force=false] Whether to skip the cache check and request the API\n   */\n\n  /**\n   * Fetches member(s) from Discord, even if they're offline.\n   * @param {UserResolvable|FetchMemberOptions|FetchMembersOptions} [options] If a UserResolvable, the user to fetch.\n   * If undefined, fetches all members.\n   * If a query, it limits the results to users with similar usernames.\n   * @returns {Promise<GuildMember>|Promise<Collection<Snowflake, GuildMember>>}\n   * @example\n   * // Fetch all members from a guild\n   * guild.members.fetch()\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member\n   * guild.members.fetch('66564597481480192')\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch a single member without checking cache\n   * guild.members.fetch({ user, force: true })\n   *   .then(console.log)\n   *   .catch(console.error)\n   * @example\n   * // Fetch a single member without caching\n   * guild.members.fetch({ user, cache: false })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by an array of users including their presences\n   * guild.members.fetch({ user: ['66564597481480192', '191615925336670208'], withPresences: true })\n   *   .then(console.log)\n   *   .catch(console.error);\n   * @example\n   * // Fetch by query\n   * guild.members.fetch({ query: 'hydra', limit: 1 })\n   *   .then(console.log)\n   *   .catch(console.error);\n   */\n  fetch(options) {\n    if (!options) return this._fetchMany();\n    const user = this.client.users.resolveID(options);\n    if (user) return this._fetchSingle({ user, cache: true });\n    if (options.user) {\n      if (Array.isArray(options.user)) {\n        options.user = options.user.map(u => this.client.users.resolveID(u));\n        return this._fetchMany(options);\n      } else {\n        options.user = this.client.users.resolveID(options.user);\n      }\n      if (!options.limit && !options.withPresences) return this._fetchSingle(options);\n    }\n    return this._fetchMany(options);\n  }\n\n  /**\n   * Prunes members from the guild based on how long they have been inactive.\n   * <info>It's recommended to set options.count to `false` for large guilds.</info>\n   * @param {Object} [options] Prune options\n   * @param {number} [options.days=7] Number of days of inactivity required to kick\n   * @param {boolean} [options.dry=false] Get number of users that will be kicked, without actually kicking them\n   * @param {boolean} [options.count=true] Whether or not to return the number of users that have been kicked.\n   * @param {RoleResolvable[]} [options.roles=[]] Array of roles to bypass the \"...and no roles\" constraint when pruning\n   * @param {string} [options.reason] Reason for this prune\n   * @returns {Promise<number|null>} The number of members that were/will be kicked\n   * @example\n   * // See how many members will be pruned\n   * guild.members.prune({ dry: true })\n   *   .then(pruned => console.log(`This will prune ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Actually prune the members\n   * guild.members.prune({ days: 1, reason: 'too many people!' })\n   *   .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *   .catch(console.error);\n   * @example\n   * // Include members with a specified role\n   * guild.members.prune({ days: 7, roles: ['657259391652855808'] })\n   *    .then(pruned => console.log(`I just pruned ${pruned} people!`))\n   *    .catch(console.error);\n   */\n  prune({ days = 7, dry = false, count: compute_prune_count = true, roles = [], reason } = {}) {\n    if (typeof days !== 'number') throw new TypeError('PRUNE_DAYS_TYPE');\n\n    const query = { days };\n    const resolvedRoles = [];\n\n    for (const role of roles) {\n      const resolvedRole = this.guild.roles.resolveID(role);\n      if (!resolvedRole) {\n        return Promise.reject(new TypeError('INVALID_TYPE', 'roles', 'Array of Roles or Snowflakes', true));\n      }\n      resolvedRoles.push(resolvedRole);\n    }\n\n    if (resolvedRoles.length) {\n      query.include_roles = dry ? resolvedRoles.join(',') : resolvedRoles;\n    }\n\n    const endpoint = this.client.api.guilds(this.guild.id).prune;\n\n    if (dry) {\n      return endpoint.get({ query, reason }).then(data => data.pruned);\n    }\n\n    return endpoint\n      .post({\n        data: { ...query, compute_prune_count },\n        reason,\n      })\n      .then(data => data.pruned);\n  }\n\n  /**\n   * Bans a user from the guild.\n   * @param {UserResolvable} user The user to ban\n   * @param {Object} [options] Options for the ban\n   * @param {number} [options.days=0] Number of days of messages to delete, must be between 0 and 7\n   * @param {string} [options.reason] Reason for banning\n   * @returns {Promise<GuildMember|User|Snowflake>} Result object will be resolved as specifically as possible.\n   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot\n   * be resolved, the user ID will be the result.\n   * @example\n   * // Ban a user by ID (or with a user/guild member object)\n   * guild.members.ban('84484653687267328')\n   *   .then(user => console.log(`Banned ${user.username || user.id || user} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  ban(user, options = { days: 0 }) {\n    if (options.days) options.delete_message_days = options.days;\n    const id = this.client.users.resolveID(user);\n    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID', true));\n    return this.client.api\n      .guilds(this.guild.id)\n      .bans[id].put({ data: options })\n      .then(() => {\n        if (user instanceof GuildMember) return user;\n        const _user = this.client.users.resolve(id);\n        if (_user) {\n          const member = this.resolve(_user);\n          return member || _user;\n        }\n        return id;\n      });\n  }\n\n  /**\n   * Unbans a user from the guild.\n   * @param {UserResolvable} user The user to unban\n   * @param {string} [reason] Reason for unbanning user\n   * @returns {Promise<User>}\n   * @example\n   * // Unban a user by ID (or with a user/guild member object)\n   * guild.members.unban('84484653687267328')\n   *   .then(user => console.log(`Unbanned ${user.username} from ${guild.name}`))\n   *   .catch(console.error);\n   */\n  unban(user, reason) {\n    const id = this.client.users.resolveID(user);\n    if (!id) return Promise.reject(new Error('BAN_RESOLVE_ID'));\n    return this.client.api\n      .guilds(this.guild.id)\n      .bans[id].delete({ reason })\n      .then(() => this.client.users.resolve(user));\n  }\n\n  _fetchSingle({ user, cache, force = false }) {\n    if (!force) {\n      const existing = this.cache.get(user);\n      if (existing && !existing.partial) return Promise.resolve(existing);\n    }\n\n    return this.client.api\n      .guilds(this.guild.id)\n      .members(user)\n      .get()\n      .then(data => this.add(data, cache));\n  }\n\n  _fetchMany({\n    limit = 0,\n    withPresences: presences = false,\n    user: user_ids,\n    query,\n    time = 120e3,\n    nonce = SnowflakeUtil.generate(),\n    force = false,\n  } = {}) {\n    return new Promise((resolve, reject) => {\n      if (this.guild.memberCount === this.cache.size && !query && !limit && !presences && !user_ids && !force) {\n        resolve(this.cache);\n        return;\n      }\n      if (!query && !user_ids) query = '';\n      if (nonce.length > 32) throw new RangeError('MEMBER_FETCH_NONCE_LENGTH');\n      this.guild.shard.send({\n        op: OPCodes.REQUEST_GUILD_MEMBERS,\n        d: {\n          guild_id: this.guild.id,\n          presences,\n          user_ids,\n          query,\n          nonce,\n          limit,\n        },\n      });\n      const fetchedMembers = new Collection();\n      const option = query || limit || presences || user_ids;\n      let i = 0;\n      const handler = (members, _, chunk) => {\n        timeout.refresh();\n        if (chunk.nonce !== nonce) return;\n        i++;\n        for (const member of members.values()) {\n          if (option) fetchedMembers.set(member.id, member);\n        }\n        if (\n          this.guild.memberCount <= this.cache.size ||\n          (option && members.size < 1000) ||\n          (limit && fetchedMembers.size >= limit) ||\n          i === chunk.count\n        ) {\n          this.client.clearTimeout(timeout);\n          this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n          this.client.decrementMaxListeners();\n          let fetched = option ? fetchedMembers : this.cache;\n          if (user_ids && !Array.isArray(user_ids) && fetched.size) fetched = fetched.first();\n          resolve(fetched);\n        }\n      };\n      const timeout = this.client.setTimeout(() => {\n        this.client.removeListener(Events.GUILD_MEMBERS_CHUNK, handler);\n        this.client.decrementMaxListeners();\n        reject(new Error('GUILD_MEMBERS_TIMEOUT'));\n      }, time);\n      this.client.incrementMaxListeners();\n      this.client.on(Events.GUILD_MEMBERS_CHUNK, handler);\n    });\n  }\n}\n\nmodule.exports = GuildMemberManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}